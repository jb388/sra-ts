---
title: "Sierra Nevada Time Series"
author: "J. Beem-Miller"
date: "21 Oct 2020"
output:
  pdf_document:
    latex_engine: xelatex
  html_notebook:
    toc: yes
    toc_depth: 2
    css: custom.css
header_includes:
  - \usepackage[utf8]{inputenc}
  - \usepackage{float}
---
```{r global_options, include = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE,
                      fig.align = 'center', dev = 'cairo_pdf')
```

```{r setup, include = FALSE}
library(ggplot2)
library(dplyr)
library(ISRaD)
library(GSIF)
library(aqp)
library(SoilR)
library(FME)
```

# Data preparation script for Sierra Nevada time series analysis

```{r load ams-jena-ingest fx}
# 1. Read in isotope data from various sources
# First load helper functions 'read_jena_ams_results.R', 'read_jena_iso_results.R' 
source("./utilities/jena_ams_ingest.R")
source("./utilities/jena_iso_ingest.R")
source("./utilities/jena_elm_ingest.R")
```

```{r read-cn-iso-data, include = FALSE}
# 2. Next read in data from the appropriate directories in 'data/raw'
# 14C
# identify subdirectories in 'raw' directory with "ams_jena" in name
ams_jena_results_dirs <- list.files("../data/raw", pattern = "ams_jena_results", full.names = TRUE)
ams_results_ls <- lapply(seq_along(ams_jena_results_dirs), function(i) {
  read_jena_ams_results(ams_jena_results_dirs[i])
})
names(ams_results_ls) <- list.files("../data/raw", pattern = "ams_jena_results")

# # 13C
# # identify subdirectories in 'raw' directory with "iso_jena" in name
# iso_jena_results_dirs <- list.files("../data/raw", pattern = "iso_jena_results", full.names = TRUE)
# iso_results_ls <- lapply(seq_along(iso_jena_results_dirs), function(i) {
#   read_jena_iso_results(iso_jena_results_dirs[i])
# })
# names(iso_results_ls) <- list.files("../data/raw", pattern = "iso_jena_results")

# Read in C and N data
elm_results_dir <- list.files("../data/raw", pattern = "elm_jena_results", full.names = TRUE)
elm_results_ls <- lapply(seq_along(elm_results_dir), function(i) {
  read_jena_elm_results(elm_results_dir[i])
})
names(elm_results_ls) <- list.files("../data/raw", pattern = "elm_jena_results")
```

```{r data-template}
# Create template for bulk soil data
template19.fx <- function(pm, eco, ndepth) {
  df <- data.frame(Year = rep(2019, ndepth * 3),
                   PM = rep(pm, ndepth * 3),
                   ECO = rep(eco, ndepth * 3),
                   pro_rep = rep(seq(1,3), each = ndepth),
                   lyr_top = rep(seq(0, (ndepth-1) * 10, by = 10), 3),
                   lyr_bot = rep(seq(10, (ndepth) * 10, by = 10), 3))
  df$pro_name <- paste0(df$PM, df$ECO, "_", df$pro_rep)
  df$lyr_name <- paste0(df$pro_name, "_", df$lyr_top, "-", df$lyr_bot)
  return(df)
}

# Create template for composite soil data (incubations, density fractions, etc.)
template19.comp.fx <- function(pm, eco, ndepth) {
  df <- data.frame(Year = rep(2019, 3),
                   PM = rep(pm, 3),
                   ECO = rep(eco, 3),
                   lyr_top = rep(seq(0, (ndepth-1) * 10, by = 10)),
                   lyr_bot = rep(seq(10, (ndepth) * 10, by = 10)))
  df$pro_name <- paste0(df$PM, df$ECO, "_comp")
  df$lyr_name <- paste0(df$pro_name, "_", df$lyr_top, "-", df$lyr_bot)
  return(df)
}

# templates for bulk soil data
# GRrf 
GRrf <- template19.fx("GR", "rf", 7)
GRrf <- if(any(GRrf$lyr_name == "GRrf_1_60_70")) {
  GRrf <- GRrf[-which(GRrf$lyr_name == "GRrf_1_60_70"), ] # NB: GRrf_1_60_70 doesn't exist
} else {
  GRrf <- GRrf
}
# GRwf
GRwf <- template19.fx("GR", "wf", 9)
# GRpp
GRpp <- template19.fx("GR", "pp", 8)

# ANrf 
ANrf <- template19.fx("AN", "rf", 6)
# ANwf
ANwf <- template19.fx("AN", "wf", 6)
# ANpp
ANpp <- template19.fx("AN", "pp", 8)

# BSrf 
BSrf <- template19.fx("BS", "rf", 8)
BSrf <- if(any(BSrf$lyr_name == "GRrf_1_60_70")) {
  BSrf <- BSrf[-which(BSrf$lyr_name == "BSrf_1_70_80"), ] # NB: BSrf_1_70_80 doesn't exist
} else {
  BSrf <- BSrf
} 
# BSwf
BSwf <- template19.fx("BS", "wf", 7)
# BSpp
BSpp <- template19.fx("BS", "pp", 8)
BSpp[BSpp$lyr_bot == 80, "lyr_bot"] <- 75 # only sampled to 75cm, not 80

sra.2019.df <- rbind(GRrf, GRwf, GRpp,
                     ANrf, ANwf, ANpp,
                     BSrf, BSwf, BSpp)

# template for 2019 incubation data
GRrf_inc <- template19.comp.fx("GR", "rf", 3)
GRwf_inc <- template19.comp.fx("GR", "wf", 3)
GRpp_inc <- template19.comp.fx("GR", "pp", 3)

ANrf_inc <- template19.comp.fx("AN", "rf", 3)
ANwf_inc <- template19.comp.fx("AN", "wf", 3)
ANpp_inc <- template19.comp.fx("AN", "pp", 3)

BSrf_inc <- template19.comp.fx("BS", "rf", 3)
BSwf_inc <- template19.comp.fx("BS", "wf", 3)
BSpp_inc <- template19.comp.fx("BS", "pp", 3)

sra.2019.inc.df <- rbind(GRrf_inc, GRwf_inc, GRpp_inc,
                         ANrf_inc, ANwf_inc, ANpp_inc,
                         BSrf_inc, BSwf_inc, BSpp_inc)

# 2001 bulk soil template
sra.2001 <- vector(mode = "list", length = length(unique(sra.2019.df$pro_name)))
names(sra.2001) <- unique(sra.2019.df$pro_name)

# 2009 data (from C. Rasmussen)
ras18.lyr <- read.csv("/Users/jeff/R/14Constraint/ras_2018.csv")
ras18.lyr$ECO <- factor(ras18.lyr$MAST, labels = c("rf","wf","pp"))

# 2019 bulk soil template
sra.2019 <- sra.2001

# 2019 inc template
sra.2019.inc <- vector(mode = "list", length = length(unique(sra.2019.inc.df$pro_name)))
names(sra.2019.inc) <- unique(sra.2019.inc.df$pro_name)
# copies for reps of incubations
sra.2019.inc_1 <- sra.2019.inc
sra.2019.inc_2 <- sra.2019.inc
```

*Merge templates with 14C, C, and N data*

Radiocarbon analyses for the 2001 samples were not run originally, but were completed on archived samples in 2020.

```{r merge-iso-data-S01-soil}
# Extract 14C data for 2001 samples
ams_results_ls_S01 <- ams_results_ls[grep("S01", names(ams_results_ls))]
for(i in seq_along(sra.2001)) {
  sra.2001[[i]] <- lapply(ams_results_ls_S01, function(ls) {
    lapply(ls, function(df) {
      if(any(grepl(names(sra.2001)[i], df$Probe))) {
       df[grep(names(sra.2001)[i], df$Probe), ] 
      }
    })
  })
  sra.2001[[i]] <- Filter(Negate(is.null), unlist(sra.2001[[i]], recursive = FALSE))
}
sra.2001 <- bind_rows(unlist(sra.2001, recursive = FALSE))

# create ID field, trim df, and add depths
sra.2001$ID <- unlist(strsplit(sra.2001$Probe, "_Sierra Nevada_2001"))
sra.2001 <- sra.2001[ , c("ID", "F14C", "err", "∆14C.(‰)", "err.(‰)")]
names(sra.2001) <- c("ID", "fm", "fm_err", "d14c", "d14c_err")
sra.2001$lyr_top <- as.numeric(ifelse(substr(sra.2001$ID, 9, 9) == "-",
                                      substr(sra.2001$ID, 8, 8),
                                      substr(sra.2001$ID, 8, 9)))
sra.2001$lyr_bot <- as.numeric(ifelse(substr(sra.2001$ID, 9, 9) == "-", 
                                      substr(sra.2001$ID, 10, nchar(sra.2001$ID)),
                                      substr(sra.2001$ID, 11, nchar(sra.2001$ID))))
sra.2001$pro_rep <- substr(sra.2001$ID, 6, 6)
sra.2001$PM <- factor(substr(sra.2001$ID, 1, 2))
sra.2001$ECO <- factor(substr(sra.2001$ID, 3, 4), levels = c("pp", "wf", "rf"))
sra.2001$pro_name <- substr(sra.2001$ID, 1, 6)
sra.2001$PMeco <- substr(sra.2001$ID, 1, 4)

# remove outlier ANpp sample
sra.2001 <- sra.2001[-which(sra.2001$ID == "ANpp_3_6-13"), ]

# make list by PMeco
sra.2001.ls <- split(sra.2001, sra.2001$PMeco)
```

```{r merge-iso-data-soil-S19}
# Extract 14C data for 2019 samples
ams_results_ls_S19 <- ams_results_ls[grep("soil-S19", names(ams_results_ls))]
for(i in seq_along(sra.2019)) {
  sra.2019[[i]] <- lapply(ams_results_ls_S19, function(ls) {
    lapply(ls, function(df) {
      if(any(grepl(names(sra.2019)[i], df$Probe))) {
       df[grep(names(sra.2019)[i], df$Probe), ] 
      }
    })
  })
  sra.2019[[i]] <- Filter(Negate(is.null), unlist(sra.2019[[i]], recursive = FALSE))
}
sra.2019 <- bind_rows(unlist(sra.2019, recursive = FALSE))

## merge w/ 2019 template
# rename cols in AMS tables
sra.2019 <- sra.2019[ , c("Probe", "F14C", "err", "∆14C.(‰)", "err.(‰)")]
names(sra.2019) <- c("ID", "fm", "fm_err", "d14c", "d14c_err")
# merge
sra.2019.ls <- lapply(split(sra.2019.df, sra.2019.df$lyr_name), function(df) {
  df <- merge(df, sra.2019[grep(df$lyr_name, sra.2019$ID), ])
  df$ID <- NULL
  df$PMeco <- paste0(df$PM, df$ECO)
  return(df)
})

# reshape list by PMeco
sra.2019.ls <- split(bind_rows(sra.2019.ls), bind_rows(sra.2019.ls)[["PMeco"]])
```

```{r merge-iso-data-co2-S19}
# Extract 14C data for 2019 samples
# rep 1 data
ams_results_ls_co2_S19_1 <- ams_results_ls[grep("co2-S19-1", names(ams_results_ls))]
for(i in seq_along(sra.2019.inc)) {
  sra.2019.inc_1[[i]] <- lapply(ams_results_ls_co2_S19_1, function(ls) {
    lapply(ls, function(df) {
      if(any(grepl(names(sra.2019.inc)[i], df$Probe))) {
       df[grep(names(sra.2019.inc)[i], df$Probe), ] 
      }
    })
  })
  sra.2019.inc_1[[i]] <- Filter(Negate(is.null), unlist(sra.2019.inc_1[[i]], recursive = FALSE))
}
sra.2019.inc_1 <- bind_rows(unlist(sra.2019.inc_1, recursive = FALSE))

## merge w/ 2019 template
# rename cols in AMS tables
sra.2019.inc_1 <- sra.2019.inc_1[ , c("Probe", "F14C", "err", "∆14C.(‰)", "err.(‰)")]
names(sra.2019.inc_1) <- c("ID", "fm", "fm_err", "d14c", "d14c_err")
# merge
sra.2019.inc.ls_1 <- lapply(split(sra.2019.inc.df, sra.2019.inc.df$lyr_name), function(df) {
  df <- merge(df, sra.2019.inc_1[grep(df$lyr_name, sra.2019.inc_1$ID), ])
  df$ID <- NULL
  df$PMeco <- paste0(df$PM, df$ECO)
  return(df)
})

# reshape list by PMeco
sra.2019.inc.ls_1 <- split(bind_rows(sra.2019.inc.ls_1), bind_rows(sra.2019.inc.ls_1)[["PMeco"]])
```

```{r plot-2001-profiles, include = FALSE}
pro.plot <- function(df, maxDepth, min14C, rep) {
  ggplot(df, aes(d14c, lyr_bot, color = PM, shape = ECO, group = rep)) +
    geom_vline(xintercept = 0) +
    geom_hline(yintercept = 0) +
    geom_point(size = 3) +
    geom_path() +
    scale_y_reverse(limits = c(maxDepth, 0)) +
    scale_x_continuous(limits = c(min14C, 180)) +
    scale_color_manual(name = "parent material",
                       labels = c("AN" = "andesite",
                                  "BS" = "basalt",
                                  "GR" = "granite"),
                       values = c("AN" = "blue", 
                                  "BS" = "red", 
                                  "GR" = "darkgray")) +
    scale_shape_manual(name = "ecosystem",
                       labels = c("pp" = expression(italic("P. ponderosa")),
                                  "rf" = expression(italic("A. magnifica")),
                                  "wf" = expression(italic("A. concolor"))),
                       values = c("pp" = 15, 
                                  "rf" = 16, 
                                  "wf" = 17)) +
    xlab(expression(Delta*''^14*'C (‰)')) +
    ylab("Depth (cm)") +
    theme_bw() +
    theme(panel.grid.minor = element_blank())
}

# lapply(sra.2001.ls, function(df) pro.plot(df, max(df$lyr_bot), min(df$d14c), df$pro_rep))
```

```{r plot-2019-profiles, include = FALSE}
# lapply(sra.2019.ls, function(df) pro.plot(df, max(df$lyr_bot), min(df$d14c), df$pro_rep))
```

```{r plot-2019-co2-profiles, include = FALSE}
# lapply(sra.2019.inc.ls_1, function(df) pro.plot(df, max(df$lyr_bot), min(df$d14c), NA))
```

## 2001 mean radiocarbon profiles
```{r plot-2001-avg-profiles}
# fm and d14c conversion functions
lambda <- 1/8267 # = 1/(true mean life of 14C)
calc_fm <- function(d14c, obs_date_y) {
  ((d14c/1000) + 1)/exp(lambda * (1950 - obs_date_y))
}
calc_14c <- function(fm, obs_date_y) {
  (fm * exp(lambda * (1950 - obs_date_y)) - 1) * 1000
}

# calc atm in 2001, 2009, 2019
Datm <- rbind(graven, future14C)
atm.d14.2001 <- Datm[Datm$Date == 2001.5, "NHc14"]
atm.fm.2001 <- calc_fm(atm.d14.2001, 2001)
atm.d14.2009 <- Datm[Datm$Date == 2009.5, "NHc14"]
atm.fm.2009 <- calc_fm(atm.d14.2009, 2009)
atm.d14.2019 <- Datm[Datm$Date == 2019.5, "NHc14"]
atm.fm.2019 <- calc_fm(atm.d14.2019, 2019)

# combine reps
sra.2001.sum.ls  <- lapply(sra.2001.ls, function(df) {
  df <- data.frame(df %>%
                     filter(lyr_bot <= 40) %>%
                     mutate(lyr_top_ch = as.character(lyr_top),
                            lyr_bot_ch = as.character(lyr_bot)) %>%
                     select(PM, ECO, PMeco, fm, d14c, lyr_top_ch, lyr_bot_ch) %>%
                     group_by(PM, ECO, PMeco, lyr_top_ch, lyr_bot_ch) %>%
                     summarize_all(list(mean = mean, sd = sd), na.rm = TRUE))
  names(df) <- c("PM", "ECO", "PMeco", "lyr_top", "lyr_bot", "fm", "d14c", "fm_sd", "d14c_sd")
  df$lyr_top <- as.numeric(df$lyr_top)
  df$lyr_bot <- as.numeric(df$lyr_bot)
  return(df)
})
sra.01.sum <- bind_rows(sra.2001.sum.ls)
sra.01.sum <- sra.01.sum[order(sra.01.sum$lyr_bot), ]

sra.01.sum <- sra.01.sum %>%
  mutate(d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite")))

# plot
fig.n <- 1
sra.01.sum %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = eco, group = PMeco)) +
  geom_vline(xintercept = atm.d14.2001) +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  geom_path() +
  scale_y_reverse(limits = c(40, 0)) +
  scale_x_continuous(limits = c(-100, 180)) +    
  scale_color_manual(name = "parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Mean profile $\Delta$^14^C for 2001 samples**

>*Caption:* Mean $\Delta$^14^C by depth for each site in 2001. Error bars show ±1 standard deviation, solid vertical line shows $\Delta$^14^C of the atmosphere in the year of sampling.

## 2009 radiocarbon profiles
```{r plot-2009-profiles}
# add PMeco col
ras18.lyr$ECO <- factor(ras18.lyr$MAST, labels = c("rf","wf","pp"))
ras18.lyr$PMeco <- paste0(ras18.lyr$PM, ras18.lyr$ECO)

sra.09.sum <- ras18.lyr %>%
  mutate(eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite")))

fig.n <- fig.n + 1
sra.09.sum %>%
  ggplot(., aes(lyr_14c, lyr_bot, color = pm, shape = eco, group = PMeco)) +
  geom_vline(xintercept = atm.d14.2009) +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_path(linetype = "dashed") +
  scale_y_reverse() +
  scale_x_continuous(limits = c(-100, 180)) +    
  scale_color_manual(name = "parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "ecosystem",
                     values = c("warm" = 0, 
                                "cool" = 1, 
                                "cold" = 2)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Profile $\Delta$^14^C for 2009 samples**

>*Caption:* Profile $\Delta$^14^C by depth for each site in 2009. Solid vertical line shows $\Delta$^14^C of the atmosphere in the year of sampling. Error bars not shown as only a single replicate profile was analyzed per site.

## 2019 mean radiocarbon profiles
```{r plot-2019-avg-profiles}
# combine reps
sra.2019.sum.ls  <- lapply(sra.2019.ls, function(df) {
  df <- data.frame(df %>%
                     mutate(lyr_top_ch = as.character(lyr_top),
                            lyr_bot_ch = as.character(lyr_bot)) %>%
                     select(PM, ECO, PMeco, fm, d14c, lyr_top_ch, lyr_bot_ch) %>%
                     group_by(PM, ECO, PMeco, lyr_top_ch, lyr_bot_ch) %>%
                     summarize_all(list(mean = mean, sd = sd), na.rm = TRUE))
  names(df) <- c("PM", "ECO", "PMeco", "lyr_top", "lyr_bot", "fm", "d14c", "fm_sd", "d14c_sd")
  df$lyr_top <- as.numeric(df$lyr_top)
  df$lyr_bot <- as.numeric(df$lyr_bot)
  return(df)
})
sra.19.sum <- bind_rows(sra.2019.sum.ls)

sra.19.sum <- sra.19.sum %>%
  mutate(d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) 

# plot
fig.n <- fig.n + 1
sra.19.sum %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = eco, group = PMeco)) +
  geom_vline(xintercept = atm.d14.2019) +
  geom_hline(yintercept = 0) +
  geom_point(size = 2.7) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  geom_path() +
  scale_y_reverse(limits = c(max(sra.19.sum$lyr_bot), 0)) +
  scale_x_continuous(limits = c(min(sra.19.sum$d14c), 180)) +    
  scale_color_manual(name = "parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Mean profile $\Delta$^14^C for 2019 samples**

>*Caption:* Mean $\Delta$^14^C by depth for each site in 2019. Error bars show ±1 standard deviation, solid vertical line shows $\Delta$^14^C of the atmosphere in the year of sampling.

## Change in $\Delta$^14^C over time between 2001 and 2019 

```{r plot-all-avg}
# combine '01 and '19 data for plotting
sra.01.sum$Year <- 2001
sra.19.sum$Year <- 2019

sra.all <- rbind(sra.01.sum, sra.19.sum)
sra.all$Year <- as.factor(sra.all$Year)

fig.n <- fig.n + 1
sra.all %>%
  mutate(PMeco_year = paste0(PMeco, Year),
         ecoYear = paste0(ECO, Year),
         ecoYear2 = ifelse(ecoYear == "pp2001", "warm (2001)",
                           ifelse(ecoYear == "pp2019", "warm (2019)",
                                  ifelse(ecoYear == "wf2001", "cool (2001)",
                                         ifelse(ecoYear == "wf2019", "cool (2019)",
                                                ifelse(ecoYear == "rf2001", "cold (2001)", "cold (2019)")))))) %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = ecoYear2, group = PMeco_year)) +
  geom_vline(xintercept = atm.d14.2001) +
  geom_vline(xintercept = atm.d14.2019, linetype = "dashed") +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  geom_path(aes(linetype = Year)) +
  scale_y_reverse(limits = c(41, 0)) +
  scale_color_manual(name = "parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem (year)",
                     values = c("warm (2001)" = 15, 
                                "cool (2001)" = 16, 
                                "cold (2001)" = 17,
                                "warm (2019)" = 0, 
                                "cool (2019)" = 1, 
                                "cold (2019)" = 2)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Mean profile $\Delta$^14^C for 2001 and 2019 samples**

>*Caption:* Mean $\Delta$^14^C by depth for each site in 2001 and 2019. Error bars show ±1 standard deviation. Vertical lines show $\Delta$^14^C of the atmosphere in 2001 (solid) and 2019 (dashed).

## Incubation $\Delta$^14^C-CO~2~ for 2019 bulk soils

```{r plot-inc-d14c}
sra.2019.inc.df_1 <- bind_rows(sra.2019.inc.ls_1)

fig.n <- fig.n + 1
sra.2019.inc.df_1 %>%
  mutate(d14c = replace(d14c, which(d14c < -300), NA), # remove GRrf 10-20 point
         eco = factor(ifelse(ECO == "pp", "warm",
                             ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = ECO)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  # geom_errorbarh(
  #   aes(xmin = d14c_l, 
  #       xmax = d14c_u,
  #       color = pm), 
  #   height = 1.5) +
  geom_path(linetype = "dashed") +
  scale_y_reverse() +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("pp" = 0, 
                                "wf" = 1, 
                                "rf" = 2),
                     labels = c("pp" = "warm", 
                                "wf" = "cool", 
                                "rf" = "cold")) +
  xlab(expression('Incubation '*Delta*''^14*'C-CO'[2]*' (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(ECO)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Rep 1 $\Delta$^14^C-CO~2~ of 2019 bulk soil incubations**

>*Caption:* $\Delta$^14^CO~2~ by depth for each site in 2019. (Still waiting for data from laboratory duplicates). Note that the 10-20 cm increment sample from the cold granite site appears to have been contaminated: $\Delta$^14^C-CO~2~ = `r {sra.2019.inc.df_1[sra.2019.inc.df_1$PMeco == "GRrf" & sra.2019.inc.df_1$lyr_bot == 20, "d14c"]}`.

## Incubation vs. bulk soil $\Delta$^14^C

```{r plot-inc-bulk-d14c}
# bind rows of inc list
sra.19.inc <- sra.2019.inc.df_1[ , !(names(sra.2019.inc.df_1) %in% c("fm", "fm_err"))]
sra.19.inc$Type <- "inc"
sra.19.inc$d14c_l <- NA
sra.19.inc$d14c_u <- NA

# rbind bulk data
sra.19.bulk <- sra.19.inc
sra.19.bulk[ , c("d14c", "d14c_l", "d14c_u")] <- sra.19.sum[which(sra.19.sum$lyr_bot < 31), c("d14c", "d14c_l", "d14c_u")]
sra.19.bulk$Type <- "bulk"
sra.19.inc.blk <- rbind(sra.19.inc, sra.19.bulk)

fig.n <- fig.n + 1
sra.19.inc.blk %>%
  mutate(ECOtype = paste0(ECO, Type),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = ECOtype, linetype = Type)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  geom_path() +
  scale_y_reverse() +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem (type)",
                     values = c("ppbulk" = 15, 
                                "wfbulk" = 16, 
                                "rfbulk" = 17,
                                "ppinc" = 0, 
                                "wfinc" = 1, 
                                "rfinc" = 2),
                     labels = c("ppbulk" = "warm (bulk)", 
                                "wfbulk" = "cool (bulk)", 
                                "rfbulk" = "cold (bulk)",
                                "ppinc" ="warm (inc)", 
                                "wfinc" = "cool (inc)", 
                                "rfinc" = "cold (inc)")) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. $\Delta$^14^C of 2019 bulk soil incubations and corresponding bulk soil**

>*Caption:* $\Delta$^14^C of bulk soil and respired CO~2~ by depth for each site in 2019. Error bars show one standard deviation for bulk soil, points show mean of three replicate profiles for bulk soils and single observations for respired CO~2~ (still waiting for data from laboratory duplicates). 

```{r plot-inc-bulk-14c-2019}
# first merge mean 14C data from 2019 samples with composite incubation data
nms.inc.blk <- c("PM", "ECO", "PMeco", "lyr_top", "lyr_bot", "Year")
sra.19.inc.blk2 <- merge(sra.19.sum[which(sra.19.sum$lyr_bot < 31), c(nms.inc.blk, "d14c", "d14c_u", "d14c_l")], 
                        sra.2019.inc.df_1[ , c(nms.inc.blk, "d14c")],
                        by = nms.inc.blk, suffixes = c(".bulk", ".inc"))

# regress bulk vs. inc
min.inc.blk <- min(sra.19.inc.blk2$d14c_l) # exclude highly negative incubation sample from GRwf
max.inc.blk <- max(sra.19.inc.blk2$d14c_u, sra.19.inc.blk$d14c.inc)

# What is the ideal grouping/expected relationship?
fig.n <- fig.n + 1
sra.19.inc.blk2 %>%
  mutate(depth = ifelse(lyr_top == 0, "0-10cm", ifelse(lyr_top == 10, "10-20cm", "20-30cm"))) %>%
  ggplot(., aes(d14c.bulk, d14c.inc, color = PM, shape = ECO, group = PM)) +
  # geom_vline(xintercept = atm.d14.2019, linetype = "dashed") +
  geom_vline(xintercept = 0) +
  # geom_hline(yintercept = atm.d14.2019, linetype = "dashed") +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  # geom_smooth(method = "lm", se = FALSE) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = PM), 
    height = 1.5) +
  scale_color_manual(name = "Parent material",
                     values = c("AN" = "blue",
                                "BS" = "red",
                                "GR" = "darkgray"),
                     labels = c("AN" = "andesite",
                                "BS"= "basalt",
                                "GR" = "granite")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("pp" = 0,
                                "wf" = 1,
                                "rf" = 2),
                     labels = c("pp" = "warm",
                                "wf" = "cool",
                                "rf" = "cold")) +
  scale_x_continuous(limits = c(min.inc.blk, max.inc.blk)) +
  scale_y_continuous(limits = c(min.inc.blk, max.inc.blk)) +
  coord_fixed() +
  xlab(expression('Bulk soil '*Delta*''^14*'C (‰)')) +
  ylab(expression('Incubation '*Delta*''^14*'C (‰)')) +
  facet_grid(cols = vars(depth)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())

# all depths together, by PM
# sra.19.inc.blk %>%
#   mutate(depth = ifelse(lyr_top == 0, "0-10cm", ifelse(lyr_top == 10, "10-20cm", "20-30cm"))) %>%
#   ggplot(., aes(d14c.bulk, d14c.inc, color = depth, shape = ECO)) +
#   geom_vline(xintercept = atm.d14.2019, linetype = "dashed") +
#   geom_vline(xintercept = 0) +
#   geom_hline(yintercept = atm.d14.2019, linetype = "dashed") +
#   geom_hline(yintercept = 0) +
#   geom_point(size = 3) +
#   geom_errorbarh(
#     aes(xmin = d14c_l, 
#         xmax = d14c_u,
#         color = depth), 
#     height = 1.5) +
#   scale_shape_manual(name = "Ecosystem",
#                      values = c("pp" = 0, 
#                                 "wf" = 1, 
#                                 "rf" = 2)) +
#   scale_x_continuous(limits = c(min.inc.blk, max.inc.blk)) +
#   scale_y_continuous(limits = c(min.inc.blk, max.inc.blk)) +
#   coord_fixed() +
#   xlab(expression('Bulk soil '*Delta*''^14*'C (‰)')) +
#   ylab(expression('Incubation '*Delta*''^14*'C (‰)')) +
#   facet_grid(cols = vars(PM)) +
#   theme_bw() +
#   theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Regression of 2019 bulk soil incubations and corresponding bulk soil $\Delta$^14^C**

>*Caption:* Regressions of $\Delta$^14^C of bulk soil and respired CO~2~ by depth for each site in 2019. Error bars show one standard deviation for bulk soil, points show mean of three replicate profiles for bulk soils and single observations for respired CO~2~ (still waiting for data from laboratory duplicates).

## Time series: $\Delta$^14^C by depth (as measured)
```{r plot-timeseries-meas-depths}
# combine '01, '09, '19 data
sra.01.09.19.raw <- rbind(bind_rows(sra.2001.sum.ls),
                          bind_rows(sra.2019.sum.ls))
sra.2009.ls <- split(ras18.lyr, ras18.lyr$PMeco)
sra.2009.df <- bind_rows(sra.2009.ls)
colnames(sra.2009.df)[which(colnames(sra.2009.df) == "lyr_14c")] <- "d14c"
sra.2009.df <- sra.2009.df[ , which(names(sra.2009.df) %in% names(sra.01.09.19.raw))]
sra.2009.df <- cbind(sra.2009.df, 
                     fm = NA,
                     d14c_sd = NA,
                     fm_sd = NA)
sra.01.09.19.raw <- rbind(sra.01.09.19.raw, sra.2009.df)
sra.01.09.19.raw$Year <- factor(c(rep(2001, nrow(bind_rows(sra.2001.sum.ls))),
                                  rep(2019, nrow(bind_rows(sra.2019.sum.ls))),
                                  rep(2009, nrow(sra.2009.df))),
                                levels = c("2001", "2009", "2019"))

# plot
# w/ ribbons
# sra.01.09.19.raw %>%
#   mutate(PMeco_year = paste0(PMeco, Year),
#          eco = factor(ifelse(ECO == "pp", "warm",
#                       ifelse(ECO == "wf", "cool", "cold")),
#                       levels = c("warm", "cool", "cold")),
#          d14c_u = d14c + d14c_sd,
#          d14c_l = d14c - d14c_sd,
#          pm = ifelse(PM == "AN", "andesite",
#                      ifelse(PM == "BS", "basalt", "granite"))) %>%
#   ggplot(., aes(d14c, lyr_bot, group = PMeco_year)) +
#   geom_vline(xintercept = 0) +
#   geom_hline(yintercept = 0) +
#   geom_ribbon(aes(xmin = d14c_l, xmax = d14c_u, fill = pm, alpha = Year, group = PMeco_year),
#               color = NA, show.legend = FALSE) +
#   geom_point(aes(fill = pm, color = pm, shape = eco, alpha = Year), size = 2) +
#   geom_point(aes(shape = eco), color = "black", size = 3) +
#   geom_path(aes(linetype = Year, color = pm), size = 0.7) +
#   scale_y_reverse() +
#   scale_color_manual(name = "Parent material",
#                      values = c("andesite" = "blue", 
#                                 "basalt" = "red", 
#                                 "granite" = "darkgray")) +
#   scale_fill_manual(name = "Parent material",
#                     values = c("andesite" = "blue", 
#                                "basalt" = "red", 
#                                "granite" = "darkgray")) +
#   scale_shape_manual(name = "Ecosystem",
#                      values = c("warm" = 22, 
#                                 "cool" = 21, 
#                                 "cold" = 24)) +
#   scale_alpha_manual(values = c("2001" = .6,
#                                 "2009" = 0.4,
#                                 "2019" = 0.2)) +
#   facet_grid(rows = vars(eco), cols = vars(pm)) +
#   xlab(expression(Delta*''^14*'C (‰)')) +
#   ylab("Depth (cm)") +
#   theme_bw() +
#   theme(panel.grid.minor = element_blank())

# with error bars
# sra.01.09.19.raw %>%
#   mutate(PMeco_year = paste0(PMeco, Year),
#          eco = factor(ifelse(ECO == "pp", "warm",
#                       ifelse(ECO == "wf", "cool", "cold")),
#                       levels = c("warm", "cool", "cold")),
#          d14c_u = d14c + d14c_sd,
#          d14c_l = d14c - d14c_sd,
#          pm = ifelse(PM == "AN", "andesite",
#                      ifelse(PM == "BS", "basalt", "granite"))) %>%
#   ggplot(., aes(d14c, lyr_bot, group = PMeco_year)) +
#   geom_vline(xintercept = 0) +
#   geom_hline(yintercept = 0) +
#   geom_point(aes(fill = pm, color = pm, shape = eco, alpha = Year), size = 3.5) +
#   geom_path(aes(linetype = Year, color = pm), size = 0.7) +
#   geom_errorbarh(
#     aes(xmin = d14c_l,
#         xmax = d14c_u,
#         color = pm,
#         alpha = Year),
#     height = 1.5) +
#   scale_y_reverse() +
#   scale_color_manual(name = "Parent material",
#                      values = c("andesite" = "blue", 
#                                 "basalt" = "red", 
#                                 "granite" = "darkgray")) +
#   scale_fill_manual(name = "Parent material",
#                     values = c("andesite" = "blue", 
#                                "basalt" = "red", 
#                                "granite" = "darkgray")) +
#   scale_shape_manual(name = "Ecosystem",
#                      values = c("warm" = 15, 
#                                 "cool" = 16, 
#                                 "cold" = 17)) +
#   scale_alpha_manual(values = c("2001" = 1,
#                                 "2009" = 0.6,
#                                 "2019" = 0.3)) +
#   facet_grid(rows = vars(eco), cols = vars(pm)) +
#   xlab(expression(Delta*''^14*'C (‰)')) +
#   ylab("Depth (cm)") +
#   theme_bw() +
#   theme(panel.grid.minor = element_blank())

# just topsoil, w/ error bars
fig.n <- fig.n + 1
sra.01.09.19.raw <- sra.01.09.19.raw[order(sra.01.09.19.raw$lyr_top), ]
sra.01.09.19.raw %>%
  mutate(PMeco_year = paste0(PMeco, Year),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  ggplot(., aes(d14c, lyr_bot, group = PMeco_year)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point(aes(fill = pm, color = pm, shape = eco, alpha = Year), size = 3) +
  geom_path(aes(linetype = Year, color = pm), size = 0.7) +
  geom_errorbarh(
    aes(xmin = d14c_l,
        xmax = d14c_u,
        color = pm,
        alpha = Year),
    height = 1.5) +
  scale_y_reverse(limits = c(41, 0)) +
  scale_x_continuous(limits = c(-160, 190)) +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_fill_manual(name = "Parent material",
                    values = c("andesite" = "blue", 
                               "basalt" = "red", 
                               "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  scale_alpha_manual(values = c("2001" = 1,
                                "2009" = 0.6,
                                "2019" = 0.3)) +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Time series of $\Delta$^14^C by depth, as measured**

>*Caption:* Points show mean of three profile replicates for 2001 and 2019 samples. Error bars show ± 1 standard deviation of the mean (only a single profile was analyzed in 2009). 

## Spline fitting
*Fit splines to 2009 data to predict at 2001 depths*

Soils collected in both the 2001 and 2009 sampling campaigns were sampled by horizon, but the depth intervals differed between the two sampling years. In 2009, full profiles were excavated for each site, as opposed to the shorter profiles collected in 2001 from the GR and AN sites. Radiocarbon was measured on all three replicate profiles at each site for the 2001 samples, but only for one of the replicate profiles at each site in 2009, e.g. ANpp rep2, etc.

In order to compare the radiocarbon profiles between 2001, 2009, and 2019 we interpolated both radiocarbon and carbon stock data at 1 cm intervals for each site in the 2009 and 2019 datasets, and then summed the carbon-stock-weighted radiocarbon values for each depth interval sampled in 2001. A monotonic cubic spline fit was used for the carbon stock interpolation (Wendt and Hauser 2013), and a mass-preserving spline was used to fit the radiocarbon data (Bishop, T.F.A., McBratney, A.B., Laslett, G.M., (1999) Modelling soil attribute depth functions with equal-area quadratic smoothing splines. Geoderma, 91(1-2): 27-45).

```{r cn-clean, include = FALSE}
elm_results_df <- bind_rows(unlist(elm_results_ls, recursive = FALSE))
# Split IDs
PMeco_rep_depth <- bind_rows(
  lapply(strsplit(elm_results_df$ID, "_"), function(x) { 
    df <-  data.frame(PMeco = x[2],
                      pro_rep = x[3],
                      depth = x[4])
    df$PM <- substr(df$PMeco, 1, 2)
    df$ECO <- substr(df$PMeco, 3, 4)
    return(df)
  })
)
elm_results_df <- cbind(elm_results_df, PMeco_rep_depth)
```

```{r soc-2001, include = FALSE}
# add SOC data (lyr_soc_kgm2) to sra.2001.ls
soc.2001 <- data.frame(read_excel("../data/external/sra_ras_sum/sierra_data_summary_2020.xlsx",
                                  sheet = "2001_bulk_data"))
soc.2001 <- type.convert(soc.2001[complete.cases(soc.2001), ])
soc.2001$lyr_soc_kgm2 <- soc.2001$C. * soc.2001$bd.g.cm3 * soc.2001$lyr_bot - soc.2001$lyr_top * 10^-1
nms.2001 <- c("PMeco", "lyr_top", "lyr_bot", "pro_rep")
sra.2001.ls <- lapply(sra.2001.ls, function(df) {
  merge(df, soc.2001[ , c(nms.2001, "lyr_soc_kgm2")], by = nms.2001)
})

# calculate cumulative stocks
# order 2001 data
sra.2001.ls <- lapply(sra.2001.ls, function(df) {
  ls <- split(df, df$pro_name)
  ls <- lapply(ls, function(x) {
    x <- x[order(x$lyr_bot), ]
    x$lyr_soc_cmtv <- NA
    for(i in seq_along(x$lyr_bot)) {
      if(i == 1) {
        x$lyr_soc_cmtv[i] <- x$lyr_soc_kgm2[i]
      } else {
        x$lyr_soc_cmtv[i] <- x$lyr_soc_kgm2[i] + x$lyr_soc_cmtv[i-1] 
      }
    }
    return(x)
  })
  return(unsplit(ls, df$pro_name))
})
```

```{r spline-fm, include = FALSE}
## spline fit for fm
sra.2001.fm.sp <- lapply(sra.2001.ls, function(df) {
  lapply(split(df, df$pro_name), function(x) {
    depths(x) <- pro_name ~ lyr_top + lyr_bot
    x.mps <- mpspline(x, var.name = "fm")
    x.mps$var.1cm <- x.mps$var.1cm[1:max(x$lyr_bot)]
    return(x.mps)
  })
})
# 2009
sra.2009.fm.sp <- lapply(sra.2009.ls, function(x) {
  depths(x) <- pro_name ~ lyr_top + lyr_bot
  x.mps <- mpspline(x, var.name = "lyr_fraction_modern")
  x.mps$var.1cm <- x.mps$var.1cm[1:max(x$lyr_bot)]
  return(x.mps)
})
# 2019
sra.2019.fm.sp <- lapply(sra.2019.ls, function(df) {
  lapply(split(df, df$pro_name), function(x) {
    depths(x) <- pro_name ~ lyr_top + lyr_bot
    x.mps <- mpspline(x, var.name = "fm")
    x.mps$var.1cm <- x.mps$var.1cm[1:max(x$lyr_bot)]
    return(x.mps)
  })
})
```

```{r spline-bd-soc-19, include = FALSE}
# Need SOC stock data for 2019 samples: use BD from 2009 samples 
# spline fit for bulk density
sra.2009.bd.sp <- lapply(sra.2009.ls, function(x) {
  depths(x) <- pro_name ~ lyr_top + lyr_bot
  x.mps <- mpspline(x, var.name = "lyr_bd_samp")
  x.mps$var.1cm <- x.mps$var.1cm[1:100]
  return(x.mps)
})
sra.2009.bd.sp <- lapply(sra.2009.bd.sp, function(ls) {
  df <- data.frame(ls["var.1cm"])
  ix <- which(is.na(df$var.1cm))
  df$var.1cm[ix] <- df$var.1cm[ix[1]-1]
  return(df)
})

# calculate mean of 1cm BD predictions for each depth increment
bd_pred <- lapply(seq_along(sra.2009.bd.sp), function(i) {
  ls <- split(sra.2019.ls[[i]], sra.2019.ls[[i]]["pro_rep"]) # split each replicate profile
  ls <- lapply(seq_along(ls), function(df) {
    d <- ls[[df]][["lyr_bot"]] # depth intervals
    c <- vector(mode = "list", length = length(d)) # vector for averaging 1 cm bd pred
    for(j in seq_along(d)) {
      if(j == 1) {
        c[[j]] <- mean(sra.2009.bd.sp[[i]][1:d[j], "var.1cm"]) # 1-10
      } else {
        c[[j]] <- mean(sra.2009.bd.sp[[i]][(d[j-1]+1):d[j], "var.1cm"]) # 10 cm increments
      }
    }
    return(unlist(c))
    })
  return(unsplit(ls, sra.2019.ls[[i]]["pro_rep"]))
})

# merge predicted bd values with sra.2019.ls
nms <- names(sra.2019.ls)
sra.2019.ls <- lapply(seq_along(sra.2019.ls), function(df) {
  cbind(sra.2019.ls[[df]], bd = bd_pred[[df]])
})
names(sra.2019.ls) <- nms

# add c conc
sra.2019.ls <- lapply(sra.2019.ls, function(df) {
  df$depth <- paste0(df$lyr_top, "-", df$lyr_bot)
  df <- merge(df, elm_results_df[ , c("PMeco", "pro_rep", "depth", "C", "N")], by = c("PMeco", "depth", "pro_rep"))
  return(df)
})

# calculate stocks
sra.2019.ls <- lapply(sra.2019.ls, function(df) {
  df$lyr_soc <- df$bd * df$C # units work out to kg_m2 
  return(df)
})
# calculate cmtv stocks
sra.2019.ls <- lapply(sra.2019.ls, function(df) {
  ls <- split(df, df$pro_name)
  ls <- lapply(ls, function(x) {
    x$lyr_soc_cmtv <- NA
    for(i in seq_along(x$lyr_bot)) {
      if(i == 1) {
        x$lyr_soc_cmtv[i] <- x$lyr_soc[i]
      } else {
        x$lyr_soc_cmtv[i] <- x$lyr_soc[i] + x$lyr_soc_cmtv[i-1] 
      }
    }
    return(x)
  })
  return(unsplit(ls, df$pro_name))
})
```

```{r spline-soc, include = FALSE}
# spline fit for carbon stocks (for calc weighted averages)
depth.spline <- function(x) {
  sp <- spline(x, method = "hyman") # fit monotonic cubic spline
  sp.ss <- smooth.spline(sp) # convert to class "spline" with smooth.spline fxn
  std <- seq(0, 100) # in cm (linear beyond last measured depth)
  sp <- predict(sp.ss, std) 
  df <- data.frame(sp)
  colnames(df) <- c("lyr_bot","lyr_soc")
  for(i in seq_along(df$lyr_bot)) {
    if(i == 1) {
      df$lyr_soc[i] <- df$lyr_soc[i]
    } else {
      df$lyr_soc[i] <- df$lyr_soc[i + 1] - df$lyr_soc[i]
    }
  }
  df <- df[-1,]
  return(df[-length(df$lyr_soc), ])
}

# add (0, 0) point for (lyr_bot, lyr_cmtv_stock)
sra.2001.sp.ls <- lapply(sra.2001.ls, function(df) {
  ls <- lapply(split(df, df$pro_name), function(x) {
    t0 <- data.frame(matrix(nrow = 1, ncol = ncol(x)))
    xy <- c(which(names(x) == "lyr_bot"), which(names(x) == "lyr_soc_cmtv"))
    t0[ , xy] <- 0
    names(t0) <- names(x)
    t0$pro_name <- unique(x$pro_name)
    return(rbind(t0, x))
  })
  return(bind_rows(ls))
})

# 2009
sra.2009.sp.ls <- lapply(sra.2009.ls, function(df) {
  t0 <- data.frame(matrix(nrow = 1, ncol = ncol(df)))
  xy <- c(which(names(df) == "lyr_bot"), which(names(df) == "lyr_soc_cmtv"))
  t0[ , xy] <- 0
  names(t0) <- names(df)
  new <- rbind(t0, df)
  return(new)
})

# 2019
sra.2019.sp.ls <- lapply(sra.2019.ls, function(df) {
  ls <- lapply(split(df, df$pro_name), function(x) {
    t0 <- data.frame(matrix(nrow = 1, ncol = ncol(x)))
    xy <- c(which(names(x) == "lyr_bot"), which(names(x) == "lyr_soc_cmtv"))
    t0[ , xy] <- 0
    names(t0) <- names(x)
    t0$pro_name <- unique(x$pro_name)
    return(rbind(t0, x))
  })
  return(bind_rows(ls))
})

## run spline
# 2001
sra.2001.oc.sp <- lapply(sra.2001.sp.ls, function(df) {
  lapply(split(df, df$pro_name), function(x) {
    depth.spline(x[, c("lyr_bot", "lyr_soc_cmtv")])
  })
})
# 2009
sra.2009.oc.sp <- lapply(sra.2009.sp.ls, function(x) {
  depth.spline(x[, c("lyr_bot", "lyr_soc_cmtv")])
})
# 2019
sra.2019.oc.sp <- lapply(sra.2019.sp.ls, function(df) {
  lapply(split(df, df$pro_name), function(x) {
    depth.spline(x[, c("lyr_bot", "lyr_soc_cmtv")])
  })
})
```

```{r cwt-d14c-01, include = FALSE}
## calculate stock weights
## 2001 depths
# order '01 data
sra.2001.sum.ls <- lapply(sra.2001.sum.ls, function(df) df[order(df$lyr_bot), ])
# 2009
cwt.01.09 <- lapply(seq_along(sra.2009.oc.sp), function(i) {
  d <- sra.2001.sum.ls[[i]][["lyr_bot"]] # map onto '01 depths
  c <- vector(mode = "list", length = length(d))
  for(j in seq_along(d)) {
    if(j == 1) {
      c[[j]] <- sra.2009.oc.sp[[i]][1:d[j], "lyr_soc"]
    } else {
      c[[j]] <- sra.2009.oc.sp[[i]][(d[j-1]+1):d[j], "lyr_soc"] 
    }
  }
  return(unlist(lapply(c, function(x) x/sum(x)))) # return weights
})
names(cwt.01.09) <- names(sra.2009.oc.sp)
# 2019 (second list level from profile reps)
cwt.01.19 <- lapply(seq_along(sra.2019.oc.sp), function(i) {
  lapply(sra.2019.oc.sp[[i]], function(df) {
    d <- sra.2001.sum.ls[[i]][["lyr_bot"]] # map onto '01 depths
    c <- vector(mode = "list", length = length(d))
    for(j in seq_along(d)) {
      if(j == 1) {
        c[[j]] <- df[1:d[j], "lyr_soc"]
      } else {
        c[[j]] <- df[(d[j-1]+1):d[j], "lyr_soc"] 
      }
    }
    return(unlist(lapply(c, function(x) x/sum(x))))  # return weights
  })
})
names(cwt.01.19) <- names(sra.2019.oc.sp)


## calculate fm_wts
## '01 depths
# 2019
fm.wt.01.19 <- lapply(seq_along(cwt.01.19), function(i) {
  lapply(seq_along(cwt.01.19[[i]]), function(j) {
    df <- data.frame(cwt = cwt.01.19[[i]][[j]])
    df$fm <- sra.2019.fm.sp[[i]][[j]][["var.1cm"]][1:length(cwt.01.19[[i]][[j]])]
    df$fm_wt <- df$fm * df$cwt
  return(df)
  })
}) 
names(fm.wt.01.19) <- names(cwt.01.19)
# 2009
fm.wt.01.09 <- lapply(seq_along(cwt.01.09), function(i) {
  df <- data.frame(cwt = cwt.01.09[[i]])
  df$fm <- sra.2009.fm.sp[[i]][["var.1cm"]][1:length(cwt.01.09[[i]])]
  df$fm_wt <- df$fm * df$cwt
  return(df)
})
names(fm.wt.01.09) <- names(cwt.01.09)


## calculate weighted average of fm for each interval
## '01 depths
# 2009
sra.01.09.ls <- lapply(seq_along(sra.2001.sum.ls), function(i) {
  d <- sra.2001.sum.ls[[i]][["lyr_bot"]]
  f <- vector(mode = "list", length = length(d))
  for(j in seq_along(d)) {
    if(j == 1) {
      f[[j]] <- sum(fm.wt.01.09[[i]][1:d[j], "fm_wt"])
    } else {
      f[[j]] <- sum(fm.wt.01.09[[i]][(d[j-1]+1):d[j], "fm_wt"])
    }
  }
  return(cbind(sra.2001.sum.ls[[i]], fm_09 = unlist(f)))
})
names(sra.01.09.ls) <- names(fm.wt.01.09)
# 2019
sra.01.19.ls <- fm.wt.01.19 # initialize list with fm wt structure
sra.01.19.ls <- lapply(seq_along(sra.2001.sum.ls), function(i) {
  sra.01.19.ls[[i]] <- lapply(seq_along(fm.wt.01.19[[i]]), function(x) {
    d <- sra.2001.sum.ls[[i]][["lyr_bot"]]
    f <- vector(mode = "list", length = length(d))
    for(j in seq_along(d)) {
      if(j == 1) {
        f[[j]] <- sum(fm.wt.01.19[[i]][[x]][1:d[j], "fm_wt"])
      } else {
        f[[j]] <- sum(fm.wt.01.19[[i]][[x]][(d[j-1]+1):d[j], "fm_wt"])
      }
    }
    return(unlist(f)) 
  })
  fm <- lapply(seq_along(sra.01.19.ls[[i]][[1]]), function(z) {
    data.frame(fm_19_mean = mean(sapply(sra.01.19.ls[[i]], "[", z), na.rm = TRUE),
               fm_19_sd = sd(sapply(sra.01.19.ls[[i]], "[", z), na.rm = TRUE))
    })
  fm <- bind_rows(fm)
  return(fm)
})
sra.01.09.19.ls <- lapply(seq_along(sra.01.09.ls), function(i) {
  data.frame(sra.01.09.ls[[i]], sra.01.19.ls[[i]])
})
names(sra.01.09.19.ls) <- names(sra.01.09.ls)

## create tidy combined '01, '09, '19 data frame
nms <- c("PM", "ECO", "PMeco", "lyr_top", "lyr_bot", "fm", "fm_sd")
sra.01.09.19.df <- bind_rows(sra.01.09.19.ls)
sra.01.09.19 <- sra.01.09.19.df[, nms]
sra.01.09.19 <- rbind(cbind(sra.01.09.19, Year = as.character(2001)),
                      data.frame(sra.01.09.19[, nms[1:5]],
                                 fm = sra.01.09.19.df$fm_09,
                                 fm_sd = NA,
                                 Year = as.character(2009)),
                      data.frame(sra.01.09.19[, nms[1:5]],
                                 fm = sra.01.09.19.df$fm_19_mean,
                                 fm_sd = sra.01.09.19.df$fm_19_sd,
                                 Year = as.character(2019)))

# calc d14c from fm
sra.01.09.19$d14c <- calc_14c(sra.01.09.19$fm, as.numeric(as.character(sra.01.09.19$Year)))
sra.01.09.19$d14c_sd <- abs(sra.01.09.19$d14c - calc_14c(sra.01.09.19$fm + sra.01.09.19$fm_sd, as.numeric(as.character(sra.01.09.19$Year))))
```

```{r cwt-d14c-19, include = FALSE}
## calculate stock weights
## 2019 depths
# 2001
cwt.19.01 <- lapply(seq_along(sra.2001.oc.sp), function(i) {
  lapply(sra.2001.oc.sp[[i]], function(df) {
    d <- sra.2019.sum.ls[[i]][["lyr_bot"]]
    c <- vector(mode = "list", length = length(d))
    for(j in seq_along(d)) {
      if(j == 1) {
        c[[j]] <- df[1:d[j], "lyr_soc"]
      } else {
        c[[j]] <- df[(d[j-1]+1):d[j], "lyr_soc"] 
      }
    }
    return(unlist(lapply(c, function(x) x/sum(x))))
  })
})
names(cwt.19.01) <- names(sra.2001.oc.sp)
# 2009
cwt.19.09 <- lapply(seq_along(sra.2009.oc.sp), function(i) {
  d <- sra.2019.sum.ls[[i]][["lyr_bot"]]
  c <- vector(mode = "list", length = length(d))
  for(j in seq_along(d)) {
    if(j == 1) {
      c[[j]] <- sra.2009.oc.sp[[i]][1:d[j], "lyr_soc"]
    } else {
      c[[j]] <- sra.2009.oc.sp[[i]][(d[j-1]+1):d[j], "lyr_soc"] 
    }
  }
  return(unlist(lapply(c, function(x) x/sum(x))))
})
names(cwt.19.09) <- names(sra.2009.oc.sp)

## calculate fm_wts
## '19 depths
# 2001
fm.wt.19.01 <- lapply(seq_along(cwt.19.01), function(i) {
  lapply(seq_along(cwt.19.01[[i]]), function(j) {
    df <- data.frame(cwt = cwt.19.01[[i]][[j]])
    df$fm <- sra.2001.fm.sp[[i]][[j]][["var.1cm"]][1:length(cwt.19.01[[i]][[j]])]
    # linear extrapolation for filling 20-30cm fm data
    fm_1_30 <- df$fm[1:30] # 0-30cm fm
    if(length(which(is.na(fm_1_30))) > 0) {
     ix <- which(is.na(fm_1_30))
     ix.min <- min(ix) # first is.na(fm)
     m <- fm_1_30[ix.min-1]-fm_1_30[ix.min-2] # slope at last two measurement points
     for(i in ix.min:30) {
      fm_1_30[i] <- fm_1_30[i - 1] + m 
     }
     df$fm[1:30] <- fm_1_30 
    }
    df$fm_wt <- df$fm * df$cwt
  return(df)
  })
})
names(fm.wt.19.01) <- names(cwt.19.01)
# 2009
fm.wt.19.09 <- lapply(seq_along(cwt.19.09), function(i) {
  df <- data.frame(cwt = cwt.19.09[[i]])
  df$fm <- sra.2009.fm.sp[[i]][["var.1cm"]][1:length(cwt.19.09[[i]])]
  df$fm_wt <- df$fm * df$cwt
  return(df)
})
names(fm.wt.19.09) <- names(cwt.19.09)


## calculate weighted average of fm for each interval
## '19 depths
# 2001
# calculate weighted spline values for each profile rep
sra.19.01.rep.ls <- fm.wt.19.01
sra.19.01.rep.ls <- lapply(seq_along(sra.2019.sum.ls), function(i) {
  sra.19.01.rep.ls[[i]] <- lapply(seq_along(fm.wt.19.01[[i]]), function(x) {
    d <- sra.2019.sum.ls[[i]][["lyr_bot"]]
    f <- vector(mode = "list", length = length(d))
    for(j in seq_along(d)) {
      if(j == 1) {
        f[[j]] <- sum(fm.wt.19.01[[i]][[x]][1:d[j], "fm_wt"])
      } else {
        f[[j]] <- sum(fm.wt.19.01[[i]][[x]][(d[j-1]+1):d[j], "fm_wt"])
      }
    }
    return(unlist(f)) 
  })})
sra.19.01.rep.ls <- lapply(seq_along(sra.19.01.rep.ls), function(i) {
  names(sra.19.01.rep.ls[[i]]) <- names(cwt.19.01[[i]])
  return(sra.19.01.rep.ls[[i]])
})
names(sra.19.01.rep.ls) <- names(fm.wt.19.01)

# average reps
sra.19.01.ls <- lapply(seq_along(sra.2019.sum.ls), function(i) {
  fm <- lapply(seq_along(sra.19.01.rep.ls[[i]][[1]]), function(z) {
    data.frame(fm_01_mean = mean(sapply(sra.19.01.rep.ls[[i]], "[", z), na.rm = TRUE),
               fm_01_sd = sd(sapply(sra.19.01.rep.ls[[i]], "[", z), na.rm = TRUE))
    })
  return(bind_rows(fm))
})
names(sra.19.01.ls) <- names(fm.wt.19.01)

# 2009
sra.19.09.ls <- lapply(seq_along(sra.2019.sum.ls), function(i) {
  d <- sra.2019.sum.ls[[i]][["lyr_bot"]]
  f <- vector(mode = "list", length = length(d))
  for(j in seq_along(d)) {
    if(j == 1) {
      f[[j]] <- sum(fm.wt.19.09[[i]][1:d[j], "fm_wt"])
    } else {
      f[[j]] <- sum(fm.wt.19.09[[i]][(d[j-1]+1):d[j], "fm_wt"])
    }
  }
  return(cbind(sra.2019.sum.ls[[i]], fm_09 = unlist(f)))
})
names(sra.19.09.ls) <- names(sra.19.01.ls)

# combine
sra.19.01.09.ls <- lapply(seq_along(sra.19.01.ls), function(i) {
  data.frame(sra.19.01.ls[[i]], sra.19.09.ls[[i]])
})
names(sra.19.01.09.ls) <- names(sra.19.01.ls)

## create tidy combined '01, '09, '19 data frame
sra.19.01.09.df <- bind_rows(sra.19.01.09.ls)
sra.19.01.09 <- sra.19.01.09.df[, nms]
sra.19.01.09 <- rbind(data.frame(sra.19.01.09[, nms[1:5]],
                                 fm = sra.19.01.09.df$fm_01_mean,
                                 fm_sd = sra.19.01.09.df$fm_01_sd,
                                 Year = as.character(2001)),
                     data.frame(sra.19.01.09[, nms[1:5]],
                                fm = sra.19.01.09.df$fm_09,
                                fm_sd = NA,
                                Year = as.character(2009)),
                     cbind(sra.19.01.09, Year = as.character(2019)))

# calc d14c from fm
sra.19.01.09$d14c <- calc_14c(sra.19.01.09$fm, as.numeric(as.character(sra.19.01.09$Year)))
sra.19.01.09$d14c_sd <- abs(sra.19.01.09$d14c - calc_14c(sra.19.01.09$fm + sra.19.01.09$fm_sd, as.numeric(as.character(sra.19.01.09$Year))))
```

```{r plot-01-09-19-14c-profiles}
fig.n <- fig.n + 1
sra.01.09.19 %>%
  mutate(PMeco_year = paste0(PMeco, Year),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = eco, linetype = Year, group = PMeco_year)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point(aes(alpha = Year), size = 3) +
  geom_path(aes(linetype = Year)) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  scale_y_reverse() +
  scale_x_continuous() +    
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  scale_alpha_manual(values = c("2001" = 1,
                                "2009" = 0.6,
                                "2019" = 0.3)) +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Time series of $\Delta$^14^C by depth (2001, 2009, 2019)**

>*Caption:* Points for 2001 samples show the mean $\Delta$^14^C values at the measured depths. Points for 2009 and 2019 samples are spline-fitted estimates of $\Delta$^14^C predicted for the same depth intervals as measured in 2001. Error bars show ± 1 standard deviation of the mean of three replicate profiles for 2001 and 2019 samples (only a single profile was analyzed in 2009). 

```{r plot-19-01-09-14c-profiles}
fig.n <- fig.n + 1
sra.19.01.09 %>%
  mutate(PMeco_year = paste0(PMeco, Year),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = eco, linetype = Year, group = PMeco_year)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point(aes(alpha = Year), size = 3) +
  geom_path(aes(linetype = Year)) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  scale_y_reverse(limits = c(30, 0)) +
  scale_x_continuous() +    
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  scale_alpha_manual(values = c("2001" = 1,
                                "2009" = 0.6,
                                "2019" = 0.3)) +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Time series of $\Delta$^14^C by depth (splined to 2019 depths)**

>*Caption:* Points for 2019 samples show the mean $\Delta$^14^C values at the measured depths. Points for 2001 and 2009 samples are spline-fitted estimates of $\Delta$^14^C predicted for the same depth intervals as measured in 2019. Error bars show ± 1 standard deviation of the mean of three replicate profiles for 2001 and 2019 samples (only a single profile was analyzed in 2009). 
>*NB: Only two depth intervals were measured at the cool and cold andesite sites (max depth of 27 and 28 cm, respectively), so linear extrapolation (using the slope of the last 1cm spline-fitted depth increment) was used to extend the profiles to 30 cm.*

## Initial modeling

The goal of this modeling exercise is to see how parent material and climate/ecosystem affect estimates of soil carbon ages and transit times. Bulk soil ^14^C observations from 2001, 2009, and 2019 will be used to constrain the carbon models, as well as observations of ^14^C-CO~2~ from laboratory soil incubations of soils collected in 2001 and 2019. Previous work has indicated that the carbon stocks at these sites is likely at equilibrium, so we will apply the steady-state assumption to the modeling.

### Two-pool parallel model

One pool models have been shown repeatedly to be inadequate for describing soil carbon dynamics. However, as simple models are easier to constrain, we will start with a two-pool parallel model, as this is the simplest model system beyond the single pool approach. The two-pool parallel model requires the following parameters:
* decomposition constants for each pool (*k*~1~, *k*~2~)
* input partitioning coefficient ($\gamma$)
* steady-state carbon stocks (C)
* inputs (I)
* initial values of ^14^C

Decomposition rates (*k*) are related to the amount of ^14^C in a pre-bomb system (fraction modern, *F*) at steady-state by the following equations (cf. Schuur, Druffle, and Trumbore, 2016):
>**Eq. 1**

$$F = \frac{k}{k + \lambda}$$
>**Eq. 2**

$$k = \frac{\lambda \cdot F}{1 - F}$$
>where $\lambda$ is the radioactive decay constant (1/8267).

As the decomposition rates will vary, the initial ^14^C content can be determined dynamically with equation 1.

Carbon stocks are known, while inputs will be estimated and are related to the steady-state conditions by the following equation: 
>**Eq. 3**

$$I = (k_{1} \cdot C_{1}) + (k_{2} \cdot C_{2})$$
>where *C~1~* and *C~2~* are the carbon stocks of the two model pools.

Both stocks and inputs can be scaled to the known value of the total carbon pool once the steady-state parameters (*k~1~*, *k~2~*, $\gamma$) have been determined. Pool sizes are a function of the inputs and input partitioning coefficient at steady-state.

A Monte-Carlo Markov chain approach will be used for parameter estimation in combination with an initial optimization algorithm to determine the best set of initial parameters.

```{r mod-utils}
# note lambda defined earlier

# k from fraction modern
k <- function(Fm) {
  (Fm*lambda)/(1-Fm)
}

# d14C from fraction modern 
fm_14c <- function(fm, date) {
  (fm*exp(lambda*(1950 - date)) - 1)*1000
}

# pre-bomb fraction modern from k (steady-state assumed)
fm <- function(k){
  k/(k+lambda)
}
```

```{r mod-funs-2pp}
# set vector of time and atm 14C inputs
Year <- Datm$Date

# index of years for which bulk/resp 14C are known
year.ix <- c(which(Datm$Date == 2001.5),
             which(Datm$Date == 2009.5),
             which(Datm$Date == 2019.5))

# function for saving constraint data in a dataframe for plotting in ggplot
con.df.fx <- function(PMeco, lyr_bot) {
  bulk.df <- sra.19.01.09[sra.19.01.09$PMeco == PMeco &
                           sra.19.01.09$lyr_bot == lyr_bot, c("Year", "d14c", "d14c_sd")]
  resp.df <- cbind(sra.2019.inc.df_1[sra.2019.inc.df_1$PMeco == PMeco &
                                       sra.2019.inc.df_1$lyr_bot == lyr_bot, c("Year", "d14c")], d14c_sd = NA)
  con.df <- cbind(pool = c(rep("bulk C", nrow(bulk.df)), rep("respiration", nrow(resp.df))), rbind(bulk.df, resp.df))
  con.df$d14c_l <- con.df$d14c - con.df$d14c_sd
  con.df$d14c_u <- con.df$d14c + con.df$d14c_sd
  con.df$Year <- as.numeric(as.character(con.df$Year))
  return(con.df)
}

# function for trial and error approach for parameter fitting
par.fx <- function(In, gam, ks, verbose = TRUE) {
  A <- -1*diag(ks)
  if(verbose) {
    cat(paste0(PMeco, "_", lyr_top, "-", lyr_bot), "\n")
    cat(round(sum(-1*solve(A)%*%c(In*gam, In*(1-gam))), 1), " (modeled stocks)\n")
    cat(csoc.19.0_30[[paste0(PMeco, "_", lyr_top, "-", lyr_bot)]][ , "lyr_soc"], " (measured stocks)\n") 
  }
  
  # steady-state stocks
  ss.cstock <- (-1*solve(A)%*%c(In*gam, In*(1-gam)))
    
  # F0_Delta14C
  F0_Delta14C <- c(Delta14C_from_AbsoluteFractionModern(fm(ks[1])), Delta14C_from_AbsoluteFractionModern(fm(ks[2])))
  
  # 2pool parallel model
  iniMod.2pp <- TwopParallelModel14(t = Year,
                                    ks = ks,
                                    C0 = c(ss.cstock[1], ss.cstock[2]),
                                    F0_Delta14C = F0_Delta14C,
                                    In = In,
                                    gam = gam,
                                    inputFc = Datm)
  
    # get C and 14C data
    ini.2pp.C14 <- getF14(iniMod.2pp)
    ini.2pp.C14m <- getF14C(iniMod.2pp) 
    ini.2pp.HR <- getF14R(iniMod.2pp)
    ini.2pp.Ctot <- getC(iniMod.2pp)
    
    # data frame for plotting
    return(data.frame(
      years = rep(Datm$Date, 5),
      d14C = c(ini.2pp.C14[,1], 
               ini.2pp.C14[,2], 
               ini.2pp.C14m,
               ini.2pp.HR,
               Datm$NHc14),
      pool = rep(c("fast", "slow", "bulk C", "respiration", "atm"), each = nrow(ini.2pp.C14))))
}

# plot function
C14.2pp.plot.fx <- function(plot.df, con.df) {
  plot.df %>%
  filter(pool == "bulk C" | pool == "respiration" | pool == "atm") %>%
  ggplot(., aes(years, d14C, color = pool)) +
  geom_path() +
  geom_point(data = con.df, aes(Year, d14c, color = pool), size = 3) +
  geom_errorbar(data = con.df,
    aes(x = Year,
        ymin = d14c_l, 
        ymax = d14c_u, 
        color = pool), 
    width = .1,
    inherit.aes = FALSE) +
  scale_color_manual(
    name = "Model pool",
    values = c("atm" = 8,
               "bulk C" = "black",
               "fast" = "#D81B60",
               "slow" = "#1E88E5",
               "respiration" = "#FFC107")) +
  scale_x_continuous(limits = c(1950, 2022)) +
  ggtitle(paste0(PMeco, "_", lyr_top, "-", lyr_bot, " 2pp")) +
  xlab("Year") +
  ylab(expression(''*Delta*''^14*'C (‰)')) +
  theme_bw() +
  theme(panel.grid = element_blank())
}

# set up model function for MCMC simulation for 2-pool parallel system
modFun_2pp <- function(pars, pass){
  F0_Delta14C <- unlist(lapply(pars[1:2], function(x) Delta14C_from_AbsoluteFractionModern(fm(x))))
  A <- -1*diag(pars[1:2])
  ss.cstock <- (-1*solve(A)%*%c(In*pars[3], In*(1-pars[3])))
  mod <- TwopParallelModel14(
    t = Year,
    ks = pars[1:2],
    C0 = c(ss.cstock[1], ss.cstock[2]),
    F0_Delta14C = F0_Delta14C,
    In = In,
    gam = pars[3],
    inputFc = Datm,
    pass = pass)
  C14m <- getF14C(mod)
  C14p <- getF14(mod)
  C14r <- getF14R(mod)
  Ctot <- getC(mod)
  return(data.frame(time = Year, 
                    bulkC = C14m, 
                    resp = C14r,
                    socs = rowSums(Ctot)))
}
```

```{r mod-constraints, include = FALSE}
## Inputs
# Inputs may vary among sites, and I could use respiration data from incubations to control that
# For now, they will be kept constant across sites but be allowed to vary by depth
In.10 <- .16 # this was fit to the BSwf 0-10 site
In.20 <- .1 # totally made up
In.30 <- .05 # totally made up

## SOC stocks
# use 2019 SOC stocks for steady-state estimates
csoc.19.0_30 <- bind_rows(
  lapply(sra.2019.sp.ls, function(df) {
    df <- suppressMessages(
      df %>% 
        filter(lyr_bot < 31 & lyr_bot > 0) %>%
        select(PMeco, lyr_top, lyr_bot, lyr_soc) %>%
        group_by(PMeco, lyr_top, lyr_bot) %>%
        summarize(lyr_soc = mean(lyr_soc)))
    return(data.frame(df))
  })
)
# convert to 27 element list
csoc.19.0_30 <- split(csoc.19.0_30, paste0(csoc.19.0_30$PMeco, "_", csoc.19.0_30$lyr_top, "-", csoc.19.0_30$lyr_bot))

## 14C constraints
# bulk
obs.bulk.14c <- unlist(
  lapply(seq_along(sra.19.01.rep.ls), function(i) {
  # index along depth intervals 0-10, 10-20, 20-30
  depth.ls <- lapply(seq_along(1:3), function(j) {
    c(unlist(lapply(sra.19.01.rep.ls[[i]], "[[", j)),
      split(split(sra.19.01.09, sra.19.01.09$PMeco)[[i]],
            split(sra.19.01.09, sra.19.01.09$PMeco)[[i]]["lyr_bot"])[[j]][ , "fm"][2],
      unlist(split(sra.2019.ls[[i]], sra.2019.ls[[i]]["lyr_bot"])[[j]]["fm"]))
  })
  reps01 <- length(sra.19.01.rep.ls[[i]])
  depth.dfs <- lapply(depth.ls, function(fm) {
    data.frame(time = c(rep(2001.5, reps01), 2009.5, rep(2019.5, 3)),
               bulkC = Delta14C_from_AbsoluteFractionModern(fm))
  })
  return(depth.dfs)
}), recursive = FALSE)
names(obs.bulk.14c) <- paste0(rep(c("AN", "BS", "GR"), each = 9),
                              rep(c("pp", "rf", "wf"), each = 3, times = 3),
                              rep(c("_0-10", "_10-20", "_20-30"), times = 9))

# respiration
obs.resp.14c <- split(sra.2019.inc.df_1, gsub("comp_", "", sra.2019.inc.df_1$lyr_name))
obs.resp.14c <- lapply(obs.resp.14c, function(df) {
  df$resp <- df$d14c
  df$time <- df$Year + .5
  return(df[ , c("time", "resp")])
})

## Initial parameters
# initialize list (9 sites by 3 depths = 27 elements)
pars.i <- lapply(seq_len(27), function(df) {
  df <- data.frame(kfast = NA,
                   kslow = NA,
                   gam = NA)
})
names(pars.i) <- names(obs.bulk.14c)
```

```{r ini-mod-pars-BSpp-0-10, include = FALSE}
# Site/depth info
PMeco <- "BSpp"
lyr_bot <- 10
lyr_top <- ifelse(lyr_bot == 10, 0, ifelse(lyr_bot == 20, 10, 20))

# 14C constraints
con.df <- con.df.fx(PMeco, lyr_bot)
                
# initial pars
In <- In.10
gam <- .7 # partitioning coef
ks <- c(.05, .0065) # fast, slow

# evaluate pars
ini.2pp.C14.df <- par.fx(In, gam, ks)

# plot
C14.2pp.plot.fx(ini.2pp.C14.df, con.df)

# save pars
pars.i[[paste0(PMeco, "_", lyr_top, "-", lyr_bot)]] <- c(ks, gam) 
```

```{r ini-mod-pars-BSwf-0-10, include = FALSE}
# Site/depth info
PMeco <- "BSwf"
lyr_bot <- 10
lyr_top <- ifelse(lyr_bot == 10, 0, ifelse(lyr_bot == 20, 10, 20))

# 14C constraints
con.df <- con.df.fx(PMeco, lyr_bot)

# initial parameters
In <- In.10
gam <- .9 # initial value
ks <- c(.12, .004) # fast, slow

# evaluate pars
ini.2pp.C14.df <- par.fx(In, gam, ks)

# plot
C14.2pp.plot.fx(ini.2pp.C14.df, con.df)

# save pars
pars.i[[paste0(PMeco, "_", lyr_top, "-", lyr_bot)]] <- c(ks, gam) 
```

```{r ini-mod-pars-BSrf-0-10, include = FALSE}
# Site/depth info
PMeco <- "BSrf"
lyr_bot <- 10
lyr_top <- ifelse(lyr_bot == 10, 0, ifelse(lyr_bot == 20, 10, 20))

# 14C constraints
con.df <- con.df.fx(PMeco, lyr_bot)

# initial pars
In <- In.10
gam <- .9 # partitioning coef
ks <- c(.10, .003) # fast, slow

# evaluate pars
ini.2pp.C14.df <- par.fx(In, gam, ks)

# plot
C14.2pp.plot.fx(ini.2pp.C14.df, con.df)

# save pars
pars.i[[paste0(PMeco, "_", lyr_top, "-", lyr_bot)]] <- c(ks, gam) 
```

```{r ini-mod-pars-ANpp-0-10, include = FALSE}
# Site/depth info
PMeco <- "ANpp"
lyr_bot <- 10
lyr_top <- ifelse(lyr_bot == 10, 0, ifelse(lyr_bot == 20, 10, 20))

# 14C constraints
con.df <- con.df.fx(PMeco, lyr_bot)
                
# initial pars
In <- In.10
gam <- .95 # partitioning coef
ks <- c(.1, .005) # fast, slow

# evaluate pars
ini.2pp.C14.df <- par.fx(In, gam, ks)

# plot
C14.2pp.plot.fx(ini.2pp.C14.df, con.df)

# save pars
pars.i[[paste0(PMeco, "_", lyr_top, "-", lyr_bot)]] <- c(ks, gam) 
```

```{r ini-mod-pars-ANwf-0-10, include = FALSE}
# Site/depth info
PMeco <- "ANwf"
lyr_bot <- 10
lyr_top <- ifelse(lyr_bot == 10, 0, ifelse(lyr_bot == 20, 10, 20))

# 14C constraints
con.df <- con.df.fx(PMeco, lyr_bot)

# initial parameters
In <- In.10
gam <- .9 # initial value
ks <- c(.09, .0017) # fast, slow

# evaluate pars
ini.2pp.C14.df <- par.fx(In, gam, ks)

# plot
C14.2pp.plot.fx(ini.2pp.C14.df, con.df)

# save pars
pars.i[[paste0(PMeco, "_", lyr_top, "-", lyr_bot)]] <- c(ks, gam) 
```

```{r ini-mod-pars-ANrf-0-10, include = FALSE}
# Site/depth info
PMeco <- "ANrf"
lyr_bot <- 10
lyr_top <- ifelse(lyr_bot == 10, 0, ifelse(lyr_bot == 20, 10, 20))

# 14C constraints
con.df <- con.df.fx(PMeco, lyr_bot)

# initial pars
In <- In.10
gam <- .92 # partitioning coef
ks <- c(.08, .0033) # fast, slow

# evaluate pars
ini.2pp.C14.df <- par.fx(In, gam, ks)

# plot
C14.2pp.plot.fx(ini.2pp.C14.df, con.df)

# save pars
pars.i[[paste0(PMeco, "_", lyr_top, "-", lyr_bot)]] <- c(ks, gam) 
```

```{r ini-mod-pars-GRpp-0-10, include = FALSE}
# Site/depth info
PMeco <- "GRpp"
lyr_bot <- 10
lyr_top <- ifelse(lyr_bot == 10, 0, ifelse(lyr_bot == 20, 10, 20))

# 14C constraints
con.df <- con.df.fx(PMeco, lyr_bot)
                
# initial pars
In <- In.10
gam <- .72 # partitioning coef
ks <- c(.06, .01) # fast, slow

# evaluate pars
ini.2pp.C14.df <- par.fx(In, gam, ks)

# plot
C14.2pp.plot.fx(ini.2pp.C14.df, con.df)

# save pars
pars.i[[paste0(PMeco, "_", lyr_top, "-", lyr_bot)]] <- c(ks, gam) 
```

```{r ini-mod-pars-GRwf-0-10, include = FALSE}
# Site/depth info
PMeco <- "GRwf"
lyr_bot <- 10
lyr_top <- ifelse(lyr_bot == 10, 0, ifelse(lyr_bot == 20, 10, 20))

# 14C constraints
con.df <- con.df.fx(PMeco, lyr_bot)

# initial parameters
In <- In.10
gam <- .8 # partitioning coef
ks <- c(.075, .0075) # fast, slow

# evaluate pars
ini.2pp.C14.df <- par.fx(In, gam, ks)

# plot
C14.2pp.plot.fx(ini.2pp.C14.df, con.df)

# save pars
pars.i[[paste0(PMeco, "_", lyr_top, "-", lyr_bot)]] <- c(ks, gam) 
```

```{r ini-mod-pars-GRrf-0-10, include = FALSE}
# Site/depth info
PMeco <- "GRrf"
lyr_bot <- 10
lyr_top <- ifelse(lyr_bot == 10, 0, ifelse(lyr_bot == 20, 10, 20))

# 14C constraints
con.df <- con.df.fx(PMeco, lyr_bot)

# initial pars
In <- In.10
gam <- .9 # partitioning coef
ks <- c(.08, .0031) # fast, slow

# evaluate pars
ini.2pp.C14.df <- par.fx(In, gam, ks)

# plot
C14.2pp.plot.fx(ini.2pp.C14.df, con.df)

# save pars
pars.i[[paste0(PMeco, "_", lyr_top, "-", lyr_bot)]] <- c(ks, gam) 
```

```{r opt-mod}
## Optimize model pars
# Cost function (evaluates error as model vs. obsv, per FME req)
# note that we have to set "pass" to TRUE so SoilR model doesn't fail (neg. resp)
mod.fits <- vector(mode = "list", length = length(pars.i))
test.ix <- seq(1, 27, 3)
mod.fits[test.ix] <- lapply(test.ix, function(i) {
  start <- Sys.time()
  cat(paste0(names(pars.i)[i], " parameter fitting\n"))
  # define cost function for current iteration
  mod.Cost <- function(pars){
    modelOutput <- modFun_2pp(pars, pass = TRUE)
    cost1 <- modCost(model = modelOutput, obs = obs.bulk.14c[[i]], scaleVar = TRUE)
    return(modCost(model = modelOutput, obs = obs.resp.14c[[i]], cost = cost1))
  }
  # fit pars
  fit <- modFit(f = mod.Cost,
                p = pars.i[[i]],
                method = 'Nelder-Mead',
                upper = c(1, .1, 1), 
                lower = c(0.01, 0, .5))
  end <- Sys.time()
  cat(paste0("time: ", end - start, "\n"))
  return(fit)
})
```

```{r report-par-fit}
# look at estimates
pars.fit <- mapply(rbind, 
                   lapply(mod.fits[test.ix], "[[", 1), 
                   pars.i[test.ix], 
                   SIMPLIFY = FALSE)
pars.fit <- lapply(pars.fit, function(df) {
  df <- data.frame(df)
  colnames(df) <- c("kfast", "kslow", "gam")
  df$est <- c("fit", "init")
  return(df)
})
names(pars.fit) <- names(pars.i)[test.ix]

# save(pars.fit, file = paste0(getwd(), "/opt-0-10-par-fit", Sys.Date()))

pars.fit.df <- bind_rows(pars.fit)
pars.fit.df$PMeco_depth <- rep(names(pars.i[test.ix]), each = 2)
pars.fit.df$PM <- substr(pars.fit.df$PMeco_depth, start = 1, stop = 2)
pars.fit.df$eco <- substr(pars.fit.df$PMeco_depth, start = 3, stop = 4)

# summarize by PM
pars.fit.df.PM <- pars.fit.df %>%
  filter(est == "fit") %>%
  select(!c(PMeco_depth, eco, est)) %>%
  group_by(PM) %>%
  summarize_all(list(mean = mean, sd = sd)) %>%
  mutate_if(is.numeric, format, digits = 2)
# summarize by ECO
pars.fit.df.eco <- pars.fit.df %>%
  filter(est == "fit") %>%
  select(!c(PMeco_depth, PM, est)) %>%
  group_by(eco) %>%
  summarize_all(list(mean = mean, sd = sd)) %>%
  mutate_if(is.numeric, format, digits = 2)

knitr::kable(pars.fit.df.PM,
             caption = "Mean parameter estimates (0-10 cm) by parent material (PM)",
             align = "c")
knitr::kable(pars.fit.df.eco,
             caption = "Mean parameter estimates (0-10 cm) by ecosystem (eco)",
             align = "c")

# plot pars
pars.fit.df %>%
  filter(est == "fit") %>%
  pivot_longer(!(est:eco), names_to = "par", values_to = "value") %>%
  mutate(PM = factor(PM),
         eco = factor(eco, levels = c("pp", "wf", "rf"))) %>%
  ggplot(., aes(par, value, color = PM, shape = eco)) +
  geom_jitter(size = 4) +
  scale_color_manual(name = "parent material",
                    labels = c("AN" = "andesite",
                               "BS" = "basalt",
                               "GR" = "granite"),
                    values = c("AN" = "blue", 
                               "BS" = "red", 
                               "GR" = "darkgray")) +
  facet_wrap(. ~ par, scales = "free") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```

```{r plot-opt-mods-0-10}
# Rerun models and plot results with fitted parameters
ks.ls <- lapply(lapply(pars.fit, "[", 1, ), function(df) unlist(df[ , c(1:2)]))
gam.ls <- lapply(lapply(pars.fit, "[", 1, ), function(df) unlist(df[ , 3]))
Twopp.fits <- lapply(seq_along(ks.ls), function(i) {
  par.fx(In.10, gam.ls[[i]], ks.ls[[i]], verbose = FALSE)
})

# Calc modeled stocks
mod.socs.ls <- lapply(seq_along(ks.ls), function(i) {
  A <- -1*diag(ks.ls[[i]])
  return(colSums(-1 * solve(A) %*% c(In.10 * gam.ls[[i]], In.10 * (1 - gam.ls[[i]]))))
})
socs.ls <- mapply(cbind, 
                   csoc.19.0_30, 
                   mod.socs.ls, 
                   SIMPLIFY = FALSE)

Twopp.fits.plots <- lapply(seq_along(Twopp.fits), function(i) {
  pars.int <- pars.i[test.ix]
  PMeco <- substr(names(pars.fit)[i], 1, 4)
  lyr_bot <- substr(names(pars.fit)[i], nchar(names(pars.fit)[i])-1, nchar(names(pars.fit)[i]))
  lyr_top <- 0
  con.df <- con.df.fx(PMeco, lyr_bot)
  plot.df <- rbind(Twopp.fits[[i]], 
                   par.fx(In.10, pars.int[[i]][3], pars.int[[i]][1:2], verbose = FALSE))
  plot.df$est <- factor(c(rep("fitted", nrow(Twopp.fits[[i]])), 
                          rep("initial", nrow(Twopp.fits[[i]]))))
  return(plot.df %>%
           filter(pool == "bulk C" | pool == "respiration" | pool == "atm") %>%
           ggplot(., aes(years, d14C, color = pool)) +
           geom_path(aes(linetype = est)) +
           geom_point(data = con.df, aes(Year, d14c, color = pool), size = 3) +
           geom_errorbar(data = con.df,
                         aes(x = Year,
                             ymin = d14c_l, 
                             ymax = d14c_u, 
                             color = pool), 
                         width = .1,
                         inherit.aes = FALSE) +
           scale_color_manual(
             name = "Model pool",
             values = c("atm" = 8,
                        "bulk C" = "black",
                        "fast" = "#D81B60",
                        "slow" = "#1E88E5",
                        "respiration" = "#FFC107")) +
           scale_x_continuous(limits = c(1950, 2022)) +
           ggtitle(paste0(PMeco, "_", lyr_top, "-", lyr_bot, " 2pp")) +
           xlab("Year") +
           ylab(expression(''*Delta*''^14*'C (‰)')) +
           theme_bw() +
           theme(panel.grid = element_blank()))
})
Twopp.fits.plots
```