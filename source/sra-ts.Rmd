---
title: "Sierra Nevada Time Series"
author: "J. Beem-Miller"
date: "21 Oct 2020"
output:
  pdf_document:
    latex_engine: xelatex
  html_notebook:
    toc: yes
    toc_depth: 2
    css: custom.css
header_includes:
  - \usepackage[utf8]{inputenc}
  - \usepackage{float}
---
```{r global_options, include = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE,
                      fig.align = 'center', dev = 'cairo_pdf')
```

```{r setup, include = FALSE}
library(ggplot2)
library(dplyr)
# suppress grouping information message
options(dplyr.summarise.inform = FALSE)
library(ISRaD)
library(GSIF)
library(aqp)
library(SoilR)
library(FME)
library(tidyr)
library(readxl)
library(gt)
```

# Data preparation script for Sierra Nevada time series analysis

```{r load ams-jena-ingest fx}
# 1. Read in isotope data from various sources
# First load helper functions 'read_jena_ams_results.R', 'read_jena_iso_results.R' 
source("./utilities/jena_ams_ingest.R")
source("./utilities/jena_iso_ingest.R")
source("./utilities/jena_elm_ingest.R")
```

```{r read-cn-iso-data, include = FALSE}
# 2. Next read in data from the appropriate directories in 'data/raw'
# 14C
# identify subdirectories in 'raw' directory with "ams_jena" in name
ams_jena_results_dirs <- list.files("../data/raw", pattern = "ams_jena_results", full.names = TRUE)
ams_results_ls <- lapply(seq_along(ams_jena_results_dirs), function(i) {
  read_jena_ams_results(ams_jena_results_dirs[i])
})
names(ams_results_ls) <- list.files("../data/raw", pattern = "ams_jena_results")

# # 13C
# # identify subdirectories in 'raw' directory with "iso_jena" in name
# iso_jena_results_dirs <- list.files("../data/raw", pattern = "iso_jena_results", full.names = TRUE)
# iso_results_ls <- lapply(seq_along(iso_jena_results_dirs), function(i) {
#   read_jena_iso_results(iso_jena_results_dirs[i])
# })
# names(iso_results_ls) <- list.files("../data/raw", pattern = "iso_jena_results")

# Read in C and N data
elm_results_dir <- list.files("../data/raw", pattern = "elm_jena_results", full.names = TRUE)
elm_results_ls <- lapply(seq_along(elm_results_dir), function(i) {
  read_jena_elm_results(elm_results_dir[i])
})
names(elm_results_ls) <- list.files("../data/raw", pattern = "elm_jena_results")
```

```{r data-template}
# Create template for bulk soil data
template19.fx <- function(pm, eco, ndepth) {
  df <- data.frame(Year = rep(2019, ndepth * 3),
                   PM = rep(pm, ndepth * 3),
                   ECO = rep(eco, ndepth * 3),
                   pro_rep = rep(seq(1,3), each = ndepth),
                   lyr_top = rep(seq(0, (ndepth-1) * 10, by = 10), 3),
                   lyr_bot = rep(seq(10, (ndepth) * 10, by = 10), 3))
  df$pro_name <- paste0(df$PM, df$ECO, "_", df$pro_rep)
  df$lyr_name <- paste0(df$pro_name, "_", df$lyr_top, "-", df$lyr_bot)
  return(df)
}

# Create template for composite soil data (incubations, density fractions, etc.)
template.comp.fx <- function(year, pm, eco, depth_bot = c(10, 20, 30), dat) {
  ndepth <- length(depth_bot)
  df <- data.frame(Year = rep(year, ndepth * length(pm)),
                   PM = rep(pm, each = ndepth * length(eco)),
                   ECO = rep(eco, each = ndepth))
  df$lyr_bot <- depth_bot
  df$lyr_top <- sapply(seq_along(depth_bot), function(i) {
    if (i == 1) {
      depth_top <- 0
      } else {
        depth_top <- depth_bot[i - 1]
      }
  })
  df$pro_name <- paste0(df$PM, df$ECO, "_comp")
  n <- nrow(df)
  if (dat == "inc") {
    df <- rbind(df, df)
    df$rep <- rep(c("a", "b"), each = n)
    df$lyr_name <- paste0(df$pro_name, "_", 
                          df$lyr_top, "-", 
                          df$lyr_bot, "_", 
                          df$Year, "_",
                          df$rep)
  } else if (dat == "density") {
    df <- rbind(df, df, df)
    df$frc <- rep(c("fLF", "oLF", "mnC"), each = n)
    df$lyr_name <- paste0(df$pro_name, "_", 
                          df$lyr_top, "-", 
                          df$lyr_bot, "_", 
                          df$Year, "_",
                          df$frc)
  }
  return(df)
}

# templates for bulk soil data
# GRrf 
GRrf <- template19.fx("GR", "rf", 7)
GRrf <- if(any(GRrf$lyr_name == "GRrf_1_60_70")) {
  GRrf <- GRrf[-which(GRrf$lyr_name == "GRrf_1_60_70"), ] # NB: GRrf_1_60_70 doesn't exist
} else {
  GRrf <- GRrf
}
# GRwf
GRwf <- template19.fx("GR", "wf", 9)
# GRpp
GRpp <- template19.fx("GR", "pp", 8)

# ANrf 
ANrf <- template19.fx("AN", "rf", 6)
# ANwf
ANwf <- template19.fx("AN", "wf", 6)
# ANpp
ANpp <- template19.fx("AN", "pp", 8)

# BSrf 
BSrf <- template19.fx("BS", "rf", 8)
BSrf <- if(any(BSrf$lyr_name == "GRrf_1_60_70")) {
  BSrf <- BSrf[-which(BSrf$lyr_name == "BSrf_1_70_80"), ] # NB: BSrf_1_70_80 doesn't exist
} else {
  BSrf <- BSrf
} 
# BSwf
BSwf <- template19.fx("BS", "wf", 7)
# BSpp
BSpp <- template19.fx("BS", "pp", 8)
BSpp[BSpp$lyr_bot == 80, "lyr_bot"] <- 75 # only sampled to 75cm, not 80

sra.2019.df <- rbind(GRrf, GRwf, GRpp,
                     ANrf, ANwf, ANpp,
                     BSrf, BSwf, BSpp)

# template for 2019 incubation data
sra.2019.inc.df <- template.comp.fx(2019, 
                                    pm = c("AN", "BS", "GR"),
                                    eco = c("pp", "wf", "rf"),
                                    dat = "inc")

## template for 2001 incubation data
# list of depths for 2001 inc samples
depth_bot_2001.ls <- list(ANpp = c(6, 13, 33),
                          ANwf = c(11, 35),
                          ANrf = c(11, 32),
                          BSpp = c(7, 18, 28),
                          BSwf = c(10, 19),
                          BSrf = c(8, 15, 30),
                          GRpp = c(7, 15, 27),
                          GRwf = c(4, 13, 28),
                          GRrf = c(8, 27)) 
# template for inputs to template.comp.fx (year, pm, eco)
inc.2001.template <- lapply(seq_along(depth_bot_2001.ls), function(i) {
  nms <- names(depth_bot_2001.ls)
  ls <- list(year = 2001, 
             pm = substr(nms[i], 1, 2), 
             eco = substr(nms[i], 3, 4))
  ls$depth_bot <- depth_bot_2001.ls[[i]]
  return(ls)
})
# create template data frame by iteratively calling template.comp.fx
sra.2001.inc.df <- bind_rows(
  lapply(seq_along(inc.2001.template), function(i) {
    template.comp.fx(year = inc.2001.template[[i]][[1]],
                     pm = inc.2001.template[[i]][[2]],
                     eco = inc.2001.template[[i]][[3]],
                     depth_bot = inc.2001.template[[i]][[4]],
                     dat = "inc")
  })
)

# 2001 bulk soil template
sra.2001 <- vector(mode = "list", length = length(unique(sra.2019.df$pro_name)))
names(sra.2001) <- unique(sra.2019.df$pro_name)

# 2019 bulk soil template
sra.2019 <- sra.2001

# inc templates for merging 14C data
sra.2019.inc <- vector(mode = "list", length = length(unique(sra.2019.inc.df$pro_name)))
names(sra.2019.inc) <- unique(sra.2019.inc.df$pro_name)
sra.2001.inc <- sra.2019.inc
# copies for reps of incubations
sra.2019.inc_L <- sra.2019.inc
names(sra.2019.inc_L) <- substr(names(sra.2019.inc_L), 1, 4)
```

```{r average-cn-data}
# complete cases, convert type for calculating stocks later
# could calculate stocks now and then remove for the following steps where not needed

## 2001 summary data
soc.2001 <- data.frame(read_excel("../data/external/sra_ras_sum/sierra_data_summary_2020.xlsx",
                                  sheet = "2001_bulk_data"))

# create list; remove BS samples deeper than 30 cm
soc.2001.ls <- lapply(split(soc.2001, soc.2001$PMeco), function(df) {
  df <- type.convert(df[complete.cases(df), c("ID", "C.", "bd.g.cm3", "PMeco", "pro_rep", "lyr_top", "lyr_bot")])
 return(df[which(df$lyr_bot < 36), ])
})

# Incubation samples combined 0-3 and 3-8 depth increments for BSrf and GRrf
# combine BSrf and GRrf initial depths
# function for calculating weighted average of first two depth increment C content
d1d2.fx <- function(df) {
  d1d2 <- data.frame(ID = paste(df$PMeco[1], df$pro_rep[1], df$lyr_top[1], df$lyr_bot[2], sep = "_"),
                     C. = sum(df$C.[1] * ((df$lyr_bot[1] - df$lyr_top[1]) / df$lyr_bot[2]), df$C.[2] * ((df$lyr_bot[2] - df$lyr_top[2]) / df$lyr_bot[2])),
                     bd.g.cm3 = df$bd.g.cm3[1],
                     PMeco = df$PMeco[1],
                     pro_rep = df$pro_rep[1],
                     lyr_top = df$lyr_top[1],
                     lyr_bot = df$lyr_bot[2])
  return(rbind(d1d2,
               df[3:nrow(df), ]))
}
# Run d1d2.fx for BSrf, GRrf
soc.2001.ls.inc <- soc.2001.ls 
soc.2001.ls.inc$GRrf <- bind_rows(lapply(split(soc.2001.ls$GRrf, soc.2001.ls$GRrf$pro_rep), d1d2.fx))
soc.2001.ls.inc$BSrf <- bind_rows(lapply(split(soc.2001.ls$BSrf, soc.2001.ls$BSrf$pro_rep), d1d2.fx))

# calculate SOC stocks
soc.2001.ls <- lapply(soc.2001.ls, function(df) {
  df$lyr_soc_kgm2 <- df$C. * df$bd.g.cm3 * (df$lyr_bot - df$lyr_top) * 10^-1
  return(df)
})

# summarize [note that soc stocks are dropped]
soc.2001.sum <- data.frame(bind_rows(lapply(soc.2001.ls, function(df) {
  df %>%
    mutate(ID2 = paste0(PMeco, "_", lyr_top, "-", lyr_bot)) %>%
    group_by(ID2, bd.g.cm3, PMeco, lyr_top, lyr_bot) %>%
    summarize(c_pct_avg = mean(C.))
})))

# 2019 data
sra.2019.cn.sum <- data.frame(
  bind_rows(unlist(elm_results_ls, recursive = FALSE)) %>%
  mutate(PMeco = sapply(strsplit(ID, "_"), "[", 2),
         depth = sapply(strsplit(ID, "_"), "[", 4)) %>%
  group_by(PMeco, depth) %>%
  summarize(c_pct_avg = mean(C)))
sra.2019.cn.sum$ID2 <- paste(sra.2019.cn.sum$PMeco, sra.2019.cn.sum$depth, sep = "_")
```

```{r read-resp-ts}
## read in timeseries of CO2 release from incubations
# 2019
sra.19a.co2.ts <- read.csv("../data/derived/lab_jena_CO2-timeseries/S19a_CO2_flux_2021-01-19.csv")
sra.19b.co2.ts <- read.csv("../data/derived/lab_jena_CO2-timeseries/S19b_CO2_flux_2021-01-19.csv")

# 2001
sra.01.1.co2.ts <- read.csv("../data/derived/lab_jena_CO2-timeseries/S01_1_CO2_flux_2021-01-27.csv")
sra.01.2.co2.ts <- read.csv("../data/derived/lab_jena_CO2-timeseries/S01_2_CO2_flux_2021-01-27.csv")

## Test that required names are present
nms <- c("PMeco", "ID", "dw_g", "timepoint_cmtv",  "time_d", "mgCO2_jar")
invisible(lapply(list(sra.19a.co2.ts,
                      sra.19b.co2.ts,
                      sra.01.1.co2.ts,
                      sra.01.2.co2.ts),
       function(x) {
         ifelse(!is.na(match(nms, names(x))), "yes", "no")
       }
       ))

# combine all data, remove time points without CO2 measurements, and add year and rep 
ts <- bind_rows(sra.19a.co2.ts[ , nms], 
                sra.19b.co2.ts[ , nms], 
                sra.01.1.co2.ts[ , nms],
                sra.01.2.co2.ts[ , nms])
if(length(which(is.na(ts$mgCO2_jar))) > 0) {
  ts <- ts[-which(is.na(ts$mgCO2_jar)), ]
}
ts$year <- sapply(strsplit(as.character(ts$ID), "_"), "[[", 3)
ts$rep <- sapply(strsplit(as.character(ts$ID), "_"), "[[", 4)
ts$depth <- sapply(strsplit(as.character(ts$ID), "_"), "[[", 2)
ts$ID2 <- paste(ts$PMeco, ts$depth, sep = "_")

# add C content
ts[which(ts$year == 2001), "gC_gS"] <- soc.2001.sum[match(ts[which(ts$year == 2001), "ID2"], soc.2001.sum$ID2), "c_pct_avg"] * 10^-2
ts[which(ts$year == 2019), "gC_gS"] <- sra.2019.cn.sum[match(ts[which(ts$year == 2019), "ID2"], sra.2019.cn.sum$ID2), "c_pct_avg"] * 10^-2

# calculate per unit carbon fluxes
ts$mgCO2_gC <- ts$gC_gS * ts$dw_g * ts$mgCO2_jar * (12/44)
ts$mgCO2_gC_d <- ts$mgCO2_gC / ts$time_d

# average reps
ts.avg <- ts %>%
  group_by(PMeco, year, depth, timepoint_cmtv) %>%
  summarize(time_d = mean(time_d),
            mgCO2_gC_d_avg = mean(mgCO2_gC_d),
            mgCO2_gC_d_max = max(mgCO2_gC_d),
            mgCO2_gC_d_min = min(mgCO2_gC_d),
            mgCO2_gC_avg = mean(mgCO2_gC),
            mgCO2_gC_max = max(mgCO2_gC),
            mgCO2_gC_min = min(mgCO2_gC)) %>%
  mutate(PMeco_depth_year = paste(PMeco, depth, year, sep = "_"))

# add depth index
t1 <- ts.avg[ts.avg$timepoint_cmtv == 1, ]
t1 <- data.frame(
  bind_rows(
    lapply(split(t1, t1$year), function(df) {
      bind_rows(lapply(split(df, df$PMeco), function(x) {
        x$lyr_top <- as.numeric(sapply(strsplit(x$depth, "-"), "[", 1))
        x <- x[order(x$lyr_top), ]
        x$depth_index <- seq(1, nrow(x))
        return(x)
      }))
    })))
ts.avg$depth_index <- t1[match(ts.avg$PMeco_depth_year, t1$PMeco_depth_year), "depth_index"]
```

```{r plot-resp-rates}
fig.n <- 1
# function for plotting
ts.plot.fx <- function(df, yr, increment, cumulative = TRUE) {
      if (cumulative) {
        df %>%
          filter(year == yr & depth_index == increment) %>%
          mutate(PM = ifelse(grepl("AN", PMeco), "AN",
                             ifelse(grepl("BS", PMeco), "BS", "GR")),
                 eco = factor(ifelse(grepl("rf", PMeco), "rf", 
                                     ifelse(grepl("wf", PMeco), "wf", "pp")),
                              levels = c("pp", "wf", "rf"))) %>%
          ggplot(., aes(time_d, mgCO2_gC_avg, color = PM, shape = eco)) +
          geom_ribbon(aes(ymin = mgCO2_gC_max, ymax = mgCO2_gC_min, fill = PM, linetype = eco, alpha = 0.2), show.legend = FALSE) +
          geom_point(aes(time_d, mgCO2_gC_max, fill = PM, shape = eco), color = "black", size = 3, stroke = 1) +
          geom_point(aes(time_d, mgCO2_gC_min, fill = PM, shape = eco), color = "black", size = 3, stroke = 1) +
          geom_line(aes(color = PM, linetype = eco), size = 1.2) +
          facet_grid(rows = vars(eco),
                     labeller = labeller(eco = c("rf" = "cold", "wf" = "cool", "pp" = "warm"))) +
          scale_x_continuous(limits = c(0,30)) +
          scale_color_manual(name = "Parent material",
                             labels = c("AN" = "andesite",
                                        "BS" = "basalt",
                                        "GR" = "granite"),
                             values = c("AN" = "blue", 
                                        "BS" = "red", 
                                        "GR" = "darkgray")) +
          scale_shape_manual(name = "Climate",
                             labels = c("rf" = "cold",
                                        "wf" = "cool",
                                        "pp" = "warm"),
                             values = c("pp" = 21, 
                                        "rf" = 22, 
                                        "wf" = 24)) +
          scale_fill_manual(values =c("AN" = "blue",
                                      "BS" = "red",
                                      "GR" = "darkgray")) +
          scale_linetype_manual(name = "Climate",
                                values = c("rf" = "dotted",
                                           "wf" = "dashed",
                                           "pp" = "solid"),
                                labels = c("rf" = "cold",
                                        "wf" = "cool",
                                        "pp" = "warm")) +
          ylab(expression('Cumulative flux (mgCO'[2]*'-C gC'^-1*')')) +
          xlab("Time (days)") +
          guides(color = guide_legend(order = 1),
                 shape = guide_legend(order = 3)) +
          ggtitle(paste("Cumulative flux, ", yr, "depth ", increment)) +
          theme_bw() +
          theme(panel.grid = element_blank())
    } else {
       df %>%
        filter(year == yr & depth_index == increment) %>%
        mutate(PM = ifelse(grepl("AN", PMeco), "AN",
                           ifelse(grepl("BS", PMeco), "BS", "GR")),
              eco = factor(ifelse(grepl("rf", PMeco), "rf",
                                  ifelse(grepl("wf", PMeco), "wf", "pp")),
                           levels = c("pp", "wf", "rf"))) %>%
        ggplot(., aes(time_d, mgCO2_gC_d_avg, color = PM, shape = eco)) +
        geom_ribbon(aes(ymin = mgCO2_gC_d_max, ymax = mgCO2_gC_d_min, fill = PM, linetype = eco, alpha = 0.2), show.legend = FALSE) +
          geom_point(aes(time_d, mgCO2_gC_d_max, fill = PM, shape = eco), color = "black", size = 3, stroke = 1) +
          geom_point(aes(time_d, mgCO2_gC_d_min, fill = PM, shape = eco), color = "black", size = 3, stroke = 1) +
        geom_line(aes(color = PM, linetype = eco), size = 1.2) +
        facet_grid(rows = vars(eco),
                   labeller = labeller(eco = c("rf" = "cold", "wf" = "cool", "pp" = "warm"))) +
        scale_x_continuous(limits = c(0,30)) +
        scale_color_manual(name = "Parent material",
                           labels = c("AN" = "andesite",
                                      "BS" = "basalt",
                                      "GR" = "granite"),
                           values = c("AN" = "blue", 
                                      "BS" = "red", 
                                      "GR" = "darkgray")) +
        scale_shape_manual(name = "Climate",
                           labels = c("rf" = "cold",
                                      "wf" = "cool",
                                      "pp" = "warm"),
                           values = c("pp" = 21, 
                                      "rf" = 22, 
                                      "wf" = 24)) +
        scale_fill_manual(values =c("AN" = "blue",
                                    "BS" = "red",
                                    "GR" = "darkgray")) +
        scale_linetype_manual(name = "Climate",
                              values = c("rf" = "dotted",
                                         "wf" = "dashed",
                                         "pp" = "solid"),
                              labels = c("rf" = "cold",
                                      "wf" = "cool",
                                      "pp" = "warm")) +
        ylab(expression('Respiration Rate (mgCO'[2]*'-C gC'^-1*'d'^-1*')')) +
        xlab("Time (days)") +
        guides(color = guide_legend(order = 1),
               shape = guide_legend(order = 3)) +
        ggtitle(paste("Flux rate", yr, "depth ", increment)) +
        theme_bw() +
        theme(panel.grid = element_blank())
    }
}

## cumulative flux
# 2019
ts.plot.fx(ts.avg, yr = "2019", increment = "1")
ts.plot.fx(ts.avg, yr = "2019", increment = "2")
ts.plot.fx(ts.avg, yr = "2019", increment = "3")
# 2001
ts.plot.fx(ts.avg, yr = "2001", increment = "1")
ts.plot.fx(ts.avg, yr = "2001", increment = "2")
ts.plot.fx(ts.avg, yr = "2001", increment = "3")

## flux rates
# 2019
ts.plot.fx(ts.avg, yr = "2019", increment = "1", cumulative = FALSE)
ts.plot.fx(ts.avg, yr = "2019", increment = "2", cumulative = FALSE)
ts.plot.fx(ts.avg, yr = "2019", increment = "3", cumulative = FALSE)
# 2001
ts.plot.fx(ts.avg, yr = "2001", increment = "1", cumulative = FALSE)
ts.plot.fx(ts.avg, yr = "2001", increment = "2", cumulative = FALSE)
ts.plot.fx(ts.avg, yr = "2001", increment = "3", cumulative = FALSE)
```
>**Fig. `r {fig.n}`. Respiration data from incubations of 2019 and 2001 bulk soils. **

>*Caption:* Points show measured CO~2~ production of laboratory duplicates as cumulative fluxes or daily flux rates by depth, lines show the means, and the ribbon represents the range. 

*Merge templates with 14C, C, and N data*

Radiocarbon analyses for the 2001 samples were not run originally, but were completed on archived samples in 2020.

```{r merge-iso-data-S01-soil}
# Extract 14C data for 2001 samples
ams_results_ls_S01 <- ams_results_ls[grep("S01", names(ams_results_ls))]
for(i in seq_along(sra.2001)) {
  sra.2001[[i]] <- lapply(ams_results_ls_S01, function(ls) {
    lapply(ls, function(df) {
      if(any(grepl(names(sra.2001)[i], df$Probe))) {
       df[grep(names(sra.2001)[i], df$Probe), ] 
      }
    })
  })
  sra.2001[[i]] <- Filter(Negate(is.null), unlist(sra.2001[[i]], recursive = FALSE))
}
sra.2001 <- bind_rows(unlist(sra.2001, recursive = FALSE))

# create ID field, trim df, and add depths
sra.2001$ID <- unlist(strsplit(sra.2001$Probe, "_Sierra Nevada_2001"))
sra.2001 <- sra.2001[ , c("ID", "F14C", "err", "∆14C.(‰)", "err.(‰)")]
names(sra.2001) <- c("ID", "fm", "fm_err", "d14c", "d14c_err")
sra.2001$lyr_top <- as.numeric(ifelse(substr(sra.2001$ID, 9, 9) == "-",
                                      substr(sra.2001$ID, 8, 8),
                                      substr(sra.2001$ID, 8, 9)))
sra.2001$lyr_bot <- as.numeric(ifelse(substr(sra.2001$ID, 9, 9) == "-", 
                                      substr(sra.2001$ID, 10, nchar(sra.2001$ID)),
                                      substr(sra.2001$ID, 11, nchar(sra.2001$ID))))
sra.2001$pro_rep <- substr(sra.2001$ID, 6, 6)
sra.2001$PM <- factor(substr(sra.2001$ID, 1, 2))
sra.2001$ECO <- factor(substr(sra.2001$ID, 3, 4), levels = c("pp", "wf", "rf"))
sra.2001$pro_name <- substr(sra.2001$ID, 1, 6)
sra.2001$PMeco <- substr(sra.2001$ID, 1, 4)

# remove outlier ANpp sample
sra.2001 <- sra.2001[-which(sra.2001$ID == "ANpp_3_6-13"), ]

# make list by PMeco
sra.2001.ls <- split(sra.2001, sra.2001$PMeco)
```

```{r merge-iso-data-soil-S19}
# Extract 14C data for 2019 samples
ams_results_ls_S19 <- ams_results_ls[grep("soil-S19", names(ams_results_ls))]
for(i in seq_along(sra.2019)) {
  sra.2019[[i]] <- lapply(ams_results_ls_S19, function(ls) {
    lapply(ls, function(df) {
      if(any(grepl(names(sra.2019)[i], df$Probe))) {
       df[grep(names(sra.2019)[i], df$Probe), ] 
      }
    })
  })
  sra.2019[[i]] <- Filter(Negate(is.null), unlist(sra.2019[[i]], recursive = FALSE))
}
sra.2019 <- bind_rows(unlist(sra.2019, recursive = FALSE))

## merge w/ 2019 template
# rename cols in AMS tables
sra.2019 <- sra.2019[ , c("Probe", "F14C", "err", "∆14C.(‰)", "err.(‰)")]
names(sra.2019) <- c("ID", "fm", "fm_err", "d14c", "d14c_err")
# merge
sra.2019.ls <- lapply(split(sra.2019.df, sra.2019.df$lyr_name), function(df) {
  df <- merge(df, sra.2019[grep(df$lyr_name, sra.2019$ID), ])
  df$ID <- NULL
  df$PMeco <- paste0(df$PM, df$ECO)
  return(df)
})

# reshape list by PMeco
sra.2019.ls <- split(bind_rows(sra.2019.ls), bind_rows(sra.2019.ls)[["PMeco"]])
```

```{r merge-iso-data-co2}
### Extract 14C data for incubation samples
## respired CO2, soil
# 2019
ams_results_ls_co2_S19 <- ams_results_ls[grep("co2-S19", names(ams_results_ls))]
for (i in seq_along(sra.2019.inc)) {
  sra.2019.inc[[i]] <- lapply(ams_results_ls_co2_S19, function(ls) {
    lapply(ls, function(df) {
      if (any(grepl(names(sra.2019.inc)[i], df$Probe))) {
        df[grep(names(sra.2019.inc)[i], df$Probe), ] 
      }
    })
  })
  sra.2019.inc[[i]] <- Filter(Negate(is.null), unlist(sra.2019.inc[[i]], recursive = FALSE))
}
sra.2019.inc <- type.convert(
  bind_rows(
    lapply(unlist(sra.2019.inc, recursive = FALSE), 
           function(x) x %>% mutate_all(as.character))),
  as.is = TRUE)
sra.2019.inc <- sra.2019.inc[-which(is.na(sra.2019.inc$F14C)), ]

# 2001
ams_results_ls_co2_S01 <- ams_results_ls[grep("co2-S01", names(ams_results_ls))]
# remove questionable/duplicate samples
# ANrf_comp_11-32_2001_a (analyzed twice; both anomously low compared to rep and rest of data)
ams_results_ls_co2_S01$`ams_jena_results-co2-S01_2020-12-11`$`Beem-Miller_22.xlsx` <- ams_results_ls_co2_S01$`ams_jena_results-co2-S01_2020-12-11`$`Beem-Miller_22.xlsx`[-grep("ANrf_comp_11-32_2001_a", ams_results_ls_co2_S01$`ams_jena_results-co2-S01_2020-12-11`$`Beem-Miller_22.xlsx`$Probe), ]
ams_results_ls_co2_S01$`ams_jena_results-co2-S01_2020-12-16`$`14C_SierraNevada_Inc_2001_3_results.xlsx` <- ams_results_ls_co2_S01$`ams_jena_results-co2-S01_2020-12-16`$`14C_SierraNevada_Inc_2001_3_results.xlsx`[-grep("ANrf_comp_11-32_2001_a", ams_results_ls_co2_S01$`ams_jena_results-co2-S01_2020-12-16`$`14C_SierraNevada_Inc_2001_3_results.xlsx`$Probe), ]
# from original analysis of samples extracted online 11-Dec-2020 (see readme for notes)
ams_results_ls_co2_S01$`ams_jena_results-co2-S01_2020-12-11`$`Beem-Miller_23.xlsx` <- ams_results_ls_co2_S01$`ams_jena_results-co2-S01_2020-12-11`$`Beem-Miller_23.xlsx`[-grep("GRwf_comp_13-28_2001_a_11", ams_results_ls_co2_S01$`ams_jena_results-co2-S01_2021-01-26`$`14C_SierraNevada_Inc_2001_2_results.xlsx`$Probe), ]
# from reanalysis of samples extracted online 11-Dec-2020 (see readme for notes)
# GRrf_comp_8-27_2001_a_5, GRrf_comp_8-27_2001_b_6, GRpp_comp_15-27_2001_b_18 
ams_results_ls_co2_S01$`ams_jena_results-co2-S01_2021-01-26`$`14C_SierraNevada_Inc_2001_2_results.xlsx` <- ams_results_ls_co2_S01$`ams_jena_results-co2-S01_2021-01-26`$`14C_SierraNevada_Inc_2001_2_results.xlsx`[c(
  grep("GRrf_comp_8-27_2001_a_5", ams_results_ls_co2_S01$`ams_jena_results-co2-S01_2021-01-26`$`14C_SierraNevada_Inc_2001_2_results.xlsx`$Probe),
  grep("GRwf_comp_13-28_2001_b_12", ams_results_ls_co2_S01$`ams_jena_results-co2-S01_2021-01-26`$`14C_SierraNevada_Inc_2001_2_results.xlsx`$Probe)), ]

# create template for extracting data
sra.2001.inc <- vector(mode = "list", length = length(unique(sra.2019.inc.df$pro_name)))
names(sra.2001.inc) <- unique(sra.2019.inc.df$pro_name)
# merge with 14C data
for (i in seq_along(sra.2001.inc)) {
  sra.2001.inc[[i]] <- lapply(ams_results_ls_co2_S01, function(ls) {
    lapply(ls, function(df) {
      if (any(grepl(names(sra.2001.inc)[i], df$Probe))) {
        df[grep(names(sra.2001.inc)[i], df$Probe), ] 
      }
    })
  })
  sra.2001.inc[[i]] <- Filter(Negate(is.null), unlist(sra.2001.inc[[i]], recursive = FALSE))
}
sra.2001.inc <- type.convert(
  bind_rows(
    lapply(unlist(sra.2001.inc, recursive = FALSE), 
           function(x) x %>% mutate_all(as.character))),
  as.is = TRUE)
sra.2001.inc <- sra.2001.inc[-which(is.na(sra.2001.inc$F14C)), ]

# respired CO2, litter
ams_results_ls_co2_L19 <- ams_results_ls[grep("co2-L19", names(ams_results_ls))]
for(i in seq_along(sra.2019.inc_L)) {
  sra.2019.inc_L[[i]] <- lapply(ams_results_ls_co2_L19, function(ls) {
    lapply(ls, function(df) {
      if(any(grepl(names(sra.2019.inc_L)[i], df$Probe))) {
       df[grep(names(sra.2019.inc_L)[i], df$Probe), ] 
      }
    })
  })
  sra.2019.inc_L[[i]] <- Filter(Negate(is.null), unlist(sra.2019.inc_L[[i]], recursive = FALSE))
}
sra.2019.inc_L <- bind_rows(unlist(sra.2019.inc_L, recursive = FALSE))

## merge w/ templates [why do I do this twice?]
# rename cols in AMS tables
# soil CO2
sra.2019.inc <- sra.2019.inc[ , c("Probe", "F14C", "err", "∆14C.(‰)", "err.(‰)")]
names(sra.2019.inc) <- c("ID", "fm", "fm_err", "d14c", "d14c_err")
sra.2001.inc <- sra.2001.inc[ , c("Probe", "F14C", "err", "∆14C.(‰)", "err.(‰)")]
names(sra.2001.inc) <- c("ID", "fm", "fm_err", "d14c", "d14c_err")
# merge
# 2019
sra.2019.inc.ls <- bind_rows(
  lapply(split(sra.2019.inc.df, sra.2019.inc.df$lyr_name), function(df) {
    df <- merge(df, sra.2019.inc[grep(df$lyr_name, sra.2019.inc$ID), ])
    df$ID <- NULL
    df$PMeco <- paste0(df$PM, df$ECO)
    return(df)
  })
)
sra.2019.inc.ls <- split(sra.2019.inc.ls, sra.2019.inc.ls$PMeco)
# 2001
sra.2001.inc.ls <- bind_rows(
  lapply(split(sra.2001.inc.df, sra.2001.inc.df$lyr_name), function(df) {
    df <- merge(df, sra.2001.inc[grep(df$lyr_name, sra.2001.inc$ID), ])
    df$ID <- NULL
    df$PMeco <- paste0(df$PM, df$ECO)
    return(df)
  })
)
sra.2001.inc.ls <- split(sra.2001.inc.ls, sra.2001.inc.ls$PMeco)


# litter CO2
sra.2019.inc_L <- sra.2019.inc_L[ , c("Probe", "F14C", "err", "∆14C.(‰)", "err.(‰)")]
names(sra.2019.inc_L) <- c("ID", "fm", "fm_err", "d14c", "d14c_err")
sra.2019.inc_L$ID <- substr(substring(sra.2019.inc_L$ID, 
                                      regexpr("_", sra.2019.inc_L$ID) + 1, 
                                      nchar(sra.2019.inc_L$ID)),
                            1, 8)
sra.2019.inc.df_L <- data.frame(Year = rep(2019, 18),
                                rep = rep(c(1, 2), 9),
                                PM = rep(c("AN", "BS", "GR"), each = 6),
                                eco = rep(c("pp", "wf", "rf"), each = 2, times = 3))
sra.2019.inc.df_L$PMeco <- paste0(sra.2019.inc.df_L$PM, sra.2019.inc.df_L$eco)
sra.2019.inc.df_L$ID <- paste0(sra.2019.inc.df_L$PM, sra.2019.inc.df_L$eco, "-L_", sra.2019.inc.df_L$rep)
# add dry wts and litter depth
sra.2019.L <- read.csv("../data/derived/lab_jena_litter/Litter_2019_2021-01-27.csv")
sra.2019.inc.df_L <- merge(sra.2019.inc.df_L, sra.2019.L[ , c("PMeco", "lyr_top", "lyr_bot")], all.x = TRUE)
# merge
sra.2019.inc_L.df <- bind_rows(
  lapply(split(sra.2019.inc_L, sra.2019.inc_L$ID), function(df) {
    df <- merge(df, sra.2019.inc.df_L, by = "ID")
    df$ID <- NULL
    return(df)
  })
)
sra.2019.inc_L.ls <- split(sra.2019.inc_L.df, sra.2019.inc_L.df$PMeco)
```

```{r plot-utils}
# fm and d14c conversion functions
lambda <- 1/8267 # = 1/(true mean life of 14C)
calc_fm <- function(d14c, obs_date_y) {
  ((d14c/1000) + 1)/exp(lambda * (1950 - obs_date_y))
}
calc_14c <- function(fm, obs_date_y) {
  (fm * exp(lambda * (1950 - obs_date_y)) - 1) * 1000
}

# calc atm in 2001, 2009, 2019
Datm <- rbind(graven, future14C)
atm.d14.2001 <- Datm[Datm$Date == 2001.5, "NHc14"]
atm.fm.2001 <- calc_fm(atm.d14.2001, 2001)
atm.d14.2009 <- Datm[Datm$Date == 2009.5, "NHc14"]
atm.fm.2009 <- calc_fm(atm.d14.2009, 2009)
atm.d14.2019 <- Datm[Datm$Date == 2019.5, "NHc14"]
atm.fm.2019 <- calc_fm(atm.d14.2019, 2019)
```

```{r plot-litter-14c}
fig.n <- fig.n + 1
# summarize litter inc data
sra.2019.inc_L.sum <- sra.2019.inc_L.df %>%
  mutate(eco = factor(ifelse(eco == "pp", "warm",
                             ifelse(eco == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = factor(ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))),
         Year = factor("2019")) %>%
  group_by(Year, pm, eco, lyr_top, lyr_bot) %>%
  summarize(d14c_mean = mean(d14c),
            d14c_u = max(d14c),
            d14c_l = min(d14c))

# plot as cols by climate
sra.2019.inc_L.sum %>%
  mutate(MAT = factor(eco, levels = c("warm", "cool", "cold"), labels = c("10-13", "8-10", "5-6"))) %>%
  ggplot(., aes(MAT, d14c_mean, fill = pm)) +
  geom_hline(yintercept = 0) +
  geom_hline(yintercept = atm.d14.2019, linetype = "dashed") +
  geom_col(position = "dodge2") +
  geom_errorbar(aes(ymax = d14c_u, ymin = d14c_l, color = pm), 
                position = position_dodge2(width = .5, padding = .5)) +
  scale_fill_manual(name = "Parent material",
                    values = c("andesite" = "blue", 
                               "basalt" = "red", 
                               "granite" = "darkgray")) +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  coord_flip() +
  ylab(expression(Delta*''^14*'C (‰)')) +
  xlab(expression("MAT ("*~degree*C*")")) +
  theme_bw() +
  theme(panel.grid = element_blank())

# plot as points with depth
sra.2019.inc_L.sum %>%
  ggplot(., aes(d14c_mean, lyr_top, color = pm)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = atm.d14.2019, linetype = "dashed") +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmax = d14c_u, xmin = d14c_l), height = 1) +
  scale_y_reverse() +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  facet_grid(rows = vars(eco)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  theme_bw() +
  theme(panel.grid = element_blank())
```
>**Fig. `r {fig.n}`. Litter incubation $\Delta$^14^C-CO~2~ (2019)**

>*Caption:* Mean $\Delta$^14^C-CO~2~ for each site. Error bars show min and max of duplicate incubation samples. ^a)^ Data shown by site, without litter depth, ^b)^ Data shown by depth of litter layer, binned by climate zone.

```{r plot-14c-profile-fx}
pro.plot <- function(df, maxDepth, min14C, rep) {
  ggplot(df, aes(d14c, lyr_bot, color = PM, shape = ECO, group = rep)) +
    geom_vline(xintercept = 0) +
    geom_hline(yintercept = 0) +
    geom_point(size = 3) +
    geom_path() +
    scale_y_reverse(limits = c(maxDepth, 0)) +
    scale_x_continuous(limits = c(min14C, 180)) +
    scale_color_manual(name = "parent material",
                       labels = c("AN" = "andesite",
                                  "BS" = "basalt",
                                  "GR" = "granite"),
                       values = c("AN" = "blue", 
                                  "BS" = "red", 
                                  "GR" = "darkgray")) +
    scale_shape_manual(name = "ecosystem",
                       labels = c("pp" = expression(italic("P. ponderosa")),
                                  "rf" = expression(italic("A. magnifica")),
                                  "wf" = expression(italic("A. concolor"))),
                       values = c("pp" = 15, 
                                  "rf" = 16, 
                                  "wf" = 17)) +
    xlab(expression(Delta*''^14*'C (‰)')) +
    ylab("Depth (cm)") +
    theme_bw() +
    theme(panel.grid.minor = element_blank())
}
```

```{r plot-2001-profiles}
# lapply(sra.2001.ls, function(df) pro.plot(df, max(df$lyr_bot), min(df$d14c), df$pro_rep))
```

```{r plot-2019-profiles}
# lapply(sra.2019.ls, function(df) pro.plot(df, max(df$lyr_bot), min(df$d14c), df$pro_rep))
```

```{r plot-2019-co2-profiles}
# lapply(sra.2019.inc.ls, function(df) pro.plot(df, max(df$lyr_bot), min(df$d14c), NA))
```

## 2001 mean radiocarbon profiles
```{r plot-2001-avg-profiles}
# combine reps
sra.2001.sum.ls  <- lapply(sra.2001.ls, function(df) {
  df <- data.frame(df %>%
                     filter(lyr_bot <= 40) %>%
                     mutate(lyr_top_ch = as.character(lyr_top),
                            lyr_bot_ch = as.character(lyr_bot)) %>%
                     select(PM, ECO, PMeco, fm, d14c, lyr_top_ch, lyr_bot_ch) %>%
                     group_by(PM, ECO, PMeco, lyr_top_ch, lyr_bot_ch) %>%
                     summarize_all(list(mean = mean, sd = sd), na.rm = TRUE))
  names(df) <- c("PM", "ECO", "PMeco", "lyr_top", "lyr_bot", "fm", "d14c", "fm_sd", "d14c_sd")
  df$lyr_top <- as.numeric(df$lyr_top)
  df$lyr_bot <- as.numeric(df$lyr_bot)
  df$d14c_u <- df$d14c + df$d14c_sd
  df$d14c_l <- df$d14c - df$d14c_sd
  return(df[order(df$lyr_bot), ])
})
sra.01.sum <- bind_rows(sra.2001.sum.ls) %>%
  mutate(eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite")))

# plot
fig.n <- fig.n + 1
sra.01.sum %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = eco, group = PMeco)) +
  geom_vline(xintercept = atm.d14.2001) +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  geom_path() +
  scale_y_reverse(limits = c(40, 0)) +
  scale_x_continuous(limits = c(-100, 180)) +    
  scale_color_manual(name = "parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Mean profile $\Delta$^14^C for 2001 samples**

>*Caption:* Mean $\Delta$^14^C by depth for each site in 2001. Error bars show ±1 standard deviation, solid vertical line shows $\Delta$^14^C of the atmosphere in the year of sampling.

## 2009 radiocarbon profiles
```{r plot-2009-profiles}
# 2009 data (from C. Rasmussen)
ras18.lyr <- read.csv("/Users/jeff/R/14Constraint/ras_2018.csv")
ras18.lyr$ECO <- factor(ras18.lyr$MAST, labels = c("rf","wf","pp"))
# add PMeco col
ras18.lyr$ECO <- factor(ras18.lyr$MAST, labels = c("rf","wf","pp"))
ras18.lyr$PMeco <- paste0(ras18.lyr$PM, ras18.lyr$ECO)

# summarize 09 data
sra.09.sum <- ras18.lyr %>%
  mutate(eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite")))

fig.n <- fig.n + 1
sra.09.sum %>%
  ggplot(., aes(lyr_14c, lyr_bot, color = pm, shape = eco, group = PMeco)) +
  geom_vline(xintercept = atm.d14.2009) +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_path(linetype = "dashed") +
  scale_y_reverse() +
  scale_x_continuous(limits = c(-100, 180)) +    
  scale_color_manual(name = "parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "ecosystem",
                     values = c("warm" = 0, 
                                "cool" = 1, 
                                "cold" = 2)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Profile $\Delta$^14^C for 2009 samples**

>*Caption:* Profile $\Delta$^14^C by depth for each site in 2009. Solid vertical line shows $\Delta$^14^C of the atmosphere in the year of sampling. Error bars not shown as only a single replicate profile was analyzed per site.

## 2019 mean radiocarbon profiles
```{r plot-2019-avg-profiles}
# combine reps
sra.2019.sum.ls  <- lapply(sra.2019.ls, function(df) {
  df <- data.frame(df %>%
                     mutate(lyr_top_ch = as.character(lyr_top),
                            lyr_bot_ch = as.character(lyr_bot)) %>%
                     select(PM, ECO, PMeco, fm, d14c, lyr_top_ch, lyr_bot_ch) %>%
                     group_by(PM, ECO, PMeco, lyr_top_ch, lyr_bot_ch) %>%
                     summarize_all(list(mean = mean, sd = sd), na.rm = TRUE))
  names(df) <- c("PM", "ECO", "PMeco", "lyr_top", "lyr_bot", "fm", "d14c", "fm_sd", "d14c_sd")
  df$lyr_top <- as.numeric(df$lyr_top)
  df$lyr_bot <- as.numeric(df$lyr_bot)
  df$d14c_u <- df$d14c + df$d14c_sd
  df$d14c_l <- df$d14c - df$d14c_sd
  return(df)
})
sra.19.sum <- bind_rows(sra.2019.sum.ls) %>%
  mutate(eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) 

# plot
fig.n <- fig.n + 1
sra.19.sum %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = eco, group = PMeco)) +
  geom_vline(xintercept = atm.d14.2019) +
  geom_hline(yintercept = 0) +
  geom_point(size = 2.7) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  geom_path() +
  scale_y_reverse(limits = c(max(sra.19.sum$lyr_bot), 0)) +
  scale_x_continuous(limits = c(min(sra.19.sum$d14c), 180)) +    
  scale_color_manual(name = "parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Mean profile $\Delta$^14^C for 2019 samples**

>*Caption:* Mean $\Delta$^14^C by depth for each site in 2019. Error bars show ±1 standard deviation, solid vertical line shows $\Delta$^14^C of the atmosphere in the year of sampling.

## Change in $\Delta$^14^C over time between 2001 and 2019 

```{r plot-all-avg}
# combine '01 and '19 data for plotting
sra.01.sum$Year <- 2001
sra.19.sum$Year <- 2019

sra.all <- rbind(sra.01.sum, sra.19.sum)
sra.all$Year <- as.factor(sra.all$Year)

fig.n <- fig.n + 1
sra.all %>%
  mutate(PMeco_year = paste0(PMeco, Year),
         ecoYear = paste0(ECO, Year),
         ecoYear2 = ifelse(ecoYear == "pp2001", "warm (2001)",
                           ifelse(ecoYear == "pp2019", "warm (2019)",
                                  ifelse(ecoYear == "wf2001", "cool (2001)",
                                         ifelse(ecoYear == "wf2019", "cool (2019)",
                                                ifelse(ecoYear == "rf2001", "cold (2001)", "cold (2019)")))))) %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = ecoYear2, group = PMeco_year)) +
  geom_vline(xintercept = atm.d14.2001) +
  geom_vline(xintercept = atm.d14.2019, linetype = "dashed") +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  geom_path(aes(linetype = Year)) +
  scale_y_reverse(limits = c(41, 0)) +
  scale_color_manual(name = "parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem (year)",
                     values = c("warm (2001)" = 15, 
                                "cool (2001)" = 16, 
                                "cold (2001)" = 17,
                                "warm (2019)" = 0, 
                                "cool (2019)" = 1, 
                                "cold (2019)" = 2)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Mean profile $\Delta$^14^C for 2001 and 2019 samples**

>*Caption:* Mean $\Delta$^14^C by depth for each site in 2001 and 2019. Error bars show ±1 standard deviation. Vertical lines show $\Delta$^14^C of the atmosphere in 2001 (solid) and 2019 (dashed).

## Incubation $\Delta$^14^C-CO~2~

```{r inc-d14c-plot-setup}
## 2019
sra.2019.inc.df <- bind_rows(sra.2019.inc.ls)
# add litter inc data and summarize
sra.2019.inc.sum.df <- data.frame(rbind(
  sra.2019.inc_L.sum[ , which(names(sra.2019.inc_L.sum) != "lyr_top")],
  sra.2019.inc.df %>%
    mutate(eco = factor(ifelse(ECO == "pp", "warm",
                             ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
           pm = factor(ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))),
           # remove GRrf 10-20 "a" point
           d14c = replace(d14c, which(d14c < -300), NA),
           Year = factor(Year)) %>%
  group_by(Year, pm, eco, lyr_bot, lyr_top) %>%
  summarize(d14c_mean = mean(d14c, na.rm = TRUE),
            d14c_l = min(d14c, na.rm = TRUE),
            d14c_u = max(d14c, na.rm = TRUE)) %>%
    select(-lyr_top)))

# 2001
sra.2001.inc.df <- bind_rows(sra.2001.inc.ls)
sra.2001.inc.sum.df <- data.frame(
  sra.2001.inc.df %>%
    mutate(eco = factor(ifelse(ECO == "pp", "warm",
                               ifelse(ECO == "wf", "cool", "cold")),
                        levels = c("warm", "cool", "cold")),
           pm = factor(ifelse(PM == "AN", "andesite",
                       ifelse(PM == "BS", "basalt", "granite"))),
           Year = factor(Year)) %>%
    group_by(Year, PMeco, pm, eco, lyr_bot, lyr_top) %>%
    summarize(d14c_mean = mean(d14c),
              d14c_l = min(d14c),
              d14c_u = max(d14c),
              fm_mean = mean(fm),
              fm_l = min(fm),
              fm_u = max(fm))
)
sra.2001.inc.sum.ls <- split(sra.2001.inc.sum.df, sra.2001.inc.sum.df$PMeco)
sra.2001.inc.sum.df <- sra.2001.inc.sum.df[ , !(names(sra.2001.inc.sum.df) %in% c("fm_mean", "fm_l", "fm_u", "lyr_top", "PMeco"))]
```

```{r plot-inc-d14c-2019}
# 2019
fig.n <- fig.n + 1
sra.2019.inc.sum.df[order(sra.2019.inc.sum.df$lyr_bot), ] %>%
  ggplot(., aes(d14c_mean, lyr_bot, color = pm, shape = eco)) +
  geom_vline(xintercept = atm.d14.2019, linetype = "dashed") +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_errorbarh(
    aes(xmin = d14c_l,
        xmax = d14c_u,
        color = pm),
    height = 1.5) +
  geom_path(linetype = "dashed") +
  scale_y_reverse() +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("warm" = 0, 
                                "cool" = 1, 
                                "cold" = 2)) +
  xlab(expression('Incubation '*Delta*''^14*'C-CO'[2]*' (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. $\Delta$^14^C-CO~2~ of 2019 bulk soil incubations**

>*Caption:* $\Delta$^14^CO~2~ by depth for each site in 2019. One rep from GRrf 10-20 (the 10-20 cm increment sample from the cold granite site) is strongly depleted relative to the other rep: $\Delta$^14^C-CO~2~ = `r {sra.2019.inc.df[sra.2019.inc.df$PMeco == "GRrf" & sra.2019.inc.df$lyr_bot == 20, "d14c"]}`. The highly depleted sample has been excluded for display reasons.

```{r plot-inc-d14c-2001}
# plot 2001 data
fig.n <- fig.n + 1
sra.2001.inc.sum.df %>%
  ggplot(., aes(d14c_mean, lyr_bot, color = pm, shape = eco)) +
  geom_vline(xintercept = atm.d14.2001) +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_errorbarh(
    aes(xmin = d14c_l,
        xmax = d14c_u,
        color = pm),
    height = 1.5) +
  geom_path() +
  scale_y_reverse() +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue",
                                "basalt" = "red",
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("warm" = 15,
                                "cool" = 16,
                                "cold" = 17)) +
  scale_x_continuous(limits = c(-70, 190)) +
  xlab(expression('Incubation '*Delta*''^14*'C-CO'[2]*' (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. $\Delta$^14^C-CO~2~ of 2001 bulk soil incubations**

>*Caption:* $\Delta$^14^CO~2~ by depth for each site in 2001. Note that some sites only have two depth increments. Similar to the 2019 dataset, one of the GRrf reps from the deepest depth increment was strongly depleted: $\Delta$^14^C-CO~2~ = `r {sra.2001.inc.sum.df %>% filter(pm == "granite", eco == "cold", lyr_bot == 27) %>% pull("d14c_l", "d14c_u")}`. Both points have been excluded for display reasons.

```{r plot-inc-d14c-all}
# plot together
sra.inc.all <- rbind(sra.2001.inc.sum.df, sra.2019.inc.sum.df)

fig.n <- fig.n + 1 
sra.inc.all %>%
  filter(lyr_bot > 0) %>%
  mutate(PMeco_year = paste0(pm, eco, Year),
         ecoYear = paste0(eco, " (", Year, ")")) %>%
  ggplot(., aes(d14c_mean, lyr_bot, color = pm, shape = ecoYear, group = PMeco_year)) +
  geom_vline(xintercept = atm.d14.2001) +
  geom_vline(xintercept = atm.d14.2019, linetype = "dashed") +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  geom_path(aes(linetype = Year)) +
  scale_y_reverse(limits = c(41, 0)) +
  scale_color_manual(name = "parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem (year)",
                     values = c("warm (2001)" = 15, 
                                "cool (2001)" = 16, 
                                "cold (2001)" = 17,
                                "warm (2019)" = 0, 
                                "cool (2019)" = 1, 
                                "cold (2019)" = 2)) +
  scale_x_continuous(limits = c(-70, 190)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. $\Delta$^14^C-CO~2~ of 2001 and 2019 bulk soil incubations**

>*Caption:* $\Delta$^14^CO~2~ by depth for each site in 2001 and 2019. Different depth increments were sampled in 2001 and 2019. Points are the mean of laboratory duplicates; error bars are the measured values of each duplicate. Granite/cold point exlcuded for display reasons as it is strongly depleted.

## Incubation vs. bulk soil $\Delta$^14^C

```{r inc-bulk-d14c-plot-setup}
# bind rows of inc list
sra.19.inc <- sra.2019.inc.sum.df
sra.19.inc$Type <- "inc"

# 2001
sra.01.inc <- sra.2001.inc.sum.df
sra.01.inc$Type <- "inc"

# rbind bulk data
sra.19.bulk <- sra.19.sum[which(sra.19.sum$lyr_bot < 31), c("Year", "PM", "ECO", "lyr_bot","d14c", "d14c_l", "d14c_u")]
names(sra.19.bulk)[which(names(sra.19.bulk) == "d14c")] <- "d14c_mean"
sra.19.bulk$Type <- "bulk"
sra.19.bulk <- sra.19.bulk %>%
  mutate(pm = factor(ifelse(PM == "AN", "andesite",
                            ifelse(PM == "BS", "basalt", "granite"))),
         eco = factor(ifelse(ECO == "pp", "warm",
                             ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         PM = NULL,
         ECO = NULL)
sra.19.inc.blk <- rbind(data.frame(sra.19.inc), data.frame(sra.19.bulk))
save(sra.19.inc.blk, file = "sra.19.inc.blk.RData")

# 2001
# Need to calculate weighted average of radiocarbon values and stocks for combined inc depths 
# 1) add SOC stocks to duplicate sra.2001.ls obj
sra.2001.ls2 <- sra.2001.ls
for(i in seq_along(sra.2001.ls2)) {
  ix <- match(sra.2001.ls2[[i]][["ID"]], soc.2001.ls[[i]][["ID"]])
  sra.2001.ls2[[i]]["lyr_soc_kgm2"] <- soc.2001.ls[[i]][ix, "lyr_soc_kgm2"]
}
# 2) weighted average fx
d1d2.14c.fx <- function(df) {
  sum_soc <- sum(df[1:2, "lyr_soc_kgm2"])
  wt1 <- df$lyr_soc_kgm2[1] / sum_soc
  wt2 <- df$lyr_soc_kgm2[2] / sum_soc
  d1d2 <- df[1, ]
  d1d2$ID = paste(df$PMeco[1], df$pro_rep[1], df$lyr_top[1], df$lyr_bot[2], sep = "_")
  d1d2$lyr_soc_kgm2 = sum(df$lyr_soc_kgm2[1], df$lyr_soc_kgm2[2])
  d1d2$lyr_bot = df$lyr_bot[2]
  d1d2$fm <- sum(df$fm[1] * wt1, df$fm[2] * wt2)
  d1d2$d14c <- sum(df$d14c[1] * wt1, df$d14c[2] * wt2)
  return(rbind(d1d2,
               df[3:nrow(df), ]))
}
# 3) calc. wtd. average for GRrf
sra.2001.ls2$GRrf <- bind_rows(
  lapply(split(sra.2001.ls2$GRrf, sra.2001.ls2$GRrf$pro_rep), function(x) {
    d1d2.14c.fx(x)
  })
)
# 4) calc. wtd. average for BSrf
#    - problem here is that only one pro_rep has 0-3 cm data
#    - so, need to calculate weighted SOC, then calculate weighted 14C
#    - composite 0-8 = 15g BSrf_1_0-3 + 5 g from each pro_rep BSrf_3-8
BSrf_comp_01_i <- sra.2001.ls2$BSrf[which(sra.2001.ls$BSrf$lyr_bot < 9), ]
BSrf_comp_01_i$soc_wt <- c(15 / 30, rep(5 / 30, 3))
BSrf_comp_01_i$soc_wtd <- BSrf_comp_01_i$lyr_soc_kgm2 * BSrf_comp_01_i$soc_wt

# create summarized list
sra.2001.sum.ls2  <- lapply(sra.2001.ls2, function(df) {
  data.frame(
    df %>%
      filter(lyr_bot <= 40) %>%
      mutate(lyr_bot_ch = as.character(lyr_bot)) %>%
      select(PMeco, d14c, fm, lyr_bot_ch, lyr_soc_kgm2) %>%
      group_by(PMeco, lyr_bot_ch) %>%
      summarize(
        across(where(is.numeric), list(mean = mean, sd = sd), na.rm = TRUE)) %>%
      mutate(lyr_bot = as.numeric(lyr_bot_ch)) %>%
      select(-lyr_bot_ch)
  )
})

# remove BSrf row w/ lyr_bot = 3
sra.2001.sum.ls2$BSrf <- sra.2001.sum.ls2$BSrf[-which(sra.2001.sum.ls2$BSrf$lyr_bot == 3), ]
# calculate weighted average for d14c, fm, lyr_soc_kgm2
sra.2001.sum.ls2$BSrf[which(sra.2001.sum.ls2$BSrf$lyr_bot == 8), "d14c_mean"] <- sum(BSrf_comp_01_i$d14c * (BSrf_comp_01_i$soc_wtd / sum(BSrf_comp_01_i$soc_wtd)))
sra.2001.sum.ls2$BSrf[which(sra.2001.sum.ls2$BSrf$lyr_bot == 8), "fm_mean"] <- sum(BSrf_comp_01_i$fm * (BSrf_comp_01_i$soc_wtd / sum(BSrf_comp_01_i$soc_wtd)))
sra.2001.sum.ls2$BSrf[which(sra.2001.sum.ls2$BSrf$lyr_bot == 8), "lyr_soc_kgm2_mean"] <- sum(BSrf_comp_01_i$soc_wtd)
sra.2001.sum.ls2$BSrf[which(sra.2001.sum.ls2$BSrf$lyr_bot == 8), c("d14c_sd", "fm_sd", "lyr_soc_kgm2_sd")] <- NA

# calculate cmtv soc
sra.2001.sum.ls2 <- lapply(sra.2001.sum.ls2, function(x) {
  x <- x[order(x$lyr_bot), ]
  x$lyr_soc_cmtv <- NA
  for(i in seq_along(x$lyr_bot)) {
      if(i == 1) {
        x$lyr_soc_cmtv[i] <- x$lyr_soc_kgm2_mean[i]
      } else {
        x$lyr_soc_cmtv[i] <- x$lyr_soc_kgm2_mean[i] + x$lyr_soc_cmtv[i-1] 
      }
  }
  return(x)
})

# make df
sra.01.sum <- data.frame(bind_rows(
  lapply(sra.2001.sum.ls2, function(df) {
    df %>%
      mutate(eco = factor(ifelse(grepl("pp", df$PMeco), "warm",
                                 ifelse(grepl("wf", df$PMeco), "cool", "cold")),
                          levels = c("warm", "cool", "cold")),
             pm = ifelse(grepl("AN", df$PMeco), "andesite",
                         ifelse(grepl("BS", df$PMeco), "basalt", "granite")),
             d14c_u = d14c_mean + d14c_sd,
             d14c_l = d14c_mean - d14c_sd,
             Year = 2001,
             Type = "bulk") %>%
      select(names(sra.01.inc)) %>%
      arrange(lyr_bot)
  })
))
# bind with inc
sra.01.inc.blk <- rbind(data.frame(sra.01.inc), sra.01.sum)
save(sra.01.inc.blk, file = "sra.01.inc.blk.RData")
```

```{r plot-inc-blk-2019}
# plot 2019
fig.n <- fig.n + 1
# p <-
sra.19.inc.blk %>%
  mutate(ECOtype = paste0(eco, " (", Type, ")")) %>%
  arrange(lyr_bot) %>%
  ggplot(., aes(d14c_mean, lyr_bot, color = pm, shape = ECOtype, linetype = Type)) +
  geom_vline(xintercept = atm.d14.2019) +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  geom_path() +
  scale_y_reverse() +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem (type)",
                     values = c("warm (bulk)" = 15, 
                                "cool (bulk)" = 16, 
                                "cold (bulk)" = 17,
                                "warm (inc)" = 0, 
                                "cool (inc)" = 1, 
                                "cold (inc)" = 2)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
# ggsave("sra.bulkInc.19.pdf", p, device = cairo_pdf, width = 9.5, height = 5, units = "in")
```
>**Fig. `r {fig.n}`. $\Delta$^14^C of 2019 bulk soil incubations and corresponding bulk soil**

>*Caption:* $\Delta$^14^C of bulk soil and respired CO~2~ by depth for each site in 2019. Error bars show one standard deviation for bulk soil, points show mean of three replicate profiles for bulk soils and single observations for respired CO~2~. 

```{r plot-inc-blk-2001}
# plot 2001
fig.n <- fig.n + 1
sra.01.inc.blk %>%
  mutate(ECOtype = paste0(eco, " (", Type, ")")) %>%
  ggplot(., aes(d14c_mean, lyr_bot, color = pm, shape = ECOtype, linetype = Type)) +
  geom_vline(xintercept = atm.d14.2001) +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  geom_path() +
  scale_y_reverse() +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem (type)",
                     values = c("warm (bulk)" = 15, 
                                "cool (bulk)" = 16, 
                                "cold (bulk)" = 17,
                                "warm (inc)" = 0, 
                                "cool (inc)" = 1, 
                                "cold (inc)" = 2)) +
  scale_x_continuous(limits = c(-100, 200)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. $\Delta$^14^C of 2001 bulk soil incubations and corresponding bulk soil**

>*Caption:* $\Delta$^14^C of bulk soil and respired CO~2~ by depth for each site in 2001. Points show mean of three replicate profiles for bulk soils and mean of laboratory duplicates for respired CO~2~. The incubated soil samples are a composite made by homogenizing subsamples from each of the three replicate profile samples by depth. Error bars show one standard deviation for bulk soil and the measured values from laboratory duplicates of the incubated composite samples.

```{r prep-inc-by-bulk-14c-plot}
# first merge mean 14C data from 2019 samples with composite incubation data
nms.inc.blk <- c("pm", "eco", "lyr_bot", "Year")
sra.19.inc.blk2 <- left_join(sra.19.bulk %>% mutate(., Year = as.factor(Year)),
                             sra.2019.inc.sum.df,
                             by = nms.inc.blk,
                             suffix = c(".bulk", ".inc"))
# 2001
sra.01.inc.blk2 <- left_join(sra.01.sum %>% mutate(., Year = as.factor(Year)),
                             sra.01.inc,
                             by = nms.inc.blk,
                             suffix = c(".bulk", ".inc"))
sra.01.inc.blk2$PMeco <- paste0(sra.01.inc.blk2$pm, sra.01.inc.blk2$eco)
# add depth factor
sra.01.inc.blk2 <- unsplit(
  lapply(split(sra.01.inc.blk2, sra.01.inc.blk2$PMeco), function(x) {
  x$depth <- seq(1, nrow(x))
  return(x) 
  }), 
sra.01.inc.blk2$PMeco)
sra.01.inc.blk2 <- sra.01.inc.blk2[which(sra.01.inc.blk2$lyr_bot < 35), ]
sra.01.inc.blk2$depth <- factor(sra.01.inc.blk2$depth)

# regress bulk vs. inc
min.inc.blk.19 <- min(sra.19.inc.blk2$d14c_l.inc,
                      sra.19.inc.blk2$d14c_l.bulk) # exclude highly negative incubation sample from GRwf
max.inc.blk.19 <- max(sra.19.inc.blk2$d14c_l.inc,
                      sra.19.inc.blk2$d14c_l.bulk)

# What is the ideal grouping/expected relationship?
```

```{r plot-inc-by-bulk-14c}
## look at combinatorial dataset
# sra.all.df.fx <- function(ls, year) {
#   cbind(bind_rows(lapply(ls, function(df) df[ , c("PMeco", "lyr_bot", "d14c")])),
#         year = year)
# }
# sra.all.df <- inner_join(
#   rbind(sra.all.df.fx(sra.2001.ls, 2001),
#         sra.all.df.fx(sra.2019.ls, 2019)),
#   rbind(sra.all.df.fx(sra.2001.inc.ls, 2001),
#         sra.all.df.fx(sra.2019.inc.ls, 2019)),
#   by = c("PMeco", "lyr_bot", "year"),
#   suffix = c("_bulk", "_inc"))
# sra.all.df <- sra.all.df %>%
#   mutate(PM = substr(PMeco, 1, 2),
#          ECO = substr(PMeco, 3, 4))
# 
# sra.all.df %>%
#   filter(d14c_inc > -130) %>%
#   ggplot(., aes(d14c_bulk, d14c_inc, color = PM)) +
#   geom_vline(xintercept = 0) +
#   geom_hline(yintercept = 0) +
#   geom_abline(slope = 1, intercept = 0) +
#   geom_smooth(method = "lm", formula = y ~ x, aes(fill = PM)) +
#   geom_point() +
#   scale_color_manual(name = "Parent material",
#                      values = c("AN" = "blue",
#                                 "BS" = "red",
#                                 "GR" = "darkgray"),
#                      labels = c("AN" = "andesite",
#                                 "BS" = "basalt",
#                                 "GR" = "granite")) +
#     scale_fill_manual(name = "Parent material",
#                      values = c("AN" = "blue",
#                                 "BS" = "red",
#                                 "GR" = "darkgray"),
#                      labels = c("AN" = "andesite",
#                                 "BS" = "basalt",
#                                 "GR" = "granite")) +
#   coord_fixed(xlim = c(-130, 200), ylim = c(-130, 200)) +
#   xlab(expression('Bulk soil '*Delta*''^14*'C (‰)')) +
#   ylab(expression('Incubation '*Delta*''^14*'C (‰)')) +
#   theme_bw() +
#   theme(panel.grid.minor = element_blank())
#   
# summary(lm(d14c_inc ~ d14c_bulk * PM, sra.all.df[sra.all.df$d14c_inc > -130, ]))

# join all data as means and sds
sra.all.sum.df <- left_join(
  bind_rows(sra.2001.sum.ls2) %>%
    select(PMeco, lyr_bot, d14c_mean, d14c_sd) %>%
    mutate(Year = 2001) %>%
    bind_rows(., 
              bind_rows(lapply(sra.2019.ls, function(df) {
                df %>%
                  filter(lyr_bot < 31) %>%
                  select(PMeco, lyr_bot, d14c) %>%
                  group_by(PMeco, lyr_bot) %>%
                  summarize(across(d14c, list(mean = mean, sd = sd))) %>%
                  mutate(Year = 2019)
                }))
            ),
  bind_rows(lapply(sra.2001.inc.ls, function(df) {
              df %>%
                select(PMeco, lyr_bot, d14c) %>%
                group_by(PMeco, lyr_bot) %>%
                summarize(across(d14c, list(mean = mean, sd = sd))) %>%
                mutate(Year = 2001) 
              })) %>%
  bind_rows(., 
            bind_rows(lapply(sra.2019.inc.ls, function(df) {
              df %>%
                select(PMeco, lyr_bot, d14c) %>%
                group_by(PMeco, lyr_bot) %>%
                summarize(across(d14c, list(mean = mean, sd = sd))) %>%
                mutate(Year = 2019)
              }))
            ), 
  by = c("PMeco", "lyr_bot", "Year"),
  suffix = c(".bulk", ".inc")) %>%
  mutate(PM = substring(PMeco, 1, 2),
         eco = substring(PMeco, 3, 4))

# simple linear regression of means
summary(lm(d14c_mean.inc ~ d14c_mean.bulk * PM, sra.all.sum.df[sra.all.sum.df$d14c_mean.inc > -200, ]))

# lapply(split(sra.all.sum.df, sra.all.sum.df$eco), function(df) {
#   summary(lm(d14c_mean.inc ~ d14c_mean.bulk * PM, df))
# })

# # Deming regression (accounts for error in x and y terms)
# sra.dem <- lapply(split(sra.all.sum.df, sra.all.sum.df$PM), function(df) {
#   deming(d14c_mean.inc ~ d14c_mean.bulk,
#        data = df, xstd = d14c_sd.inc, ystd = d14c_sd.bulk)
# })

# all depths and years together, by PM
fig.n <- fig.n + 1
sra.19.inc.blk2  %>%
  bind_rows(., sra.01.inc.blk2[ , which(names(sra.19.inc.blk2) %in% names(sra.01.inc.blk2))]) %>%
  mutate(depth = factor(lyr_bot),
         ecoYear = paste0(eco, " (", Year, ")")) %>%
  filter(d14c_mean.inc > -200) %>%
  ggplot(., aes(d14c_mean.bulk, d14c_mean.inc, color = pm)) +
  # geom_vline(xintercept = atm.d14.2019, linetype = "dashed") +
  geom_vline(xintercept = 0) +
  # geom_hline(yintercept = atm.d14.2019, linetype = "dashed") +
  geom_hline(yintercept = 0) +
  geom_abline(slope = 1, intercept = 0) +
  geom_point(aes(color = pm, shape = ecoYear), size = 3) +
  geom_smooth(method = "lm", formula = y ~ x, se = FALSE) +
  geom_errorbarh(
    aes(xmin = d14c_l.bulk, 
        xmax = d14c_u.bulk,
        color = pm), 
    height = 1.5) +
  geom_errorbar(
    aes(ymin = d14c_l.inc, 
        ymax = d14c_u.inc,
        color = pm), 
    width = 1.5) +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue",
                                "basalt" = "red",
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem (year)",
                     values = c("warm (2019)" = 0,
                                "cool (2019)" = 1,
                                "cold (2019)" = 2,
                                "warm (2001)" = 15,
                                "cool (2001)" = 16,
                                "cold (2001)" = 17)) +
  coord_fixed(xlim = c(-100, 200), ylim = c(-100, 200)) +
  xlab(expression('Bulk soil '*Delta*''^14*'C (‰)')) +
  ylab(expression('Incubation '*Delta*''^14*'C (‰)')) +
  # facet_grid(rows = vars(depth)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())

# # 2001
# sra.01.inc.blk2 %>%
#   filter(d14c_mean.bulk > -100 & d14c_mean.inc > -100) %>%
#   ggplot(., aes(d14c_mean.bulk, d14c_mean.inc, color = pm, shape = eco, group = pm)) +
#   # geom_vline(xintercept = atm.d14.2019, linetype = "dashed") +
#   geom_vline(xintercept = 0) +
#   # geom_hline(yintercept = atm.d14.2019, linetype = "dashed") +
#   geom_hline(yintercept = 0) +
#   geom_abline(slope = 1, intercept = 0) +
#   geom_point(size = 3) +
#   geom_smooth(method = "lm", formula = y ~ x, se = FALSE) +
#   geom_errorbarh(
#     aes(xmin = d14c_l.bulk, 
#         xmax = d14c_u.bulk,
#         color = pm), 
#     height = 1.5) +
#   geom_errorbar(
#     aes(ymin = d14c_l.inc, 
#         ymax = d14c_u.inc,
#         color = pm), 
#     width = 1.5) +
#   scale_color_manual(name = "Parent material",
#                      values = c("andesite" = "blue",
#                                 "basalt" = "red",
#                                 "granite" = "darkgray")) +
#   scale_shape_manual(name = "Ecosystem",
#                      values = c("warm" = 15,
#                                 "cool" = 16,
#                                 "cold" = 17)) +
#   coord_fixed(xlim = c(-100, 200), ylim = c(-100, 200)) +
#   xlab(expression('Bulk soil '*Delta*''^14*'C (‰)')) +
#   ylab(expression('Incubation '*Delta*''^14*'C (‰)')) +
#   facet_grid(rows = vars(depth)) +
#   theme_bw() +
#   theme(panel.grid.minor = element_blank())
# 
# # 2019
# fig.n <- fig.n + 1
# sra.19.inc.blk2 %>%
#   mutate(depth = factor(lyr_bot)) %>%
#   ggplot(., aes(d14c_mean.bulk, d14c_mean.inc, color = pm, shape = eco, group = pm)) +
#   # geom_vline(xintercept = atm.d14.2019, linetype = "dashed") +
#   geom_vline(xintercept = 0) +
#   # geom_hline(yintercept = atm.d14.2019, linetype = "dashed") +
#   geom_hline(yintercept = 0) +
#   geom_abline(slope = 1, intercept = 0) +
#   geom_point(size = 3) +
#   geom_smooth(method = "lm", formula = y ~ x, se = FALSE) +
#   geom_errorbarh(
#     aes(xmin = d14c_l.bulk, 
#         xmax = d14c_u.bulk,
#         color = pm), 
#     height = 1.5) +
#   geom_errorbar(
#     aes(ymin = d14c_l.inc, 
#         ymax = d14c_u.inc,
#         color = pm), 
#     width = 1.5) +
#   scale_color_manual(name = "Parent material",
#                      values = c("andesite" = "blue",
#                                 "basalt" = "red",
#                                 "granite" = "darkgray")) +
#   scale_shape_manual(name = "Ecosystem",
#                      values = c("warm" = 0,
#                                 "cool" = 1,
#                                 "cold" = 2)) +
#   coord_fixed(xlim = c(-100, 200), ylim = c(-100, 200)) +
#   xlab(expression('Bulk soil '*Delta*''^14*'C (‰)')) +
#   ylab(expression('Incubation '*Delta*''^14*'C (‰)')) +
#   facet_grid(rows = vars(depth)) +
#   theme_bw() +
#   theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Regression of 2019 bulk soil incubations and corresponding bulk soil $\Delta$^14^C**

>*Caption:* Regressions of $\Delta$^14^C of bulk soil and respired CO~2~ by depth for each site in 2019. Error bars show one standard deviation for bulk soil, points show mean of three replicate profiles for bulk soils and single observations for respired CO~2~.

## Time series: $\Delta$^14^C by depth (as measured)
```{r plot-timeseries-meas-depths}
# combine '01, '09, '19 data
sra.01.09.19.raw <- rbind(bind_rows(sra.2001.sum.ls),
                          bind_rows(sra.2019.sum.ls))
sra.2009.ls <- split(ras18.lyr, ras18.lyr$PMeco)
sra.2009.df <- bind_rows(sra.2009.ls)
colnames(sra.2009.df)[which(colnames(sra.2009.df) == "lyr_14c")] <- "d14c"
sra.2009.df <- sra.2009.df[ , which(names(sra.2009.df) %in% names(sra.01.09.19.raw))]
sra.2009.df <- cbind(sra.2009.df, 
                     fm = NA,
                     d14c_sd = NA,
                     fm_sd = NA,
                     d14c_u = NA,
                     d14c_l = NA)
sra.01.09.19.raw <- rbind(sra.01.09.19.raw, sra.2009.df)
sra.01.09.19.raw$Year <- factor(c(rep(2001, nrow(bind_rows(sra.2001.sum.ls))),
                                  rep(2019, nrow(bind_rows(sra.2019.sum.ls))),
                                  rep(2009, nrow(sra.2009.df))),
                                levels = c("2001", "2009", "2019"))

# plot
# w/ ribbons
# sra.01.09.19.raw %>%
#   mutate(PMeco_year = paste0(PMeco, Year),
#          eco = factor(ifelse(ECO == "pp", "warm",
#                       ifelse(ECO == "wf", "cool", "cold")),
#                       levels = c("warm", "cool", "cold")),
#          d14c_u = d14c + d14c_sd,
#          d14c_l = d14c - d14c_sd,
#          pm = ifelse(PM == "AN", "andesite",
#                      ifelse(PM == "BS", "basalt", "granite"))) %>%
#   ggplot(., aes(d14c, lyr_bot, group = PMeco_year)) +
#   geom_vline(xintercept = 0) +
#   geom_hline(yintercept = 0) +
#   geom_ribbon(aes(xmin = d14c_l, xmax = d14c_u, fill = pm, alpha = Year, group = PMeco_year),
#               color = NA, show.legend = FALSE) +
#   geom_point(aes(fill = pm, color = pm, shape = eco, alpha = Year), size = 2) +
#   geom_point(aes(shape = eco), color = "black", size = 3) +
#   geom_path(aes(linetype = Year, color = pm), size = 0.7) +
#   scale_y_reverse() +
#   scale_color_manual(name = "Parent material",
#                      values = c("andesite" = "blue", 
#                                 "basalt" = "red", 
#                                 "granite" = "darkgray")) +
#   scale_fill_manual(name = "Parent material",
#                     values = c("andesite" = "blue", 
#                                "basalt" = "red", 
#                                "granite" = "darkgray")) +
#   scale_shape_manual(name = "Ecosystem",
#                      values = c("warm" = 22, 
#                                 "cool" = 21, 
#                                 "cold" = 24)) +
#   scale_alpha_manual(values = c("2001" = .6,
#                                 "2009" = 0.4,
#                                 "2019" = 0.2)) +
#   facet_grid(rows = vars(eco), cols = vars(pm)) +
#   xlab(expression(Delta*''^14*'C (‰)')) +
#   ylab("Depth (cm)") +
#   theme_bw() +
#   theme(panel.grid.minor = element_blank())

# litter
sra.2019.inc.L.df <- data.frame(
  sra.2019.inc_L.df %>%
    group_by(Year, PM, eco, lyr_bot, PMeco) %>%
    summarize(across(.cols = d14c, 
                     .fns = list(mean = mean, min = min, max = max))) %>%
    rename(year = Year, d14c = d14c_mean) %>%
    mutate(eco = factor(ifelse(eco == "pp", "warm",
                      ifelse(eco == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
           pm = ifelse(PM == "AN", "andesite",
                       ifelse(PM == "BS", "basalt", "granite"))))
# for plotting below
sra.2019.inc.L.df2 <- sra.2019.inc.L.df %>%
  rename(d14c_l = d14c_min,
         d14c_u = d14c_max) %>%
  mutate(PMeco_year = paste0(PMeco, year))

# with error bars, all depths
sra.01.09.19.raw %>%
  mutate(PMeco_year = paste0(PMeco, Year),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  ggplot(., aes(d14c, lyr_bot, group = PMeco_year)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point(aes(fill = pm, color = pm, shape = eco, alpha = Year), size = 3.5) +
  geom_point(data = sra.2019.inc.L.df2, 
             aes(d14c, lyr_bot, color = pm, shape = eco), shape = 8, size = 3.5, show.legend = FALSE) +
  geom_path(aes(linetype = Year, color = pm), size = 0.7) +
  geom_errorbarh(
    aes(xmin = d14c_l,
        xmax = d14c_u,
        color = pm,
        alpha = Year),
    height = 1.5) +
  scale_y_reverse() +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue",
                                "basalt" = "red",
                                "granite" = "darkgray")) +
  scale_fill_manual(name = "Parent material",
                    values = c("andesite" = "blue",
                               "basalt" = "red",
                               "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("warm" = 15,
                                "cool" = 16,
                                "cold" = 17)) +
  scale_alpha_manual(values = c("2001" = 1,
                                "2009" = 0.6,
                                "2019" = 0.3)) +
  scale_linetype_manual(values = c("2001" = 1,
                                   "2009" = 2,
                                   "2019" = 3)) +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())

# just topsoil, w/ error bars
fig.n <- fig.n + 1
sra.01.09.19.raw <- sra.01.09.19.raw[order(sra.01.09.19.raw$lyr_top), ]
sra.01.09.19.raw %>%
  mutate(PMeco_year = paste0(PMeco, Year),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  ggplot(., aes(d14c, lyr_bot, group = PMeco_year)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point(aes(fill = pm, color = pm, shape = eco, alpha = Year), size = 3) +
  geom_path(aes(linetype = Year, color = pm), size = 0.7) +
  geom_errorbarh(
    aes(xmin = d14c_l,
        xmax = d14c_u,
        color = pm,
        alpha = Year),
    height = 1.5) +
  scale_y_reverse(limits = c(41, 0)) +
  scale_x_continuous(limits = c(-160, 190)) +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_fill_manual(name = "Parent material",
                    values = c("andesite" = "blue", 
                               "basalt" = "red", 
                               "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  scale_alpha_manual(values = c("2001" = 1,
                                "2009" = 0.6,
                                "2019" = 0.3)) +
  scale_linetype_manual(values = c("2001" = "solid",
                                   "2009" = "dashed",
                                   "2019" = "dotted")) +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Time series of $\Delta$^14^C by depth, as measured**

>*Caption:* Points show mean of three profile replicates for 2001, 2009, and 2019 samples. Error bars show ± 1 standard deviation of the mean (only a single profile was analyzed in 2009). Stars show litter incubation $\Delta$^14^C-CO~2~ for 2019 samples as a point of reference.

## Spline fitting

Soils collected in both the 2001 and 2009 sampling campaigns were sampled by horizon, but the depth intervals differed between the two sampling years. In 2009, full profiles were excavated for each site, as opposed to the shorter profiles collected in 2001 from the GR and AN sites. Radiocarbon was measured on all three replicate profiles at each site for the 2001 samples, but only for one of the replicate profiles at each site in 2009, e.g. ANpp rep2, etc.

In order to compare the radiocarbon profiles between 2001, 2009, and 2019 we first interpolated both radiocarbon and carbon stock data at 1 cm intervals for each site in the datasets from each year. The carbon-stock-weighted radiocarbon values for any given target depth interval can then be calculated as a simple sum of the product of the carbon weight of each 1 cm increment (relative to the total carbon stock of the target depth interval) and its radiocarbon value. A monotonic cubic spline fit was used for the carbon stock interpolation (Wendt and Hauser 2013), and a mass-preserving spline was used to fit the radiocarbon data (Bishop, T.F.A., McBratney, A.B., Laslett, G.M., (1999) Modelling soil attribute depth functions with equal-area quadratic smoothing splines. Geoderma, 91(1-2): 27-45).

```{r cn-clean, include = FALSE}
elm_results_df <- bind_rows(unlist(elm_results_ls, recursive = FALSE))
# Split IDs
PMeco_rep_depth <- bind_rows(
  lapply(strsplit(elm_results_df$ID, "_"), function(x) { 
    df <-  data.frame(PMeco = x[2],
                      pro_rep = x[3],
                      depth = x[4])
    df$PM <- substr(df$PMeco, 1, 2)
    df$ECO <- substr(df$PMeco, 3, 4)
    return(df)
  })
)
elm_results_df <- cbind(elm_results_df, PMeco_rep_depth)
```

```{r soc-2001, include = FALSE}
# merge soc.2001.ls and sra.2001.ls to add SOC data
sra.2001.ls <- mapply(merge, sra.2001.ls, soc.2001.ls, SIMPLIFY = FALSE)

# calculate cumulative stocks
sra.2001.ls <- lapply(sra.2001.ls, function(df) {
  ls <- split(df, df$pro_name)
  ls <- lapply(ls, function(x) {
    x <- x[order(x$lyr_bot), ] # make sure to order data
    x$lyr_soc_cmtv <- NA
    for(i in seq_along(x$lyr_bot)) {
      if(i == 1) {
        x$lyr_soc_cmtv[i] <- x$lyr_soc_kgm2[i]
      } else {
        x$lyr_soc_cmtv[i] <- x$lyr_soc_kgm2[i] + x$lyr_soc_cmtv[i-1] 
      }
    }
    return(x)
  })
  return(unsplit(ls, df$pro_name))
})
```

```{r spline-fm, include = FALSE}
### spline fit for fm
## bulk (split by pro rep)
# 2001
sra.2001.fm.sp <- lapply(sra.2001.ls, function(df) {
  lapply(split(df, df$pro_name), function(x) {
    depths(x) <- pro_name ~ lyr_top + lyr_bot
    x.mps <- mpspline(x, var.name = "fm")
    x.mps$var.1cm <- x.mps$var.1cm[1:max(x$lyr_bot)]
    return(x.mps)
  })
})
# 2009
sra.2009.fm.sp <- lapply(sra.2009.ls, function(x) {
  depths(x) <- pro_name ~ lyr_top + lyr_bot
  x.mps <- mpspline(x, var.name = "lyr_fraction_modern")
  x.mps$var.1cm <- x.mps$var.1cm[1:max(x$lyr_bot)]
  return(x.mps)
})
# 2019
sra.2019.fm.sp <- lapply(sra.2019.ls, function(df) {
  lapply(split(df, df$pro_name), function(x) {
    depths(x) <- pro_name ~ lyr_top + lyr_bot
    x.mps <- mpspline(x, var.name = "fm")
    x.mps$var.1cm <- x.mps$var.1cm[1:max(x$lyr_bot)]
    return(x.mps)
  })
})

## inc
# need min and max values for spline fits
# 2001
sra.2001.inc.fm.sp <- lapply(sra.2001.inc.sum.ls, function(df) {
    depths(df) <- PMeco ~ lyr_top + lyr_bot
    mean.mps <- mpspline(df, var.name = "fm_mean")
    min.mps <- mpspline(df, var.name = "fm_l")
    max.mps <- mpspline(df, var.name = "fm_u")
    return(list(mean.var.1cm = mean.mps$var.1cm[1:max(df$lyr_bot)],
                min.var.1cm = min.mps$var.1cm[1:max(df$lyr_bot)],
                max.var.1cm = max.mps$var.1cm[1:max(df$lyr_bot)]))
  })
```

```{r spline-bd-soc-19, include = FALSE}
# Need SOC stock data for 2019 samples: use BD from 2009 samples 
# spline fit for bulk density
sra.2009.bd.sp <- lapply(sra.2009.ls, function(x) {
  depths(x) <- pro_name ~ lyr_top + lyr_bot
  x.mps <- mpspline(x, var.name = "lyr_bd_samp")
  x.mps$var.1cm <- x.mps$var.1cm[1:100]
  return(x.mps)
})
sra.2009.bd.sp <- lapply(sra.2009.bd.sp, function(ls) {
  df <- data.frame(ls["var.1cm"])
  ix <- which(is.na(df$var.1cm))
  df$var.1cm[ix] <- df$var.1cm[ix[1]-1]
  return(df)
})

# calculate mean of 1cm BD predictions for each depth increment
bd_pred <- lapply(seq_along(sra.2009.bd.sp), function(i) {
  ls <- split(sra.2019.ls[[i]], sra.2019.ls[[i]]["pro_rep"]) # split each replicate profile
  ls <- lapply(seq_along(ls), function(df) {
    d <- ls[[df]][["lyr_bot"]] # depth intervals
    c <- vector(mode = "list", length = length(d)) # vector for averaging 1 cm bd pred
    for(j in seq_along(d)) {
      if(j == 1) {
        c[[j]] <- mean(sra.2009.bd.sp[[i]][1:d[j], "var.1cm"]) # 1-10
      } else {
        c[[j]] <- mean(sra.2009.bd.sp[[i]][(d[j-1]+1):d[j], "var.1cm"]) # 10 cm increments
      }
    }
    return(unlist(c))
    })
  return(unsplit(ls, sra.2019.ls[[i]]["pro_rep"]))
})

# merge predicted bd values with sra.2019.ls
nms <- names(sra.2019.ls)
sra.2019.ls <- lapply(seq_along(sra.2019.ls), function(df) {
  cbind(sra.2019.ls[[df]], bd = bd_pred[[df]])
})
names(sra.2019.ls) <- nms

# add c conc
sra.2019.ls <- lapply(sra.2019.ls, function(df) {
  df$depth <- paste0(df$lyr_top, "-", df$lyr_bot)
  df <- merge(df, elm_results_df[ , c("PMeco", "pro_rep", "depth", "C", "N")], by = c("PMeco", "depth", "pro_rep"))
  return(df)
})

# calculate stocks  
sra.2019.ls <- lapply(sra.2019.ls, function(df) {
  df$lyr_soc <- df$bd * df$C # units work out to kg_m2 
  return(df)
})
# calculate cmtv stocks
sra.2019.ls <- lapply(sra.2019.ls, function(df) {
  ls <- split(df, df$pro_name)
  ls <- lapply(ls, function(x) {
    x$lyr_soc_cmtv <- NA
    for(i in seq_along(x$lyr_bot)) {
      if(i == 1) {
        x$lyr_soc_cmtv[i] <- x$lyr_soc[i]
      } else {
        x$lyr_soc_cmtv[i] <- x$lyr_soc[i] + x$lyr_soc_cmtv[i-1] 
      }
    }
    return(x)
  })
  return(unsplit(ls, df$pro_name))
})
save(sra.2019.ls, file = "sra.2019.ls.RData")
```

```{r spline-soc, include = FALSE}
# spline fit for carbon stocks (for calc weighted averages)
depth.spline <- function(x) {
  sp <- spline(x, method = "hyman") # fit monotonic cubic spline
  sp.ss <- smooth.spline(sp) # convert to class "spline" with smooth.spline fxn
  std <- seq(0, 100) # in cm (linear beyond last measured depth)
  sp <- predict(sp.ss, std) 
  df <- data.frame(sp)
  colnames(df) <- c("lyr_bot","lyr_soc")
  for(i in seq_along(df$lyr_bot)) {
    if(i == 1) {
      df$lyr_soc[i] <- df$lyr_soc[i]
    } else {
      df$lyr_soc[i] <- df$lyr_soc[i + 1] - df$lyr_soc[i]
    }
  }
  df <- df[-1,]
  return(df[-length(df$lyr_soc), ])
}

## add (0, 0) point for (lyr_bot, lyr_cmtv_stock)
# 2001
sra.2001.sp.ls <- lapply(sra.2001.ls, function(df) {
  ls <- lapply(split(df, df$pro_name), function(x) {
    t0 <- data.frame(matrix(nrow = 1, ncol = ncol(x)))
    xy <- c(which(names(x) == "lyr_bot"), which(names(x) == "lyr_soc_cmtv"))
    t0[ , xy] <- 0
    names(t0) <- names(x)
    t0$pro_name <- unique(x$pro_name)
    return(rbind(t0, x))
  })
  return(bind_rows(ls))
})
sra.2001.sp.ls.avg <- lapply(sra.2001.sum.ls2, function(df) {
  xy <- df[ , c("lyr_bot", "lyr_soc_cmtv")]
  t0 <- data.frame(lyr_bot = 0, lyr_soc_cmtv = 0)
  return(rbind(xy))
})
# 2009
sra.2009.sp.ls <- lapply(sra.2009.ls, function(df) {
  t0 <- data.frame(matrix(nrow = 1, ncol = ncol(df)))
  xy <- c(which(names(df) == "lyr_bot"), which(names(df) == "lyr_soc_cmtv"))
  t0[ , xy] <- 0
  names(t0) <- names(df)
  new <- rbind(t0, df)
  return(new)
})
# 2019
sra.2019.sp.ls <- lapply(sra.2019.ls, function(df) {
  ls <- lapply(split(df, df$pro_name), function(x) {
    t0 <- data.frame(matrix(nrow = 1, ncol = ncol(x)))
    xy <- c(which(names(x) == "lyr_bot"), which(names(x) == "lyr_soc_cmtv"))
    t0[ , xy] <- 0
    names(t0) <- names(x)
    t0$pro_name <- unique(x$pro_name)
    return(rbind(t0, x))
  })
  return(bind_rows(ls))
})

## run spline
# 2001
sra.2001.oc.sp <- lapply(sra.2001.sp.ls, function(df) {
  lapply(split(df, df$pro_name), function(x) {
    depth.spline(x[, c("lyr_bot", "lyr_soc_cmtv")])
  })
})
sra.2001.oc.sp.avg <- lapply(sra.2001.sp.ls.avg, function(df) {
  depth.spline(df)
})
# 2009
sra.2009.oc.sp <- lapply(sra.2009.sp.ls, function(x) {
  depth.spline(x[, c("lyr_bot", "lyr_soc_cmtv")])
})
# 2019
sra.2019.oc.sp <- lapply(sra.2019.sp.ls, function(df) {
  lapply(split(df, df$pro_name), function(x) {
    depth.spline(x[, c("lyr_bot", "lyr_soc_cmtv")])
  })
})
```

```{r cwt-d14c-01, include = FALSE}
## calculate stock weights
## 2001 depths
# order '01 data
sra.2001.sum.ls <- lapply(sra.2001.sum.ls, function(df) df[order(df$lyr_bot), ])
# 2009
cwt.01.09 <- lapply(seq_along(sra.2009.oc.sp), function(i) {
  d <- sra.2001.sum.ls[[i]][["lyr_bot"]] # map onto '01 depths
  c <- vector(mode = "list", length = length(d))
  for(j in seq_along(d)) {
    if(j == 1) {
      c[[j]] <- sra.2009.oc.sp[[i]][1:d[j], "lyr_soc"]
    } else {
      c[[j]] <- sra.2009.oc.sp[[i]][(d[j-1]+1):d[j], "lyr_soc"] 
    }
  }
  return(unlist(lapply(c, function(x) x/sum(x)))) # return weights
})
names(cwt.01.09) <- names(sra.2009.oc.sp)
# 2019 (second list level from profile reps)
cwt.01.19 <- lapply(seq_along(sra.2019.oc.sp), function(i) {
  lapply(sra.2019.oc.sp[[i]], function(df) {
    d <- sra.2001.sum.ls[[i]][["lyr_bot"]] # map onto '01 depths
    c <- vector(mode = "list", length = length(d))
    for(j in seq_along(d)) {
      if(j == 1) {
        c[[j]] <- df[1:d[j], "lyr_soc"]
      } else {
        c[[j]] <- df[(d[j-1]+1):d[j], "lyr_soc"] 
      }
    }
    return(unlist(lapply(c, function(x) x/sum(x))))  # return weights
  })
})
names(cwt.01.19) <- names(sra.2019.oc.sp)


## calculate fm_wts
## '01 depths
# 2019
fm.wt.01.19 <- lapply(seq_along(cwt.01.19), function(i) {
  lapply(seq_along(cwt.01.19[[i]]), function(j) {
    df <- data.frame(cwt = cwt.01.19[[i]][[j]])
    df$fm <- sra.2019.fm.sp[[i]][[j]][["var.1cm"]][1:length(cwt.01.19[[i]][[j]])]
    df$fm_wt <- df$fm * df$cwt
  return(df)
  })
}) 
names(fm.wt.01.19) <- names(cwt.01.19)
# 2009
fm.wt.01.09 <- lapply(seq_along(cwt.01.09), function(i) {
  df <- data.frame(cwt = cwt.01.09[[i]])
  df$fm <- sra.2009.fm.sp[[i]][["var.1cm"]][1:length(cwt.01.09[[i]])]
  df$fm_wt <- df$fm * df$cwt
  return(df)
})
names(fm.wt.01.09) <- names(cwt.01.09)


## calculate weighted average of fm for each interval
## '01 depths
# 2009
sra.01.09.ls <- lapply(seq_along(sra.2001.sum.ls), function(i) {
  d <- sra.2001.sum.ls[[i]][["lyr_bot"]]
  f <- vector(mode = "list", length = length(d))
  for(j in seq_along(d)) {
    if(j == 1) {
      f[[j]] <- sum(fm.wt.01.09[[i]][1:d[j], "fm_wt"])
    } else {
      f[[j]] <- sum(fm.wt.01.09[[i]][(d[j-1]+1):d[j], "fm_wt"])
    }
  }
  return(cbind(sra.2001.sum.ls[[i]], fm_09 = unlist(f)))
})
names(sra.01.09.ls) <- names(fm.wt.01.09)
# 2019
sra.01.19.ls <- fm.wt.01.19 # initialize list with fm wt structure
sra.01.19.ls <- lapply(seq_along(sra.2001.sum.ls), function(i) {
  sra.01.19.ls[[i]] <- lapply(seq_along(fm.wt.01.19[[i]]), function(x) {
    d <- sra.2001.sum.ls[[i]][["lyr_bot"]]
    f <- vector(mode = "list", length = length(d))
    for(j in seq_along(d)) {
      if(j == 1) {
        f[[j]] <- sum(fm.wt.01.19[[i]][[x]][1:d[j], "fm_wt"])
      } else {
        f[[j]] <- sum(fm.wt.01.19[[i]][[x]][(d[j-1]+1):d[j], "fm_wt"])
      }
    }
    return(unlist(f)) 
  })
  fm <- lapply(seq_along(sra.01.19.ls[[i]][[1]]), function(z) {
    data.frame(fm_19_mean = mean(sapply(sra.01.19.ls[[i]], "[", z), na.rm = TRUE),
               fm_19_sd = sd(sapply(sra.01.19.ls[[i]], "[", z), na.rm = TRUE))
    })
  fm <- bind_rows(fm)
  return(fm)
})
sra.01.09.19.ls <- lapply(seq_along(sra.01.09.ls), function(i) {
  data.frame(sra.01.09.ls[[i]], sra.01.19.ls[[i]])
})
names(sra.01.09.19.ls) <- names(sra.01.09.ls)

## create tidy combined '01, '09, '19 data frame
nms <- c("PM", "ECO", "PMeco", "lyr_top", "lyr_bot", "fm", "fm_sd")
sra.01.09.19.df <- bind_rows(sra.01.09.19.ls)
sra.01.09.19 <- sra.01.09.19.df[, nms]
sra.01.09.19 <- rbind(cbind(sra.01.09.19, Year = as.character(2001)),
                      data.frame(sra.01.09.19[, nms[1:5]],
                                 fm = sra.01.09.19.df$fm_09,
                                 fm_sd = NA,
                                 Year = as.character(2009)),
                      data.frame(sra.01.09.19[, nms[1:5]],
                                 fm = sra.01.09.19.df$fm_19_mean,
                                 fm_sd = sra.01.09.19.df$fm_19_sd,
                                 Year = as.character(2019)))

# calc d14c from fm
sra.01.09.19$d14c <- calc_14c(sra.01.09.19$fm, as.numeric(as.character(sra.01.09.19$Year)))
sra.01.09.19$d14c_sd <- abs(sra.01.09.19$d14c - calc_14c(sra.01.09.19$fm + sra.01.09.19$fm_sd, as.numeric(as.character(sra.01.09.19$Year))))
```

```{r cwt-d14c-19, include = FALSE}
## calculate stock weights
## 2019 depths
# 2001
cwt.19.01 <- lapply(seq_along(sra.2001.oc.sp), function(i) {
  lapply(sra.2001.oc.sp[[i]], function(df) {
    d <- sra.2019.sum.ls[[i]][["lyr_bot"]]
    c <- vector(mode = "list", length = length(d))
    for(j in seq_along(d)) {
      if(j == 1) {
        c[[j]] <- df[1:d[j], "lyr_soc"]
      } else {
        c[[j]] <- df[(d[j-1]+1):d[j], "lyr_soc"] 
      }
    }
    return(unlist(lapply(c, function(x) x/sum(x))))
  })
})
names(cwt.19.01) <- names(sra.2001.oc.sp)
# 2001 mean
cwt.19.01.avg <- lapply(seq_along(sra.2001.oc.sp.avg), function(i) {
    d <- sra.2019.sum.ls[[i]][["lyr_bot"]]
    c <- vector(mode = "list", length = length(d))
    for(j in seq_along(d)) {
      if(j == 1) {
        c[[j]] <- sra.2001.oc.sp.avg[[i]][1:d[j], "lyr_soc"]
      } else {
        c[[j]] <- sra.2001.oc.sp.avg[[i]][(d[j-1]+1):d[j], "lyr_soc"] 
      }
    }
    return(unlist(lapply(c, function(x) x/sum(x))))
})
names(cwt.19.01.avg) <- names(sra.2001.oc.sp)

# 2009
cwt.19.09 <- lapply(seq_along(sra.2009.oc.sp), function(i) {
  d <- sra.2019.sum.ls[[i]][["lyr_bot"]]
  c <- vector(mode = "list", length = length(d))
  for(j in seq_along(d)) {
    if(j == 1) {
      c[[j]] <- sra.2009.oc.sp[[i]][1:d[j], "lyr_soc"]
    } else {
      c[[j]] <- sra.2009.oc.sp[[i]][(d[j-1]+1):d[j], "lyr_soc"] 
    }
  }
  return(unlist(lapply(c, function(x) x/sum(x))))
})
names(cwt.19.09) <- names(sra.2009.oc.sp)

## calculate fm_wts
## '19 depths
## bulk
# 2001
fm.wt.19.01 <- lapply(seq_along(cwt.19.01), function(i) {
  lapply(seq_along(cwt.19.01[[i]]), function(j) {
    df <- data.frame(cwt = cwt.19.01[[i]][[j]])
    df$fm <- sra.2001.fm.sp[[i]][[j]][["var.1cm"]][1:length(cwt.19.01[[i]][[j]])]
    # linear extrapolation for filling 20-30cm fm data
    fm_1_30 <- df$fm[1:30] # 0-30cm fm
    if(length(which(is.na(fm_1_30))) > 0) {
     ix <- which(is.na(fm_1_30))
     ix.min <- min(ix) # first is.na(fm)
     m <- fm_1_30[ix.min-1]-fm_1_30[ix.min-2] # slope at last two measurement points
     for(i in ix.min:30) {
      fm_1_30[i] <- fm_1_30[i - 1] + m 
     }
     df$fm[1:30] <- fm_1_30 
    }
    df$fm_wt <- df$fm * df$cwt
  return(df)
  })
})
names(fm.wt.19.01) <- names(cwt.19.01)
# '01 inc
fm.wt.19.01.inc <- lapply(seq_along(cwt.19.01.avg), function(j) {
  lapply(sra.2001.inc.fm.sp[[j]], function(fm) {
    df <- data.frame(cwt = cwt.19.01.avg[[j]][1:30])
    # linear extrapolation for filling 20-30cm fm data
    if (length(fm) >= 30) {
      fm_1_30 <- fm[1:30] # 0-30cm fm
    } else {
      fm_1_30 <- rep(NA, 30)
      fm_1_30[1:length(fm)] <- fm
      # first is.na(fm)
      ix.min <- min(which(is.na(fm_1_30)))
      # slope at last two measurement points
      m <- fm_1_30[ix.min - 1] - fm_1_30[ix.min - 2]
      for(x in ix.min:30) {
        fm_1_30[x] <- fm_1_30[x - 1] + m
      }
    }
    df$fm[1:30] <- fm_1_30 
    df$fm_wt <- df$fm * df$cwt
    return(df)
  })
})
names(fm.wt.19.01.inc) <- names(cwt.19.01.avg)

# 2009
fm.wt.19.09 <- lapply(seq_along(cwt.19.09), function(i) {
  df <- data.frame(cwt = cwt.19.09[[i]])
  df$fm <- sra.2009.fm.sp[[i]][["var.1cm"]][1:length(cwt.19.09[[i]])]
  df$fm_wt <- df$fm * df$cwt
  return(df)
})
names(fm.wt.19.09) <- names(cwt.19.09)

## calculate weighted average of fm for each interval
## '19 depths
# 2001
# calculate weighted spline values for each profile rep
sra.19.01.rep.ls <- fm.wt.19.01
sra.19.01.rep.ls <- lapply(seq_along(sra.2019.sum.ls), function(i) {
  sra.19.01.rep.ls[[i]] <- lapply(seq_along(fm.wt.19.01[[i]]), function(x) {
    d <- sra.2019.sum.ls[[i]][["lyr_bot"]]
    f <- vector(mode = "list", length = length(d))
    for(j in seq_along(d)) {
      if(j == 1) {
        f[[j]] <- sum(fm.wt.19.01[[i]][[x]][1:d[j], "fm_wt"])
      } else {
        f[[j]] <- sum(fm.wt.19.01[[i]][[x]][(d[j-1]+1):d[j], "fm_wt"])
      }
    }
    return(unlist(f)) 
  })})
sra.19.01.rep.ls <- lapply(seq_along(sra.19.01.rep.ls), function(i) {
  names(sra.19.01.rep.ls[[i]]) <- names(cwt.19.01[[i]])
  return(sra.19.01.rep.ls[[i]])
})
names(sra.19.01.rep.ls) <- names(fm.wt.19.01)
save(sra.19.01.rep.ls, file = "sra.19.01.rep.ls.RData")

# average reps
sra.19.01.ls <- lapply(seq_along(sra.2019.sum.ls), function(i) {
  fm <- lapply(seq_along(sra.19.01.rep.ls[[i]][[1]]), function(z) {
    data.frame(fm_01_mean = mean(sapply(sra.19.01.rep.ls[[i]], "[", z), na.rm = TRUE),
               fm_01_sd = sd(sapply(sra.19.01.rep.ls[[i]], "[", z), na.rm = TRUE))
    })
  return(bind_rows(fm))
})
names(sra.19.01.ls) <- names(fm.wt.19.01)

## '01 inc
sra.19.01.inc.ls <- lapply(fm.wt.19.01.inc, function(ls) {
  lapply(ls, function(df) {
    d <- c(10, 20, 30)
    f <- vector(mode = "list", length = length(d))
    for(j in seq_along(d)) {
      if(j == 1) {
        f[[j]] <- sum(df[1:d[j], "fm_wt"])
      } else {
        f[[j]] <- sum(df[(d[j-1]+1):d[j], "fm_wt"])
      }
    }
    return(unlist(f)) 
  })})

# 2009
sra.19.09.ls <- lapply(seq_along(sra.2019.sum.ls), function(i) {
  d <- sra.2019.sum.ls[[i]][["lyr_bot"]]
  f <- vector(mode = "list", length = length(d))
  for(j in seq_along(d)) {
    if(j == 1) {
      f[[j]] <- sum(fm.wt.19.09[[i]][1:d[j], "fm_wt"])
    } else {
      f[[j]] <- sum(fm.wt.19.09[[i]][(d[j-1]+1):d[j], "fm_wt"])
    }
  }
  return(cbind(sra.2019.sum.ls[[i]], fm_09 = unlist(f)))
})
names(sra.19.09.ls) <- names(sra.19.01.ls)

# combine
sra.19.01.09.ls <- lapply(seq_along(sra.19.01.ls), function(i) {
  data.frame(sra.19.01.ls[[i]], sra.19.09.ls[[i]])
})
names(sra.19.01.09.ls) <- names(sra.19.01.ls)

## create tidy combined '01, '09, '19 data frame
sra.19.01.09.df <- bind_rows(sra.19.01.09.ls)
sra.19.01.09 <- sra.19.01.09.df[, nms]
sra.19.01.09 <- rbind(data.frame(sra.19.01.09[, nms[1:5]],
                                 fm = sra.19.01.09.df$fm_01_mean,
                                 fm_sd = sra.19.01.09.df$fm_01_sd,
                                 Year = as.character(2001)),
                     data.frame(sra.19.01.09[, nms[1:5]],
                                fm = sra.19.01.09.df$fm_09,
                                fm_sd = NA,
                                Year = as.character(2009)),
                     cbind(sra.19.01.09, Year = as.character(2019)))

# calc d14c from fm
sra.19.01.09$d14c <- calc_14c(sra.19.01.09$fm, as.numeric(as.character(sra.19.01.09$Year)))
sra.19.01.09$d14c_sd <- abs(sra.19.01.09$d14c - calc_14c(sra.19.01.09$fm + sra.19.01.09$fm_sd, as.numeric(as.character(sra.19.01.09$Year))))
save(sra.19.01.09, file = "sra.19.01.09.RData")
```

```{r plot-01-09-19-14c-profiles}
fig.n <- fig.n + 1
sra.01.09.19 %>%
  mutate(PMeco_year = paste0(PMeco, Year),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  # filter(Year != "2009") %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = eco, linetype = Year, group = PMeco_year)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point(aes(alpha = Year), size = 3) +
  geom_path(aes(linetype = Year)) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  scale_y_reverse() +
  scale_x_continuous() +    
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  scale_alpha_manual(values = c("2001" = 1,
                                "2009" = 0.6,
                                "2019" = 0.3)) +
  scale_linetype_manual(values = c("2001" = "solid",
                                 "2009" = "dashed",
                                 "2019" = "dotted")) +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Time series of bulk soil $\Delta$^14^C by 2001 depths (2001, 2009, 2019 samples)**

>*Caption:* Points for 2001 samples show the mean $\Delta$^14^C values at the measured depths. Points for 2009 and 2019 samples are spline-fitted estimates of $\Delta$^14^C predicted for the same depth intervals as measured in 2001. Error bars show ± 1 standard deviation of the mean of three replicate profiles for 2001 and 2019 samples (only a single profile was analyzed in 2009). 

```{r plot-19-01-09-14c-profiles}
fig.n <- fig.n + 1
sra.19.01.09 %>%
  mutate(PMeco_year = paste0(PMeco, Year),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = eco, linetype = Year, group = PMeco_year)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point(aes(alpha = Year), size = 3) +
  geom_path(aes(linetype = Year)) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  # scale_y_reverse(limits = c(30, 0)) +
  scale_y_reverse() +
  scale_x_continuous() +    
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  scale_alpha_manual(values = c("2001" = 1,
                                "2009" = 0.6,
                                "2019" = 0.3)) +
  scale_linetype_manual(values = c("2001" = "solid",
                                   "2009" = "dashed",
                                   "2019" = "dotted")) +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Time series of bulk soil $\Delta$^14^C by depth (splined to 2019 depths)**

>*Caption:* Points for 2019 samples show the mean $\Delta$^14^C values at the measured depths. Points for 2001 and 2009 samples are spline-fitted estimates of $\Delta$^14^C predicted for the same depth intervals as measured in 2019. Error bars show ± 1 standard deviation of the mean of three replicate profiles for 2001 and 2019 samples (only a single profile was analyzed in 2009). 
>*NB: Only two depth intervals were measured at the cool and cold andesite sites (max depth of 27 and 28 cm, respectively), so linear extrapolation (using the slope of the last 1cm spline-fitted depth increment) was used to extend the profiles to 30 cm.*

```{r plot-by-depth-14C-timeseries}
# plot individual depths
fig.n <- fig.n + 1

# Atm
atm.14c <- data.frame(year = Datm[Datm$Date > 2000, "Date"],
                      d14c = Datm[Datm$Date > 2000, "NHc14"])
save(atm.14c, file = "atm.14c.RData")

# bulk 14C over time for 0-10, 10-20, 20-30 w/ atm
sra.19.01.09 %>%
  filter(lyr_bot < 31) %>%
  mutate(PMeco_depth = paste0(PMeco, lyr_bot),
         depth = factor(lyr_bot),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite")),
         year = as.numeric(as.character(Year))) %>%
  ggplot(., aes(year, d14c)) +
  geom_path(data = atm.14c) +
  geom_point(aes(color = pm, shape = eco), size = 3) +
  geom_path(aes(color = pm, group = PMeco_depth, linetype = depth), alpha = 0.3) +
  geom_errorbar(
    aes(ymin = d14c_l, 
        ymax = d14c_u,
        color = pm), 
    width = .5) +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  scale_linetype_manual(name = "Depth (cm)",
                        labels = c("10" = "0-10",
                                   "20" = "10-20",
                                   "30" = "20-30"),
                        values = c("10" = 1,
                                   "20" = 2,
                                   "30" = 3)) +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  ylab(expression(Delta*''^14*'C (‰)')) +
  xlab("Year") +
  theme_bw() +
  theme(panel.grid = element_blank())

### incubation
## 2019
sra.2019.inc.df <- bind_rows(lapply(sra.2019.inc.ls, function(df) {
  data.frame(df %>%
               group_by(Year, PM, ECO, lyr_bot, PMeco) %>%
               summarize(
                 across(.cols = d14c, 
                        .fns = list(mean = mean, min = min, max = max))) %>%
               rename(year = Year, d14c = d14c_mean))
}))
## 2001
sra.19.01.inc.df <- bind_rows(lapply(seq_along(sra.19.01.inc.ls), function(i) {
  PMeco <- names(sra.19.01.inc.ls)[i]
  d14c.ls <- lapply(sra.19.01.inc.ls[[i]], calc_14c, obs_date_y = 2001)
  df <- data.frame(d14c = d14c.ls[[1]],
                   d14c_min = d14c.ls[[2]],
                   d14c_max = d14c.ls[[3]],
                   lyr_bot = c(10, 20, 30),
                   PMeco = PMeco,
                   PM = substr(PMeco, 1, 2),
                   ECO = substr(PMeco, 3, 4),
                   year = 2001)
  return(df)
}))
sra.19.01.inc <- rbind(sra.19.01.inc.df, sra.2019.inc.df)

# plot
sra.19.01.inc %>%
  mutate(PMeco_depth = paste0(PMeco, lyr_bot),
         depth = factor(lyr_bot),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  ggplot(., aes(year, d14c)) +
  geom_path(data = atm.14c) +
  geom_point(aes(color = eco, shape = eco), size = 3) +
  geom_point(data = sra.2019.inc.L.df, aes(color = eco), shape = 8, size = 3, show.legend = FALSE) +
  geom_path(aes(color = eco, group = PMeco), alpha = 0.3) +
  geom_errorbar(
    aes(ymin = d14c_min, 
        ymax = d14c_max,
        color = eco), 
    width = .5) +
  geom_errorbar(
    data = sra.2019.inc.L.df,
    aes(ymin = d14c_min, 
        ymax = d14c_max,
        color = eco), 
    width = .5) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  scale_y_continuous(limits = c(-40, 170)) +
  facet_grid(rows = vars(pm), cols = vars(depth)) +
  ylab(expression(Delta*''^14*'C (‰)')) +
  xlab("Year") +
  theme_bw() +
  theme(panel.grid = element_blank())

# plot inc and bulk together, by depth
sra.ts.all <- sra.19.01.09 %>%
  filter(lyr_bot < 31) %>%
  select(Year, PM, ECO, PMeco, lyr_bot, d14c, d14c_sd) %>%
  mutate(Type = "bulk",
         d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         year = as.numeric(as.character(Year))) %>%
  select(-d14c_sd) %>%
  bind_rows(.,
            sra.19.01.inc %>%
              select(year, PM, ECO, PMeco, lyr_bot, d14c, d14c_min, d14c_max) %>%
              rename(d14c_l = d14c_min,
                     d14c_u = d14c_max) %>%
              mutate(Type = "inc")
  ) %>%
  mutate(depth = factor(lyr_bot),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite")),
         ecoType = paste0(eco, " (", Type, ")"))

# Plot by depth
plot.ts.fx <- function(df) {
  df %>%
    filter(d14c > -200) %>%
    filter(year != 2009) %>%
    ggplot(., aes(year, d14c)) +
    geom_path(data = atm.14c) +
    geom_point(aes(color = pm, shape = ecoType), size = 3) +
    geom_path(aes(color = pm, linetype = Type), alpha = 0.3) +
    geom_errorbar(
      aes(ymin = d14c_l, 
          ymax = d14c_u,
          color = pm), 
      width = .5) +
    scale_color_manual(name = "Parent material",
                       values = c("andesite" = "blue", 
                                  "basalt" = "red", 
                                  "granite" = "darkgray")) +
    scale_shape_manual(name = "Ecosystem (type)",
                       values = c("warm (inc)" = 0,
                                  "cool (inc)" = 1,
                                  "cold (inc)" = 2,
                                  "warm (bulk)" = 15,
                                  "cool (bulk)" = 16,
                                  "cold (bulk)" = 17)) +
    facet_grid(rows = vars(eco), cols = vars(pm)) +
    ylab(expression(Delta*''^14*'C (‰)')) +
    xlab("Year") +
    theme_bw() +
    theme(panel.grid = element_blank())
}

# plots
lapply(split(sra.ts.all, sra.ts.all$depth), plot.ts.fx)

# # to save
# for(i in 1:3) ggsave(paste0(i, ".pdf"), lapply(split(sra.ts.all, sra.ts.all$depth), plot.ts.fx)[[i]])
```
>**Fig. `r {fig.n}`. Change in $\Delta$^14^C of bulk soil (panel a) and respired CO~2~ (panel b) over time relative to the atmosphere**

>*Caption:* Points for 2019 samples show the mean $\Delta$^14^C values at the measured depths. Points for 2001 and 2009 (bulk only) samples are spline-fitted estimates of $\Delta$^14^C predicted for the same depth intervals as measured in 2019. Error bars for bulk samples in panel (a) show ± 1 standard deviation of the mean of three replicate profiles for 2001 and 2019 samples (only a single profile was analyzed in 2009); error bars for incubation samples in panel (b) show the values of the two reps, while the point represents the mean. 
>*NB: Only two depth intervals were measured at the cool and cold andesite sites (max depth of 27 and 28 cm, respectively), so linear extrapolation (using the slope of the last 1cm spline-fitted depth increment) was used to extend the profiles to 30 cm.*

```{r ts-stats}
# function for Tukey HSD tables
tukey.table.fx <- function(x, year, type, var) {
  depth <- paste0(unique(x$lyr_bot) - 10, "-", unique(x$lyr_bot), " cm")
  if (type == "inc") {
    x <- x[x$d14c > -200, c("d14c", var)]
  } 
  return(
    TukeyHSD(aov(reformulate(var, "d14c"), x))[var] %>%
    data.frame(.) %>%
    mutate(Pairs = rownames(.)) %>%
    mutate(across(where(is.numeric), round, 3)) %>%
    gt() %>%
    tab_header(
      title = depth,
      subtitle = paste(year, type, var)
    ))
}

### 2001
## bulk
sra.2001.bulk.df <- bind_rows(
  lapply(sra.19.01.rep.ls, function(ls) {
    ls <- lapply(ls, function(x) x[complete.cases(x)])
    d14c <- calc_14c(unlist(ls), 2001)
    df <- data.frame(d14c = d14c,
                     lyr_bot = rep(c(10, 20, 30), length(d14c) / 3))
    return(df)
  }),
  .id = "PMeco") %>%
  mutate(PM = substr(PMeco, 1, 2),
         ECO = substr(PMeco, 3, 4))
# PM
# lapply(split(sra.2001.bulk.df, sra.2001.bulk.df$lyr_bot), function(x) {
#   summary(lm(d14c ~ PM, x))
# })
lapply(split(sra.2001.bulk.df, sra.2001.bulk.df$lyr_bot), function(x) {
  tukey.table.fx(x, "2001", "bulk", "PM")
})
# ECO
# lapply(split(sra.2001.bulk.df, sra.2001.bulk.df$lyr_bot), function(x) {
#   summary(lm(d14c ~ ECO, x))
# })
lapply(split(sra.2001.bulk.df, sra.2001.bulk.df$lyr_bot), function(x) {
  tukey.table.fx(x, "2001", "bulk", "ECO")
})

## inc
sra.2001.inc.df2 <- cbind(sra.19.01.inc.df[rep(1:nrow(sra.19.01.inc.df), 2), c("PM", "ECO", "lyr_bot")],
                          d14c = c(sra.19.01.inc.df$d14c_min, sra.19.01.inc.df$d14c_max))
save(sra.2001.inc.df2, file = "sra.2001.inc.df2.RData")
# PM
# lapply(split(sra.2001.inc.df2, sra.2001.inc.df2$lyr_bot), function(x) {
#   summary(lm(d14c ~ PM, x[x$d14c > -200, ]))
# })
lapply(split(sra.2001.inc.df2, sra.2001.inc.df2$lyr_bot), function(x) {
  tukey.table.fx(x, "2001", "inc", "PM")
})
# ECO
# lapply(split(sra.2001.inc.df2, sra.2001.inc.df2$lyr_bot), function(x) {
#   summary(lm(d14c ~ ECO, x[x$d14c > -200, ]))
# })
lapply(split(sra.2001.inc.df2, sra.2001.inc.df2$lyr_bot), function(x) {
  tukey.table.fx(x, "2001", "inc", "ECO")
})

### 2019
## bulk
sra.2019.bulk.df <- bind_rows(sra.2019.ls)
# PM
# lapply(split(sra.2019.bulk.df, sra.2019.bulk.df$lyr_bot), function(x) {
#   if (nrow(x) == 27) summary(lm(d14c ~ PM, x[x$d14c > -200, ]))
# })
lapply(split(sra.2019.bulk.df, sra.2019.bulk.df$lyr_bot), function(x) {
  if (nrow(x) == 27) tukey.table.fx(x, "2019", "bulk", "PM")
})
# ECO
# lapply(split(sra.2019.bulk.df, sra.2019.bulk.df$lyr_bot), function(x) {
#   if (nrow(x) == 27) summary(lm(d14c ~ ECO, x[x$d14c > -200, ]))
# })
lapply(split(sra.2019.bulk.df, sra.2019.bulk.df$lyr_bot), function(x) {
  if (nrow(x) == 27) tukey.table.fx(x, "2019", "bulk", "ECO")
})
## inc
sra.2019.inc.df2 <- bind_rows(sra.2019.inc.ls)
save(sra.2019.inc.df2, file = "sra.2019.inc.df2.RData")
# PM
# lapply(split(sra.2019.inc.df2, sra.2019.inc.df2$lyr_bot), function(x) {
#   summary(lm(d14c ~ PM, x[x$d14c > -200, ]))
# })
lapply(split(sra.2019.inc.df2, sra.2019.inc.df2$lyr_bot), function(x) {
  tukey.table.fx(x, "2019", "inc", "PM")
})
# ECO
# lapply(split(sra.2019.inc.df2, sra.2019.inc.df2$lyr_bot), function(x) {
#   summary(lm(d14c ~ ECO, x[x$d14c > -200, ]))
# })
lapply(split(sra.2019.inc.df2, sra.2019.inc.df2$lyr_bot), function(x) {
  tukey.table.fx(x, "2019", "inc", "ECO")
})

# compare 2001 and 2019
# bulk
sra.01.19.bulk.df <- data.frame(
  rbind(sra.2001.bulk.df, 
        sra.2019.bulk.df[, which(names(sra.2019.bulk.df) %in% names(sra.2001.bulk.df))]),
  year = as.factor(c(rep(2001, nrow(sra.2001.bulk.df)), rep(2019, nrow(sra.2019.bulk.df))))) %>%
  filter(lyr_bot < 31)
sra.01.19.bulk.ls <- split(sra.01.19.bulk.df, sra.01.19.bulk.df$PMeco)
lapply(sra.01.19.bulk.ls, function(df) {
  lapply(split(df, df$lyr_bot), function(x) {
    tukey.table.fx(x, paste0(unique(df$PMeco), " 2001 vs. 2019"), "bulk", "year")
  })
})
# by PM
lapply(split(sra.01.19.bulk.df, sra.01.19.bulk.df$PM), function(df) {
  lapply(split(df, df$lyr_bot), function(x) {
    tukey.table.fx(x, paste0(unique(df$PM), " 2001 vs. 2019"), "bulk", "year")
  })
})
# by ECO
lapply(split(sra.01.19.bulk.df, sra.01.19.bulk.df$ECO), function(df) {
  lapply(split(df, df$lyr_bot), function(x) {
    tukey.table.fx(x, paste0(unique(df$ECO), " 2001 vs. 2019"), "bulk", "year")
  })
})
# inc
sra.01.19.inc.df <- data.frame(
  d14c = c(sra.19.01.inc[ , "d14c_min"],
           sra.19.01.inc[ , "d14c_max"]),
  sra.19.01.inc[ , c("PMeco", "lyr_bot", "PM", "ECO", "year")]) %>%
  mutate(year = as.factor(year))
sra.01.19.inc.ls <- split(sra.01.19.inc.df, sra.01.19.inc.df$PMeco)
lapply(sra.01.19.inc.ls, function(df) {
  lapply(split(df, df$lyr_bot), function(x) {
    tukey.table.fx(x, paste0(unique(df$PMeco), " 2001 vs. 2019"), "inc", "year")
  })
})
lapply(split(sra.01.19.inc.df, sra.01.19.inc.df$PM), function(df) {
  lapply(split(df, df$lyr_bot), function(x) {
    tukey.table.fx(x, paste0(unique(df$PM), " 2001 vs. 2019"), "inc", "year")
  })
})
lapply(split(sra.01.19.inc.df, sra.01.19.inc.df$ECO), function(df) {
  lapply(split(df, df$lyr_bot), function(x) {
    tukey.table.fx(x, paste0(unique(df$ECO), " 2001 vs. 2019"), "inc", "year")
  })
})
```

```{r tukey-plots}
# color palettes for ECO & PM
warm <- "#BF812D"
cool <- "#80CDC1"
cold <- "#01665E"
granite <- "#9daba9"
andesite <- "#382dbf"
basalt <- "#bf382d"

# plot fx
boxplot.fx <- function(df, var, year, type, topsoil = FALSE, subsoil = FALSE) {
  atm <- ifelse(year == "2001", atm.d14.2001, atm.d14.2019)
  if (type == "inc") {
    df <- df[df$d14c > -200, ]
    ylim <- c(-65, 165)
  } else {
    if (topsoil) {
      df <- df[df$lyr_bot < 31, ]
      ylim <- c(-120, 165)
      }
    if (subsoil) {
      df <- df[df$lyr_bot > 31, ]
      ylim <- c(-270, 65)
    }
  }
  if (var == "PM") {
    df %>%
      mutate(pm = factor(ifelse(PM == "GR", "granite",
                                ifelse(PM == "AN", "andesite", "basalt")),
                         levels = c("granite", "andesite", "basalt"))) %>%
      group_by(pm, lyr_bot) %>%
      ggplot(., aes(pm, d14c)) +
      geom_hline(yintercept = atm, linetype = "dotted", alpha = 0.3) +
      geom_hline(yintercept = 0) +
      geom_boxplot(aes(color = pm), lwd = 1) +
      scale_color_manual(values = c("andesite" = andesite,
                                    "basalt" = basalt,
                                    "granite" = granite),
                         guide = "none") +
      scale_y_continuous(limits = ylim) +
      facet_grid(cols = vars(lyr_bot)) +
      ylab(expression(Delta*''^14*'C (‰)')) +
      ggtitle(paste(year, type)) +
      theme_bw() +
      theme(panel.grid = element_blank(),
            text = element_text(size = 14))
  } else {
    df %>%
      mutate(eco = factor(ifelse(ECO == "pp", "warm",
                                 ifelse(ECO == "wf", "cool", "cold")),
                          levels = c("warm", "cool", "cold"))) %>%
      group_by(eco, lyr_bot) %>%
      ggplot(., aes(eco, d14c)) +
      geom_hline(yintercept = atm, linetype = "dotted", alpha = 0.3) +
      geom_hline(yintercept = 0) +
      geom_boxplot(aes(color = eco), lwd = 1) +
      scale_color_manual(values = c("warm" = warm,
                                    "cool" = cool,
                                    "cold" = cold),
                         guide = "none") +
      scale_y_continuous(limits = ylim) +
      facet_grid(cols = vars(lyr_bot)) +
      ylab(expression(Delta*''^14*'C (‰)')) +
      ggtitle(paste(year, type)) +
      theme_bw() +
      theme(panel.grid = element_blank(),
            text = element_text(size = 14))
  }
}

# bulk
boxplot.fx(sra.2001.bulk.df, "PM", "2001", "bulk", topsoil = TRUE)
boxplot.fx(sra.2019.bulk.df, "PM", "2019", "bulk", topsoil = TRUE)
boxplot.fx(sra.2001.bulk.df, "ECO", "2001", "bulk", topsoil = TRUE)
boxplot.fx(sra.2019.bulk.df, "ECO", "2019", "bulk", topsoil = TRUE)
boxplot.fx(sra.2019.bulk.df, "ECO", "2019", "bulk", subsoil = TRUE)
# inc
boxplot.fx(sra.2001.inc.df2, "PM", "2001", "inc")
boxplot.fx(sra.2019.inc.df2, "PM", "2019", "inc")
boxplot.fx(sra.2001.inc.df2, "ECO", "2001", "inc")
boxplot.fx(sra.2019.inc.df2, "ECO", "2019", "inc")
```

```{r delta-delta-plots}
# data, unsummarized
sra.ts.all.raw <- rbind(
  sra.2001.bulk.df[ , names(sra.2001.bulk.df) %in% names(sra.2001.inc.df2)],
  sra.2019.bulk.df[ , names(sra.2019.bulk.df) %in% names(sra.2001.inc.df2)],
  sra.2001.inc.df2,
  sra.2019.inc.df2[ , names(sra.2019.inc.df2) %in% names(sra.2001.inc.df2)]) %>%
  mutate(eco = factor(ifelse(ECO == "pp", "warm",
                             ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = factor(ifelse(PM == "GR", "granite",
                                ifelse(PM == "AN", "andesite", "basalt")),
                         levels = c("granite", "andesite", "basalt")),
         Type = c(rep("bulk", length = nrow(sra.2001.bulk.df)),
                  rep("bulk", length = nrow(sra.2019.bulk.df)),
                  rep("inc", length = nrow(sra.2001.inc.df2)),
                  rep("inc", length = nrow(sra.2019.inc.df2))),
         year = c(rep(2001, length = nrow(sra.2001.bulk.df)),
                  rep(2019, length = nrow(sra.2019.bulk.df)),
                  rep(2001, length = nrow(sra.2001.inc.df2)),
                  rep(2019, length = nrow(sra.2019.inc.df2))))

# plot fx
ts.groupPlot.fx <- function(df, x, y) {
  quo_x <- sym(x)
  quo_y <- sym(y)
  if (x == "pm") {
    var.name <- "Parent material"
    var.values <- c("andesite" = andesite,
                    "basalt" = basalt,
                    "granite" = granite) 
  } else {
    var.name <- "Climate"
    var.values <-  c("warm" = warm,
                     "cool" = cool,
                     "cold" = cold)
  }
  plot.df <- df %>%
    filter(d14c > -200) %>%
    filter(lyr_bot < 31) %>%
    group_by(!! quo_x, lyr_bot, Type, year) %>%
    summarize(across(d14c, list(mean = mean, sd = sd)))
  if (y == "dd14c") {
    plot.df <- plot.df %>%
      mutate(atm = ifelse(year == 2001, atm.d14.2001, atm.d14.2019),
             dd14c = d14c_mean - atm,
             u = d14c_mean + d14c_sd - atm,
             l = d14c_mean - d14c_sd - atm)
    atm.df <- atm.14c
    atm.df$d14c <- 0
    ylab <- expression(Delta*Delta*''^14*'C (‰)') 
    } else {
      plot.df <- plot.df %>%
        mutate(u = d14c_mean + d14c_sd,
               l = d14c_mean - d14c_sd)
      atm.df <- atm.14c
      ylab <- expression(Delta*''^14*'C (‰)') 
    }
    ggplot(plot.df, aes(year, !! quo_y)) +
    geom_path(data = atm.df, aes(year, d14c)) +
    geom_path(aes(color = !! quo_x, linetype = Type), alpha = .5, lwd = 1) +
    geom_point(aes(color = !! quo_x), 
               size = 3, position = position_dodge(width = 1)) +
    geom_errorbar(
      aes(ymin = l,
          ymax = u,
          color = !! quo_x,
          alpha = Type),
      width = 1,
      position = position_dodge(width = 1)) +
    scale_color_manual(name = var.name,
                       values = var.values) +
    scale_fill_manual(name = "±SD",
                      values = var.values) +
    scale_alpha_manual(values = c("bulk" = 1,
                                  "inc" = .5)) +
    facet_grid(cols = vars(lyr_bot)) +
    ylab(ylab) +
    xlab("Year") +
    theme_bw() +
    theme(panel.grid = element_blank())
}
# plot
ts.groupPlot.fx(sra.ts.all.raw, "pm", "dd14c")
ts.groupPlot.fx(sra.ts.all.raw, "eco", "dd14c")
ts.groupPlot.fx(sra.ts.all.raw, "pm", "d14c_mean")
ts.groupPlot.fx(sra.ts.all.raw, "eco", "d14c_mean")
```
## Initial modeling

The goal of this modeling exercise is to see how parent material and climate/ecosystem affect estimates of soil carbon ages and transit times. Bulk soil ^14^C observations from 2001, 2009, and 2019 will be used to constrain the carbon models, as well as observations of ^14^C-CO~2~ from laboratory soil incubations of soils collected in 2001 and 2019. Previous work has indicated that the carbon stocks at these sites is likely at equilibrium, so we will apply the steady-state assumption to the modeling.

### Two-pool models

One pool models have been shown repeatedly to be inadequate for describing soil carbon dynamics. However, as simple models are easier to constrain, we will start with a two-pool parallel and two-series models, as these are the simplest model system beyond the single pool approach. 

The two-pool parallel model requires the following parameters:
* decomposition constants for each pool (*k*~1~, *k*~2~)
* input partitioning coefficient ($\gamma$)
* steady-state carbon stocks (C)
* inputs (I)
* initial values of ^14^C
1
The two-pool series model requires the following parameters:
* decomposition constants for each pool (*k*~1~, *k*~2~)
* transfer coefficient ($\alpha$)
* steady-state carbon stocks (C)
* inputs (I)
* initial values of ^14^C

Decomposition rates (*k*) are related to the amount of ^14^C in a pre-bomb system (fraction modern, *F*) at steady-state by the following equations (cf. Schuur, Druffle, and Trumbore, 2016):
>**Eq. 1**

$$F = \frac{k}{k + \lambda}$$
>**Eq. 2**

$$k = \frac{\lambda \cdot F}{1 - F}$$
>where $\lambda$ is the radioactive decay constant (1/8267).

As the decomposition rates will vary, the initial ^14^C content can be determined dynamically with equation 1.

Carbon stocks are known, while inputs will be estimated and are related to the steady-state conditions by the following equation: 
>**Eq. 3**

$$I = (k_{1} \cdot C_{1}) + (k_{2} \cdot C_{2})$$
>where *C~1~* and *C~2~* are the carbon stocks of the two model pools.

Both stocks and inputs can be scaled to the known value of the total carbon pool once the steady-state parameters (*k~1~*, *k~2~*, and $\gamma$ or $\alpha$) have been determined. Pool sizes are a function of the inputs and input partitioning coefficient at steady-state.

A Monte-Carlo Markov chain approach will be used for parameter estimation in combination with an initial optimization algorithm to determine the best set of initial parameters.

## Workflow

Initial model fitting was performed for both model structures using generous parameter ranges [0, 1] for all three parameters (*k~1~*, *k~2~*, $\gamma$ or $\alpha$). The initial parameter set was found by fitting the models by eye, followed by optimization with the function "modFit" (R package FME), using the Nelder-Mead algorithm. The best set of parameters found by modFit was then used as the input to a Monte Carlo Markov Chain (MCMC), using the function "modMCMC" (R package FME). The number of iterations for the MCMC optimization was set at 5000 intially, with delayed rejection employed to increase efficiency. 

The sum of the mean squared error for the best parameter set was slightly lower for the parallel structure than for the series structure. Additionally, the overall mean error of the residuals was also lower for the parallel structure, moderately so for the bulk C observations but substantially so for the respiration observations (in andesite and granite soils in particular).

However, these initial fits yielded unrealistic parameter estimates for multiple sites, particularly at the lower depths. Additionally, the modFit output showed very high correlation between the parameters for both model structures (slightly higher for the two-pool series model). 

```{r mod-utils}
# k from fraction modern
k <- function (Fm) {
  (Fm * lambda)/(1 - Fm)
}

# d14C from fraction modern 
fm_14c <- function (fm, date) {
  (fm * exp(lambda * (1950 - date)) - 1) * 1000
}

# pre-bomb fraction modern from k (steady-state assumed)
fm <- function (k){
  k/(k + lambda)
}
```

```{r mod-constraints, include = FALSE}
# Indices for each depth increment
ix.10 <- seq(1, 27, 3)
ix.20 <- seq(2, 27, 3)
ix.30 <- seq(3, 27, 3)

## SOC stocks
# use 2019 SOC stocks for steady-state estimates
csoc.19.0_30.df <- bind_rows(
  lapply(sra.2019.sp.ls, function(df) {
    df <- suppressMessages(
      df %>%
        filter(lyr_bot < 31 & lyr_bot > 0) %>%
        select(PMeco, lyr_top, lyr_bot, lyr_soc) %>%
        group_by(PMeco, lyr_top, lyr_bot))
    return(data.frame(df))
  })
)
# convert to 27 element list
csoc.19.0_30.ls <- split(csoc.19.0_30.df, paste0(csoc.19.0_30.df$PMeco, "_", csoc.19.0_30.df$lyr_top, "-", csoc.19.0_30.df$lyr_bot))

# average
csoc.19.0_30 <- lapply(csoc.19.0_30.ls, function(df) {
  data.frame(
    df %>%
      group_by(PMeco, lyr_top, lyr_bot) %>%
      summarize(lyr_soc = mean(lyr_soc)))
})

# make into obs data frame for mod.cost fx
obs.cStock <- lapply(csoc.19.0_30.ls, function(df) {
  return(data.frame(time = rep(c(2001.5, 2009.5, 2019.5), each = 3), cStock = rep(df$lyr_soc, 3)))
})

## Inputs
# initial inputs will be set at 4% of the layer carbon stocks (arbitrary)
in.i <- lapply(csoc.19.0_30, function(x) .04 * x$lyr_soc)
# Inputs will be adjusted based on the fitted parameters to match measured stocks later

## 14C constraints
# bulk
obs.bulk.14c <- unlist(
  lapply(seq_along(sra.19.01.rep.ls), function(i) {
  # index along depth intervals 0-10, 10-20, 20-30
  depth.ls <- lapply(seq_along(1:3), function(j) {
    c(unlist(lapply(sra.19.01.rep.ls[[i]], "[[", j)),
      split(split(sra.19.01.09, sra.19.01.09$PMeco)[[i]],
            split(sra.19.01.09, sra.19.01.09$PMeco)[[i]]["lyr_bot"])[[j]][ , "fm"][2],
      unlist(split(sra.2019.ls[[i]], sra.2019.ls[[i]]["lyr_bot"])[[j]]["fm"]))
  })
  reps01 <- length(sra.19.01.rep.ls[[i]])
  depth.dfs <- lapply(depth.ls, function(fm) {
    data.frame(time = c(rep(2001.5, reps01), 2009.5, rep(2019.5, 3)),
               bulkC = Delta14C_from_AbsoluteFractionModern(fm))
  })
  return(depth.dfs)
}), recursive = FALSE)
names(obs.bulk.14c) <- paste0(rep(c("AN", "BS", "GR"), each = 9),
                              rep(c("pp", "rf", "wf"), each = 3, times = 3),
                              rep(c("_0-10", "_10-20", "_20-30"), times = 9))
# respiration
sra.19.01.inc.min.max <- unlist(
  lapply(seq_along(1:3), function(i) {
    lapply(
      mapply(merge,
             lapply(lapply(sra.19.01.inc.ls, "[[", 2), "[[", i), 
             lapply(lapply(sra.19.01.inc.ls, "[[", 3), "[[", i),
             SIMPLIFY = FALSE),
      function(df) {
        data.frame(time = 2001.5, resp = c(df$x, df$y))
      })
  }), recursive = FALSE)
names(sra.19.01.inc.min.max) <- paste0(names(sra.19.01.inc.min.max), 
                                       rep(c("_0-10", "_10-20", "_20-30"), each = 9))
sra.19.01.inc.min.max <- lapply(sra.19.01.inc.min.max, function(df) {
  df$resp <- calc_14c(df$resp, 2001)
  return(df)
})

sra.2019.inc.min.max <- unlist(lapply(sra.2019.inc.ls, function(df) {
  lapply(split(df, df$lyr_bot), function(x) {
    x$resp <- x$d14c
    x$time <- x$Year + .5
    return(x[ , c("time", "resp")])
  })
}), recursive = FALSE)
names(sra.2019.inc.min.max) <- gsub("\\.", "_", names(sra.2019.inc.min.max))
for (i in seq_along(names(sra.2019.inc.min.max))) {
  names(sra.2019.inc.min.max)[i] <- ifelse(grepl("10", names(sra.2019.inc.min.max)[i]),
                                   gsub("10", "0-10", names(sra.2019.inc.min.max)[i]),
                                   ifelse(grepl("20", names(sra.2019.inc.min.max)[i]),
                                          gsub("20", "10-20", names(sra.2019.inc.min.max)[i]), gsub("30", "20-30", names(sra.2019.inc.min.max)[i])))
}

obs.resp.14c <- rbind(bind_rows(sra.19.01.inc.min.max, .id = "id"),
                      bind_rows(sra.2019.inc.min.max, .id = "id"))
obs.resp.14c <- lapply(split(obs.resp.14c, obs.resp.14c$id), function(df) df[ , 2:3])

## input/stock ratio
ras06 <- data.frame(read_excel("../data/external/sra_ras_inc/RespRates_Rasmussen2006.xlsx", sheet = "RatesSum"))
# Obs cost
obs.flx.stock <- lapply(split(ras06, ras06$PMeco), function(x) {
  data.frame(time = 2001.5, # arbitrary
             flx.stock = x[ , "flx_stock_ratio"])
})

# calculate inputs using flx/stock ratio
in.flx.stock <- lapply(seq_along(obs.flx.stock), function(i) {
  obs.flx.stock[[i]][["flx.stock"]]/csoc.19.0_30[ix.10][[i]][["lyr_soc"]]
})

# Flux estimated from Goulden et al. 2012; Tang et al. 2005; Wang et al. 2000; Gaudinski 2000
# fluxes by elevation from GPP reported in Goulden et al. Fig. 5 and approximated
# Rh percentage from Tang et al. 2005 = 0.44 (ann. mean Blodgett); cf. 0.48 Harvard Forest
# A horizon est. 0.55 from Gaudinski
# assuming A = 0-30, assume 0-10 = 50%, 10-20 = 30%, 20-30 = 20% of total A production 
hznA.Rh.kgm2 <- 0.44 * 0.55 * 10^-3
gpp.ls <- c(1800, 1600, 1400)
in.frc.ls <- c(0.5, 0.3, 0.2)

# fx for calculating inputs
in.flx.fx <- function(PMeco_depth) {
  gpp <- ifelse(grepl("pp", PMeco_depth), gpp.ls[1], ifelse(grepl("wf", PMeco_depth), gpp.ls[2], gpp.ls[3]))
  in.frc <- ifelse(grepl("0-10", PMeco_depth), in.frc.ls[1], ifelse(grepl("10-20", PMeco_depth), in.frc.ls[2], in.frc.ls[3]))
  return(gpp * in.frc * hznA.Rh.kgm2)
}

# input list
in.est <- lapply(seq_along(obs.cStock), function(i) {
  PMeco_depth <- names(obs.cStock)[i]
  return(in.flx.fx(PMeco_depth))
})
names(in.est) <- names(obs.cStock)
```

```{r mod-funs-gen}
# index of years for which bulk/resp 14C are known
year.ix <- c(which(Datm$Date == 2001.5),
             which(Datm$Date == 2009.5),
             which(Datm$Date == 2019.5))

# function for saving constraint data in a dataframe for plotting in ggplot'
con.df.fx <- function(PMeco_depth) {
  bulk.df <- obs.bulk.14c[[PMeco_depth]]
  resp.df <- obs.resp.14c[[PMeco_depth]]
  return(
    con.df <- data.frame(pool = c(rep("bulk C", nrow(bulk.df)), rep("respiration", nrow(resp.df))),
                         d14c = c(bulk.df$bulkC, resp.df$resp),
                         Year = c(bulk.df$time, resp.df$time)))
}

# plot function
C14.2p.plot.fx <- function(plot.df, con.df, mod, PMeco_depth) {
  plot.df %>%
  filter(pool == "bulk C" | pool == "respiration" | pool == "atm") %>%
  ggplot(., aes(years, d14C, color = pool)) +
  geom_path() +
  geom_point(data = con.df, aes(Year, d14c, color = pool), size = 3) +
  scale_color_manual(
    name = "Pool",
    values = c("atm" = 8,
               "bulk C" = "black",
               "fast" = "#D81B60",
               "slow" = "#1E88E5",
               "respiration" = "#FFC107")) +
  scale_x_continuous(limits = c(1950, 2022)) +
  ggtitle(paste(PMeco_depth, mod)) +
  xlab("Year") +
  ylab(expression(''*Delta*''^14*'C (‰)')) +
  theme_bw() +
  theme(panel.grid = element_blank())
}
C14.1p.plot.fx <- function(plot.df, con.df, mod, PMeco_depth) {
  ggplot(plot.df, aes(years, d14C, color = pool)) +
  geom_path() +
  geom_point(data = con.df, aes(Year, d14c, color = pool), size = 3) +
  scale_color_manual(
    name = "Pool",
    values = c("atm" = 8,
               "bulk C" = "black",
               "respiration" = "#FFC107")) +
  scale_x_continuous(limits = c(1950, 2022)) +
  ggtitle(paste(PMeco_depth, " 1p bulk + 1p resp")) +
  xlab("Year") +
  ylab(expression(''*Delta*''^14*'C (‰)')) +
  theme_bw() +
  theme(panel.grid = element_blank())
}

# set up model function for optimization
# NOTE: par[3] for 2ps model changed to proportion transferred (no longer = a21)
# therefore, a21 = par[3] * par[1]
modFun_2p <- function(pars, In, lag = 0, pass = TRUE, out = "modFit", mod) {
 
  # intial 14C
  F0_Delta14C <- unlist(lapply(pars[1:2], function(x) Delta14C_from_AbsoluteFractionModern(fm(x))))
  
  # model matrix
  A <- -diag(pars[1:2])
  if (mod == "2ps") {
    a21 <- pars[3] * pars[1]
    A[2, 1] <- a21
  }
    
  # steady-state C stocks
  if (mod == "2pp") {
    ss.cstock <- (-1 * solve(A) %*% c(In * pars[3], In * (1 - pars[3])))
  } else {
    ss.cstock <- (-1 * solve(A) %*% c(In, 0))
  }
  
  # time index
  ix.t <- c((lag + 1):nrow(Datm))
  
  # model
  if (mod == "2pp") {
    mod <- TwopParallelModel14(t = Datm$Date[ix.t],
                               ks = pars[1:2],
                               C0 = c(ss.cstock[1], ss.cstock[2]),
                               F0_Delta14C = F0_Delta14C,
                               In = In,
                               gam = pars[3],
                               inputFc = Datm,
                               lag = lag,
                               pass = pass)
  } else {
    mod <- TwopSeriesModel14(t = Datm$Date[ix.t],
                             ks = pars[1:2],
                             C0 = c(ss.cstock[1], ss.cstock[2]),
                             F0_Delta14C = F0_Delta14C,
                             In = In,
                             a21 = a21,
                             inputFc = Datm,
                             lag = lag,
                             pass = pass)
  }
  
  # get mod values
  C14m <- getF14C(mod)
  C14p <- getF14(mod)
  C14r <- getF14R(mod)
  Ctot <- getC(mod)
  
  if(out == "modFit") {
    # dataframe for modFit fx
    return(data.frame(
      time = Datm$Date[ix.t],
      bulkC = C14m, 
      resp = C14r,
      cStock = rowSums(Ctot)))
  } else {
    # data frame for plotting
    return(data.frame(
      years = rep(Datm$Date[ix.t], 5),
      d14C = c(C14p[,1], 
               C14p[,2], 
               C14m,
               C14r,
               Datm$NHc14[ix.t]),
      pool = rep(c("fast", "slow", "bulk C", "respiration", "atm"), each = nrow(C14p))))
  }
}

# 1p modFun
modFun_1p <- function(pars, In, lag = 0, out = "modFit", mod, pass = TRUE) {
 
  # intial 14C
  F0_Delta14C <- Delta14C_from_AbsoluteFractionModern(fm(pars))
  
  # steady-state C stocks
  ss.cstock <- In/pars
  
  # time index
  ix.t <- c((lag + 1):nrow(Datm))
  
  # model
  mod <- suppressWarnings(
    # warnings suppressed due to the "Fc" warning
    OnepModel14(t = Datm$Date[ix.t],
                     k = pars,
                     C0 = ss.cstock,
                     F0_Delta14C = F0_Delta14C,
                     In = In,
                     inputFc = Datm,
                     lag = lag,
                     pass = pass)
  )
  
  # get mod values
  C14m <- getF14C(mod)
  Ctot <- getC(mod)
  
  if(out == "modFit") {
    # dataframe for modFit fx
    return(data.frame(
      time = Datm$Date[ix.t],
      bulkC = C14m,
      cStock = Ctot))
  } else {
    # data frame for plotting
    return(data.frame(
      years = rep(Datm$Date[ix.t], 1),
      d14C = c(C14m,
               Datm$NHc14[ix.t]),
      pool = rep(c("bulk C", "atm"), each = length(C14m))))
  }
}

# function for trial and error approach to finding initial parameter set
par.fx <- function(pars, In, lag = 0, out = "plot.df", verbose = TRUE, mod, pass = FALSE) {
  
  # model matrix
  A <- -diag(pars[1:2])
  if (mod == "2ps") {
    a21 <- pars[3] * pars[1]
    A[2, 1] <- a21
    # steady-state stocks
    ss.cstock <- round((-1 * solve(A) %*% c(In, 0)), 1)
  } else if (mod == "2pp") {
    # steady-state stocks
    ss.cstock <- round((-1 * solve(A) %*% c(In * pars[3], In * (1 - pars[3]))), 1)
  } else {
    ss.cstock <- In/pars
  }
  
  cstock.sum <- ifelse(length(ss.cstock) == 1, ss.cstock, colSums(ss.cstock))
  
  # print site and steady-state stocks
  if (verbose) {
    cat(paste0(PMeco_depth, "\n"))
    if (mod == "2ps" | mod == "2pp") {
      cat(paste0(ss.cstock[1], " (fast pool)\n", ss.cstock[2], " (slow pool)\n"))
      cat(paste0("slow pool: ", round(ss.cstock[2] / cstock.sum * 100, 0), "%\n")) 
    }
    cat(round(cstock.sum, 1), " (modeled stocks)\n")
    cat(round(csoc.19.0_30[[PMeco_depth]][ , "lyr_soc"], 1), " (measured stocks)\n") 
  }
  if (mod == "1p") {
    return(modFun_1p(pars = pars, In = In, lag = lag, out = out, mod = "1p", pass = pass))
  }
  if (mod == "2pp") {
   return(modFun_2p(pars = pars, In = In, lag = lag, out = out, mod = "2pp", pass = pass)) 
  } else if (mod == "2ps") {
    return(modFun_2p(pars = pars, In = In, lag = lag, out = out, mod = "2ps", pass = pass)) 
  }
}
```

```{r inputs-stocks}
## adjust inputs to match stocks
# function for calculating steady-state SOC stocks
soc.fx <- function(modStr, pars, In, out = "pools") {
  if (modStr == "2pp") {
    cmat <- -1 * solve(-diag(pars[1:2])) %*% c(In * pars[3], In * (1 - pars[3]))
  } else {
    A <- -diag(pars[1:2])
    A[2, 1] <- pars[3] # note that a21 defined as pct transfer * k1
    cmat <- -1 * solve(A) %*% c(In, 0) # In is total input into the system
  }
  if (out == "pools") {
    return(cmat)
  } else {
    return(colSums(cmat))
  }
}

in.fit.fx <- function(modStr, pars, initialIn, SOC) {
  # sequence of possible input values
  if  (SOC < soc.fx(modStr, pars, initialIn, out = "sum")) {
    ins <- seq(.01, 
               initialIn, 
               .01)
    } else {
      ins <- seq(initialIn, 
                 SOC, 
                 .01)
    }
  # modeled stocks
  soc_mod <- lapply(seq_along(ins), function(j) {
    soc.fx(modStr, pars, ins[j], out = "sum")
  })
  ix <- which.min(abs(unlist(soc_mod) - SOC))
  return(ins[ix])
}

# load initial parameter set
load("../data/derived/modFit_pars/pars.i.2pp_2021-03-30.Rdata")
load("../data/derived/modFit_pars/pars.i.2ps_2020-11-16.Rdata")

## inputs for initial par set and measured stocks
# 2pp
in.meas.2pp <- lapply(seq_along(pars.i.2pp[ix.10]), function(i) {
  PMeco_depth <- names(pars.i.2pp[ix.10])[i]
  SOC <- csoc.19.0_30[[PMeco_depth]][ ,"lyr_soc"]
  return(in.fit.fx("2pp", pars.i.2pp[ix.10][[i]], in.i[ix.10][[i]], SOC))
})
names(in.meas.2pp) <- names(pars.i.2pp[ix.10])
# 2ps
in.meas.2ps <- lapply(seq_along(pars.i.2ps[ix.10]), function(i) {
  PMeco_depth <- names(pars.i.2ps[ix.10])[i]
  SOC <- csoc.19.0_30[[PMeco_depth]][ ,"lyr_soc"]
  return(in.fit.fx("2pp", pars.i.2ps[ix.10][[i]], in.i[ix.10][[i]], SOC))
})
names(in.meas.2ps) <- names(pars.i.2ps[ix.10])

# Flux estimated from Goulden et al. 2012; Tang et al. 2005; Wang et al. 2000; Gaudinski 2000
# fluxes by elevation from GPP reported in Goulden et al. Fig. 5 and approximated
# Rh percentage from Tang et al. 2005 = 0.44 (ann. mean Blodgett); cf. 0.48 Harvard Forest
# A horizon est. 0.55 from Gaudinski
# assuming A = 0-30, assume 0-10 = 50%, 10-20 = 30%, 20-30 = 20% of total A production 
hznA.Rh.kgm2 <- 0.44 * 0.55 * 10^-3
gpp.ls <- c(1800, 1600, 1400)
in.frc.ls <- c(0.5, 0.3, 0.2)

# fx for calculating inputs
in.flx.fx <- function(PMeco_depth) {
  gpp <- ifelse(grepl("pp", PMeco_depth), gpp.ls[1], ifelse(grepl("wf", PMeco_depth), gpp.ls[2], gpp.ls[3]))
  in.frc <- ifelse(grepl("0-10", PMeco_depth), in.frc.ls[1], ifelse(grepl("10-20", PMeco_depth), in.frc.ls[2], in.frc.ls[3]))
  return(gpp * in.frc * hznA.Rh.kgm2)
}

# input list
in.est <- lapply(seq_along(pars.i.2pp), function(i) {
  PMeco_depth <- names(pars.i.2pp)[i]
  return(in.flx.fx(PMeco_depth))
})
names(in.est) <- names(pars.i.2pp)
```
## Parameter optimization

Optimizing the parameter set requires imposing costs and optionally constraining the allowable range of values for each parameter. Given that we only have data for three time points, this is a relatively sparse data set for constraining these models. Accordingly, the optimization procedure will benefit from *a priori* constraints of the allowable parameter ranges. For example, since we assume that the system cannot be adequately modeled as a single homogenous reservoir, we will ensure that the optimization procedure cannot collapse the two-pool system into a single pool. This can be mitigated in the two-pool parallel optimization by constraining $\gamma$ (i.e. the percentage of the inputs entering the fast pool) to a range of 50% to 95%. Similarly, for the two-pool series model structure we can constrain the range of the transfer coefficient to be between 0.0 and 0.1, ensuring that some carbon remains in the fast cycling pool.

Additionally, to enforce a relatively fast cycling pool and relatively slower cycling pool, we will loosely constrain the intrinsic decomposition rates as well (both model structures):

*k~1~*: [0.02, 1.00] (50 to 1 year)
*k~2~*: [0.0001, 0.02] (10,000 to 50 years)

Finally, the models will be run to enforce steady-state, i.e. with unvarying carbon stocks. The amount of carbon observed in the system will be used in the cost function in addition to the radiocarbon observations made in 2001, 2009, and 2019. The inputs will be estimated from net ecosystem exchange (NEE) data measured at nearby eddy covariance sites: Blodgett experimental forest (AmeriFlux), Lower Teakettle (NEON), and Soaproot Saddle (NEON). Alternatively, using correlations between fluxes measured from these eddy covariance towers and GPP estimated from satellite retrievals of SIF, estimates can be made for inputs at the pixels corresponding to each site location.

```{r opt-mod, eval = FALSE}
# Note: this only runs if eval flag switched to TRUE
## Optimize model pars
# Cost function (evaluates error as model vs. obsv, per FME req)
# note that we have to set "pass" to TRUE so SoilR model doesn't fail (neg. resp)
mod.fits.fx <- function(mod, pars, In, sub, lag = 0, upper, lower, cost) {
  
  # start loop
  lapply(seq_along(pars[sub]), function(i) {
    
    # start timer and print PMeco_depth
    start <- Sys.time()
    cat(paste0(names(pars)[sub][i], " parameter fitting\n"))
  
    # define pars
    pars <- pars[sub][[i]]
    if (mod == "2pp") {
      names(pars) <- c("k1", "k2", "gam")
    } else {
      names(pars) <- c("k1", "k2", "tc")
    }
    
    # Set input
    In <- In[sub][[i]]
    
    # define cost function
    if (cost == "14C + cStock") {
      mod.Cost <- function(pars) {
        modelOutput <- modFun_2p(pars, In, mod = mod, lag = lag)
        cost1 <- modCost(model = modelOutput, obs = obs.bulk.14c[sub][[i]], scaleVar = TRUE)
        cost2 <- modCost(model = modelOutput, obs = obs.resp.14c[sub][[i]], scaleVar = TRUE, cost = cost1) 
        return(modCost(model = modelOutput, obs = obs.cStock[sub][[i]], cost = cost2))
      }
    } else if (cost == "14C + stock/flx") {
      mod.Cost <- function(pars) {
        modelOutput <- modFun_2p(pars, In, mod = mod, lag = lag)
        cost1 <- modCost(model = modelOutput, obs = obs.bulk.14c[sub][[i]], scaleVar = TRUE)
        cost2 <- modCost(model = modelOutput, obs = obs.resp.14c[sub][[i]], scaleVar = TRUE, cost = cost1) 
        return(modCost(model = modelOutput, obs = obs.flx.stock[[i]], cost = cost2))
      }
    } else if (cost == "14C") {
      mod.Cost <- function(pars) {
        modelOutput <- modFun_2p(pars, In, mod = mod, lag = lag)
        cost1 <- modCost(model = modelOutput, obs = obs.bulk.14c[sub][[i]], scaleVar = TRUE)
        return(modCost(model = modelOutput, obs = obs.resp.14c[sub][[i]], scaleVar = TRUE, cost = cost1))
      } 
    } else if (cost == "14C bulk + cStock") {
      mod.Cost <- function(pars) {
        modelOutput <- modFun_2p(pars, In, mod = mod, lag = lag)
        cost1 <- modCost(model = modelOutput, obs = obs.bulk.14c[sub][[i]], scaleVar = TRUE)
        return(modCost(model = modelOutput, obs = obs.cStock[sub][[i]], cost = cost1))
      }
    } else if (cost == "14C bulk only") {
      mod.Cost <- function(pars) {
        modelOutput <- modFun_2p(pars, In, mod = mod, lag = lag)
        return(modCost(model = modelOutput, obs = obs.bulk.14c[sub][[i]], scaleVar = TRUE))
      }
    }
    
    # fit pars
    fit <- tryCatch(
      modFit(f = mod.Cost,
             p = pars,
             method = 'Nelder-Mead',
             upper = upper, 
             lower = lower),
      error = function (e) {cat("ERROR :", conditionMessage(e), "\n")})
    
    Sfun <- sensFun(mod.Cost, fit$par)
    
    # End timer and print elapsed time
    end <- Sys.time()
    cat(paste0("time: ", end - start, "\n"))
    
    # Return fitted parameters and sensitivity
    return(list(modfit = fit, 
                sens = Sfun))
  }) 
}

## 2pp
# par range [0, 1] for all pars
mod.sens.fits.2pp <- mod.fits.fx(mod = "2pp",
                                 pars = pars.i.2pp,
                                 In = in.i,
                                 sub = ix.10,
                                 upper = c(1, 1, 1),
                                 lower = c(0, 0, 0),
                                 cost = "14C")
names(mod.sens.fits.2pp) <- names(pars.i.2pp)[ix.10]
save(mod.sens.fits.2pp, file = paste0("../data/derived/modFit_pars/", "mod.fits.2pp", "_", Sys.Date(), ".Rdata"))
mod.fits.2pp <- lapply(mod.sens.fits.2pp, function(x) x[[1]])
# constrain gamma to [0.5, 0.95]
mod.sens.fits.2pp.p3.5.95 <- mod.fits.fx(mod = "2pp",
                                    pars = pars.i.2pp,
                                    sub = ix.10,
                                    In = in.i,
                                    upper = c(1, 1, 0.951),
                                    lower = c(0, 0, 0.5))
names(mod.sens.fits.2pp.p3.5.95) <- names(pars.i.2pp)[ix.10]
save(mod.sens.fits.2pp.p3.5.95, file = paste0("../data/derived/modFit_pars/", "mod.fits.2pp.p3.5.95", "_", Sys.Date(), ".Rdata"))
mod.fits.2pp.p3.5.95 <- lapply(mod.sens.fits.2pp.p3.5.95, function(x) x[[1]])

# 2pp3 (par range constraints, inputs fit to meas stocks)
mod.sens.fits.2pp3 <- mod.fits.fx(mod = "2pp",
                                  pars = pars.i.2pp,
                                  sub = ix.10,
                                  In = in.meas.2pp,
                                  upper = c(1, .02, .951),
                                  lower = c(.04, .0001, .5),
                                  cost = "14C only")
names(mod.sens.fits.2pp3) <- names(pars.i.2pp)[ix.10]
save(mod.sens.fits.2pp3, file = paste0("../data/derived/modFit_pars/", "mod.fits.2pp3", "_", Sys.Date(), ".Rdata"))
mod.fits.2pp3 <- lapply(mod.sens.fits.2pp3, function(x) x[[1]])
# 2pp3s (par range constraints, inputs fit to meas stocks, + stock constraint)
mod.sens.fits.2pp3s <- mod.fits.fx(mod = "2pp",
                                   pars = pars.i.2pp,
                                   sub = ix.10,
                                   In = in.meas.2pp,
                                   upper = c(1, .02, .951),
                                   lower = c(.04, .0001, .5),
                                   cost = "cStock")
names(mod.sens.fits.2pp3s) <- names(pars.i.2pp)[ix.10]
save(mod.sens.fits.2pp3s, file = paste0("../data/derived/modFit_pars/", "mod.fits.2pp3s", "_", Sys.Date(), ".Rdata"))
mod.fits.2pp3s <- lapply(mod.sens.fits.2pp3s, function(x) x[[1]])

## 2ps
# par range [0, 1] for all pars
mod.sens.fits.2ps <- mod.fits.fx(mod = "2ps",
                                 pars = pars.i.2ps, 
                                 sub = ix.10,
                                 In = in.i,
                                 upper = c(1, 1, 1),
                                 lower = c(0, 0, 0),
                                 cost = "14C")
names(mod.sens.fits.2ps) <- names(pars.i.2ps)[ix.10]
save(mod.sens.fits.2ps, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps", "_", Sys.Date(), ".Rdata"))
mod.fits.2ps <- lapply(mod.sens.fits.2ps, function(x) x[[1]])
# 20-30
mod.sens.fits.2ps.30 <- mod.fits.fx(mod = "2ps",
                                    pars = pars.i.2ps, 
                                    sub = ix.30,
                                    In = in.i,
                                    upper = c(1, 1, 1),
                                    lower = c(0, 0, 0),
                                    cost = "14C")
names(mod.sens.fits.2ps.30) <- names(pars.i.2ps)[ix.30]
save(mod.sens.fits.2ps.30, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps.30", "_", Sys.Date(), ".Rdata"))
mod.fits.2ps.30 <- lapply(mod.sens.fits.2ps.30, function(x) x[[1]])

# 2ps3 (par range constraints, inputs fit to meas stocks)
mod.sens.fits.2ps3 <- mod.fits.fx(mod = "2ps",
                                  pars = pars.i.2ps,
                                  sub = ix.10,
                                  In = in.meas.2ps,
                                  upper = c(1, 1, .15),
                                  lower = c(0, 0, .0004),
                                  cost = "14C only")
names(mod.sens.fits.2ps3) <- names(pars.i.2ps)[ix.10]
save(mod.sens.fits.2ps3, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps3", "_", Sys.Date(), ".Rdata"))
mod.fits.2ps3 <- lapply(mod.sens.fits.2ps3, function(x) x[[1]])
# 2ps3 (par range constraints, inputs fit to meas stocks, + stock constraint)
mod.sens.fits.2ps3s <- mod.fits.fx(mod = "2ps",
                                   pars = pars.i.2ps,
                                   sub = ix.10,
                                   In = in.meas.2ps,
                                   upper = c(1, .02, .1),
                                   lower = c(.04, .0001, 0),
                                   cost = "cStock")
names(mod.sens.fits.2ps3s) <- names(pars.i.2ps)[ix.10]
save(mod.sens.fits.2ps3s, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps3s", "_", Sys.Date(), ".Rdata"))
mod.fits.2ps3s <- lapply(mod.sens.fits.2ps3s, function(x) x[[1]])

### 2p4 (par range set, stock and bulk 14C costs, GPP-based inputs by eco)
## 2pp
# 0-10
mod.sens.fits.2pp4.10 <- mod.fits.fx(mod = "2pp",
                                     pars = pars.i.2pp,
                                     sub = ix.10,
                                     In = in.est,
                                     upper = c(1, .02, .951),
                                     lower = c(.04, .0001, .5),
                                     cost = "14C bulk + cStock")
names(mod.sens.fits.2pp4.10) <- names(pars.i.2pp)[ix.10]
save(mod.sens.fits.2pp4.10, file = paste0("../data/derived/modFit_pars/", "mod.fits.2pp4.10", "_", Sys.Date(), ".Rdata"))
mod.fits.2pp4.10 <- lapply(mod.sens.fits.2pp4.10, function(x) x[[1]])
# 20-30
mod.sens.fits.2pp4.30 <- mod.fits.fx(mod = "2pp",
                                     pars = pars.i.2pp,
                                     sub = ix.30,
                                     In = in.est,
                                     upper = c(1, .02, .951),
                                     lower = c(.04, .0001, .5),
                                     cost = "14C bulk + cStock")
names(mod.sens.fits.2pp4.30) <- names(pars.i.2pp)[ix.30]
save(mod.sens.fits.2pp4.30, file = paste0("../data/derived/modFit_pars/", "mod.fits.2pp4.30", "_", Sys.Date(), ".Rdata"))
mod.fits.2pp4.30 <- lapply(mod.sens.fits.2pp4.30, function(x) x[[1]])
## 2ps
# 0-10
mod.sens.fits.2ps4.10 <- mod.fits.fx(mod = "2ps",
                                     pars = pars.i.2ps,
                                     sub = ix.10,
                                     In = in.est,
                                     upper = c(1, .02, .1),
                                     lower = c(.04, .0001, 0),
                                     cost = "14C bulk + cStock")
names(mod.sens.fits.2ps4.10) <- names(pars.i.2ps)[ix.10]
save(mod.sens.fits.2ps4.10, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps4.10", "_", Sys.Date(), ".Rdata"))
mod.fits.2ps4.10 <- lapply(mod.sens.fits.2ps4.10, function(x) x[[1]])
# 20-30
mod.sens.fits.2ps4.30 <- mod.fits.fx(mod = "2ps",
                                     pars = pars.i.2ps,
                                     sub = ix.30,
                                     In = in.est,
                                     upper = c(1, .02, .1),
                                     lower = c(.04, .0001, 0),
                                     cost = "14C bulk + cStock")
names(mod.sens.fits.2ps4.30) <- names(pars.i.2ps)[ix.30]
save(mod.sens.fits.2ps4.30, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps4.30", "_", Sys.Date(), ".Rdata"))
mod.fits.2ps4.30 <- lapply(mod.sens.fits.2ps4.30, function(x) x[[1]])

### 2p4r (par range set, stock, bulk, and respiration 14C costs, GPP-based inputs by eco)
## 2pp
# 0-10
mod.sens.fits.2pp4r.10 <- mod.fits.fx(mod = "2pp",
                                      pars = pars.i.2pp,
                                      sub = ix.10,
                                      In = in.est,
                                      upper = c(1, .02, .951),
                                      lower = c(.04, .0001, .5),
                                      cost = "14C + cStock")
names(mod.sens.fits.2pp4r.10) <- names(pars.i.2pp)[ix.10]
save(mod.sens.fits.2pp4r.10, file = paste0("../data/derived/modFit_pars/", "mod.fits.2pp4r.10", "_", Sys.Date(), ".Rdata"))
mod.fits.2pp4r.10 <- lapply(mod.sens.fits.2pp4r.10, function(x) x[[1]])
# 20-30
mod.sens.fits.2pp4r.30 <- mod.fits.fx(mod = "2pp",
                                      pars = pars.i.2pp,
                                      sub = ix.30,
                                      In = in.est,
                                      upper = c(1, .02, .951),
                                      lower = c(.04, .0001, .5),
                                      cost = "14C + cStock")
names(mod.sens.fits.2pp4r.30) <- names(pars.i.2pp)[ix.30]
save(mod.sens.fits.2pp4r.30, file = paste0("../data/derived/modFit_pars/", "mod.fits.2pp4r.30", "_", Sys.Date(), ".Rdata"))
mod.fits.2pp4r.30 <- lapply(mod.sens.fits.2pp4r.30, function(x) x[[1]])
## 2ps
# 0-10
mod.sens.fits.2ps4r.10 <- mod.fits.fx(mod = "2ps",
                                      pars = pars.i.2ps,
                                      sub = ix.10,
                                      In = in.est,
                                      upper = c(1, .02, .1),
                                      lower = c(.04, .0001, 0),
                                      cost = "14C + cStock")
names(mod.sens.fits.2ps4r.10) <- names(pars.i.2ps)[ix.10]
save(mod.sens.fits.2ps4r.10, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps4r.10", "_", Sys.Date(), ".Rdata"))
mod.fits.2ps4r.10 <- lapply(mod.sens.fits.2ps4r.10, function(x) x[[1]])
# 20-30
mod.sens.fits.2ps4r.30 <- mod.fits.fx(mod = "2ps",
                                      pars = pars.i.2ps,
                                      sub = ix.30,
                                      In = in.est,
                                      upper = c(1, .02, .1),
                                      lower = c(.04, .0001, 0),
                                      cost = "14C + cStock")
names(mod.sens.fits.2ps4r.30) <- names(pars.i.2ps)[ix.30]
save(mod.sens.fits.2ps4r.30, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps4r.30", "_", Sys.Date(), ".Rdata"))
mod.fits.2ps4r.30 <- lapply(mod.sens.fits.2ps4r.30, function(x) x[[1]])
```

```{r report-par-fit}
# load initial parameters as needed
if (!exists("pars.i.2pp")) {
 load("../data/derived/modFit_pars/pars.i.2pp_2020-11-16.Rdata") 
}
if (!exists("pars.i.2ps")) {
  load("../data/derived/modFit_pars/pars.i.2ps_2020-11-16.Rdata")  
}

# load fits as needed
if (!exists("mod.fits.2pp")) {
 load(file = "../data/derived/modFit_pars/mod.fits.2pp_2020-11-16.RData")
}
if (!exists("mod.fits.2pp.p3.5.95")) {
  load("../data/derived/modFit_pars/mod.fits.2pp.p3.5.95_2020-11-16.Rdata")  
}
if (!exists("mod.fits.2ps")) {
 load(file = "../data/derived/modFit_pars/mod.fits.2ps_2020-11-16.Rdata")
}
if (!exists("mod.fits.2pp2")) {
 load(file = "../data/derived/modFit_pars/mod.fits.2pp.flx.stock_2020-12-02.RData")
}
if (!exists("mod.fits.2ps2")) {
 load(file = "../data/derived/modFit_pars/mod.fits.2ps.flx.stock_2020-12-02.Rdata")
}
if (!exists("mod.fits.2pp3")) {
 load(file = "../data/derived/modFit_pars/mod.fits.2pp3_2020-12-08.RData")
}
if (!exists("mod.fits.2ps3")) {
 load(file = "../data/derived/modFit_pars/mod.fits.2ps3_2020-12-08.Rdata")
}
if (!exists("mod.fits.2pp3s")) {
 load(file = "../data/derived/modFit_pars/mod.fits.2pp3s_2020-12-08.RData")
}
if (!exists("mod.fits.2ps3s")) {
 load(file = "../data/derived/modFit_pars/mod.fits.2ps3s_2020-12-08.Rdata")
}

## Par estimates
# 2pp
pars.fit.2pp <- lapply(mod.fits.2pp, "[[", 1)
names(pars.fit.2pp) <- names(pars.i.2pp)[ix.10]
# 2pp gam = [.5, .95]
pars.fit.2pp.p3.5.95 <- lapply(mod.fits.2pp.p3.5.95, "[[", 1)
names(pars.fit.2pp.p3.5.95) <- names(pars.i.2pp)[ix.10]

# 2ps
pars.fit.2ps <- lapply(mod.fits.2ps, "[[", 1)
names(pars.fit.2ps) <- names(pars.i.2ps)[ix.10]


# 2pp2 (input/stock and 14C constraints)
pars.fit.2pp2 <- lapply(mod.fits.2pp2, "[[", 1)
names(pars.fit.2pp2) <- names(pars.i.2pp)[ix.10]
# 2ps2 (input/stock and 14C constraints)
pars.fit.2ps2 <- lapply(mod.fits.2ps2, "[[", 1)
names(pars.fit.2ps2) <- names(pars.i.2ps)[ix.10]

# 2pp3 (14C constraints, constrained par ranges, stock-fit inputs)
pars.fit.2pp3 <- lapply(mod.fits.2pp3, "[[", 1)
names(pars.fit.2pp3) <- names(pars.i.2pp)[ix.10]
# 2ps3 (14C constraints, constrained par ranges, stock-fit inputs)
pars.fit.2ps3 <- lapply(mod.fits.2ps3, "[[", 1)
names(pars.fit.2ps3) <- names(pars.i.2ps)[ix.10]

# 2pp3s (14C constraints, constrained par ranges, stock-fit inputs, + stock constraint)
pars.fit.2pp3s <- lapply(mod.fits.2pp3s, "[[", 1)
names(pars.fit.2pp3s) <- names(pars.i.2pp)[ix.10]
# 2ps3s (14C constraints, constrained par ranges, stock-fit inputs, + stock constraint)
pars.fit.2ps3s <- lapply(mod.fits.2ps3s, "[[", 1)
names(pars.fit.2ps3s) <- names(pars.i.2ps)[ix.10]

## stock & bulk 14C costs only
# 2pp
pars.fit.2pp4.10 <- lapply(mod.fits.2pp4.10, "[[", 1)
names(pars.fit.2pp4.10) <- names(pars.i.2pp)[ix.10]
pars.fit.2pp4.30 <- lapply(mod.fits.2pp4.30, "[[", 1)
names(pars.fit.2pp4.30) <- names(pars.i.2pp)[ix.30]
# 2ps
pars.fit.2ps4.10 <- lapply(mod.fits.2ps4.10, "[[", 1)
names(pars.fit.2ps4.10) <- names(pars.i.2ps)[ix.10]
pars.fit.2ps4.30 <- lapply(mod.fits.2ps4.30, "[[", 1)
names(pars.fit.2ps4.30) <- names(pars.i.2ps)[ix.30]

## stock, bulk and respiration 14C costs
# 2pp
pars.fit.2pp4r.10 <- lapply(mod.fits.2pp4r.10, "[[", 1)
names(pars.fit.2pp4r.10) <- names(pars.i.2pp)[ix.10]
pars.fit.2pp4r.30 <- lapply(mod.fits.2pp4r.30, "[[", 1)
names(pars.fit.2pp4r.30) <- names(pars.i.2pp)[ix.30]
# 2ps
pars.fit.2ps4r.10 <- lapply(mod.fits.2ps4r.10, "[[", 1)
names(pars.fit.2ps4r.10) <- names(pars.i.2ps)[ix.10]
pars.fit.2ps4r.30 <- lapply(mod.fits.2ps4r.30, "[[", 1)
names(pars.fit.2ps4r.30) <- names(pars.i.2ps)[ix.30]

## Summary of fits
# 2pp
pars.fit.2pp.sum <- lapply(mod.fits.2pp, function(x) {
  tryCatch(summary(x), 
           error = function (e) {cat("ERROR :", conditionMessage(e), "\n")})
})
names(pars.fit.2pp.sum) <- names(pars.fit.2pp)
# 2ps
pars.fit.2ps.sum <- lapply(mod.fits.2ps, function(x) {
  tryCatch(summary(x), 
           error = function (e) {cat("ERROR :", conditionMessage(e), "\n")})
})
names(pars.fit.2ps.sum) <- names(pars.fit.2ps)

## Summary of errors
# best par set (ssr)
ssr.2pp.df <- data.frame(bind_rows(lapply(mod.fits.2pp, "[", "ssr"), .id = "PMeco_depth"))
ssr.2ps.df <- data.frame(bind_rows(lapply(mod.fits.2ps, "[", "ssr"), .id = "PMeco_depth"))
ssr.2pp2.df <- data.frame(bind_rows(lapply(mod.fits.2pp2, "[", "ssr"), .id = "PMeco_depth"))
ssr.2ps2.df <- data.frame(bind_rows(lapply(mod.fits.2ps2, "[", "ssr"), .id = "PMeco_depth"))
# stock and bulk 14C costs only
ssr.2pp4.10.df <- data.frame(bind_rows(lapply(mod.fits.2pp4.10, "[", "ssr"), .id = "PMeco_depth"))
ssr.2pp4.30.df <- data.frame(bind_rows(lapply(mod.fits.2pp4.30, "[", "ssr"), .id = "PMeco_depth"))
ssr.2ps4.10.df <- data.frame(bind_rows(lapply(mod.fits.2ps4.10, "[", "ssr"), .id = "PMeco_depth"))
ssr.2ps4.30.df <- data.frame(bind_rows(lapply(mod.fits.2ps4.30, "[", "ssr"), .id = "PMeco_depth"))
# stock, bulk and resp 14C costs
ssr.2pp4r.10.df <- data.frame(bind_rows(lapply(mod.fits.2pp4r.10, "[", "ssr"), .id = "PMeco_depth"))
ssr.2pp4r.30.df <- data.frame(bind_rows(lapply(mod.fits.2pp4r.30, "[", "ssr"), .id = "PMeco_depth"))
ssr.2ps4r.10.df <- data.frame(bind_rows(lapply(mod.fits.2ps4r.10, "[", "ssr"), .id = "PMeco_depth"))
ssr.2ps4r.30.df <- data.frame(bind_rows(lapply(mod.fits.2ps4r.30, "[", "ssr"), .id = "PMeco_depth"))

# mean residuals, by var (var_ms)
var_ms.df.fx <- function(mod.fits.ls, costs) {
  df <- data.frame(bind_rows(lapply(mod.fits.ls, "[", "var_ms"), .id = "PMeco_depth"))
  if (length(costs) == 2 ) {
    df$var <- rep(c("resp", "bulkC"), nrow(df)/2)
  } else {
    df$var <- rep(c("resp", "bulkC", "flx.stock"), nrow(df)/3)
  }
  df$var_ms <- round(df$var_ms, 5)
  return(df)
}
var_ms.2pp.df <- var_ms.df.fx(mod.fits.2pp, c("resp", "bulkC"))
var_ms.2pp.p3.5.95.df <- var_ms.df.fx(mod.fits.2pp.p3.5.95, c("resp", "bulkC"))
var_ms.2ps.df <- var_ms.df.fx(mod.fits.2ps, c("resp", "bulkC"))
var_ms.2pp2.df <- var_ms.df.fx(mod.fits.2pp2, c("resp", "bulkC", "flx.stock"))
var_ms.2ps2.df <- var_ms.df.fx(mod.fits.2ps2, c("resp", "bulkC", "flx.stock"))

# bind fitted pars with initial pars into data frame for plotting/summarizing
par.fit.df.fx <- function(mod, pars.fit, pars.i) {
  df <- bind_rows(
    lapply(
      mapply(rbind, 
             pars.fit,
             pars.i,
             SIMPLIFY = FALSE), 
      function(df) {
        df <- data.frame(df)
        if (mod == "2pp") {
          colnames(df) <- c("kfast", "kslow", "gam")
        } else {
          colnames(df) <- c("kfast", "kslow", "a21")
        }
        df$est <- c("fit", "init")
        return(df)
      })
  )
  df$PMeco_depth <- rep(names(pars.i), each = 2)
  df$PM <- substr(df$PMeco_depth, start = 1, stop = 2)
  df$eco <- substr(df$PMeco_depth, start = 3, stop = 4)
  df$depth <- substr(df$PMeco_depth, start = 6, stop = length(df$PMeco_depth))
  return(df)
}


## 2pp
# gam range = [0, 1]
pars.fit.2pp.df <- par.fit.df.fx(mod = "2pp",
                                 pars.fit = pars.fit.2pp,
                                 pars.i = pars.i.2pp[ix.10])
# gam range = [.5, .95]
pars.fit.2pp.p3.5.95.df <- par.fit.df.fx(mod = "2pp",
                                         pars.fit = pars.fit.2pp.p3.5.95,
                                         pars.i = pars.i.2pp[ix.10])
# w/ input/stock cost and gam range = [.5, .95]
pars.fit.2pp2.df <- par.fit.df.fx(mod = "2pp",
                                  pars.fit = pars.fit.2pp2,
                                  pars.i = pars.i.2pp[ix.10])

## 2ps
# a21 range = [0, 1]
pars.fit.2ps.df <- par.fit.df.fx(mod = "2ps",
                                 pars.fit = pars.fit.2ps,
                                 pars.i = pars.i.2ps[ix.10])
# w/ input/stock cost and a21 range = [0, 1]
pars.fit.2ps2.df <- par.fit.df.fx(mod = "2ps",
                                 pars.fit = pars.fit.2ps2,
                                 pars.i = pars.i.2ps[ix.10])

## Constrained par ranges, with and without stock constraint
# w/o stock
pars.fit.2pp3.df <- par.fit.df.fx(mod = "2pp",
                                  pars.fit = pars.fit.2pp3,
                                  pars.i = pars.i.2pp[ix.10])
pars.fit.2ps3.df <- par.fit.df.fx(mod = "2ps",
                                  pars.fit = pars.fit.2ps3,
                                  pars.i = pars.i.2ps[ix.10])
# w/ stock
pars.fit.2pp3s.df <- par.fit.df.fx(mod = "2pp",
                                   pars.fit = pars.fit.2pp3s,
                                   pars.i = pars.i.2ps[ix.10])
pars.fit.2ps3s.df <- par.fit.df.fx(mod = "2ps",
                                   pars.fit = pars.fit.2ps3s,
                                   pars.i = pars.i.2ps[ix.10])
# w/ stock & bulk 14C only
pars.fit.2pp4.10.df <- par.fit.df.fx(mod = "2pp",
                                     pars.fit = pars.fit.2pp4.10,
                                     pars.i = pars.i.2pp[ix.10])
pars.fit.2pp4.30.df <- par.fit.df.fx(mod = "2pp",
                                     pars.fit = pars.fit.2pp4.30,
                                     pars.i = pars.i.2pp[ix.30])
pars.fit.2ps4.10.df <- par.fit.df.fx(mod = "2ps",
                                     pars.fit = pars.fit.2ps4.10,
                                     pars.i = pars.i.2ps[ix.10])
pars.fit.2ps4.30.df <- par.fit.df.fx(mod = "2ps",
                                     pars.fit = pars.fit.2ps4.30,
                                     pars.i = pars.i.2ps[ix.30])

# w/ stock, bulk + resp 14C
pars.fit.2pp4r.10.df <- par.fit.df.fx(mod = "2pp",
                                     pars.fit = pars.fit.2pp4r.10,
                                     pars.i = pars.i.2pp[ix.10])
pars.fit.2pp4r.30.df <- par.fit.df.fx(mod = "2pp",
                                     pars.fit = pars.fit.2pp4r.30,
                                     pars.i = pars.i.2pp[ix.30])
pars.fit.2ps4r.10.df <- par.fit.df.fx(mod = "2ps",
                                     pars.fit = pars.fit.2ps4r.10,
                                     pars.i = pars.i.2ps[ix.10])
pars.fit.2ps4r.30.df <- par.fit.df.fx(mod = "2ps",
                                     pars.fit = pars.fit.2ps4r.30,
                                     pars.i = pars.i.2ps[ix.30])


## Summarize by PM, depth
# 2pp
# PM/depth
pars.fit.2pp.df.PM <- pars.fit.2pp.df %>%
    filter(est == "fit") %>%
    select(!c(est, PMeco_depth, eco)) %>%
    group_by(PM, depth) %>%
    summarize_all(list(mean = mean, sd = sd)) %>%
    mutate_if(is.numeric, format, digits = 2)
# print table
knitr::kable(pars.fit.2pp.df.PM,
             caption = "Mean parameter estimates by parent material (PM)",
             align = "c")
# eco/depth
pars.fit.2pp.df.eco <- pars.fit.2pp.df %>%
  filter(est == "fit") %>%
  mutate(eco = factor(eco, levels = c("pp", "wf", "rf"))) %>%
  select(!c(est, PMeco_depth, PM)) %>%
  group_by(eco, depth) %>%
  summarize_all(list(mean = mean, sd = sd)) %>%
  mutate_if(is.numeric, format, digits = 2)
# print table
knitr::kable(pars.fit.2pp.df.eco,
             caption = "Mean parameter estimates by ecosystem (eco)",
             align = "c")
```

```{r sens-fun-fits}
## look at sensFun output
# without constraints
sens.2pp <- lapply(mod.sens.fits.2pp, function(x) x[[2]])
sens.2ps <- lapply(mod.sens.fits.2ps, function(x) x[[2]])
# without stock constraint
sens.2pp3 <- lapply(mod.sens.fits.2pp3, function(x) x[[2]])
sens.2ps3 <- lapply(mod.sens.fits.2ps3, function(x) x[[2]])
# with stock constraint
sens.2pp3s <- lapply(mod.sens.fits.2pp3s, function(x) x[[2]])
sens.2ps3s <- lapply(mod.sens.fits.2ps3s, function(x) x[[2]])
# with stock constraint, w/o resp
sens.2pp4.10 <- lapply(mod.sens.fits.2pp4.10, function(x) x[[2]])
sens.2pp4.30 <- lapply(mod.sens.fits.2pp4.30, function(x) x[[2]])
sens.2ps4.10 <- lapply(mod.sens.fits.2ps4.10, function(x) x[[2]])
sens.2ps4.30 <- lapply(mod.sens.fits.2ps4.30, function(x) x[[2]])
# with stock constraint + resp
sens.2pp4r.10 <- lapply(mod.sens.fits.2pp4r.10, function(x) x[[2]])
sens.2pp4r.30 <- lapply(mod.sens.fits.2pp4r.30, function(x) x[[2]])
sens.2ps4r.10 <- lapply(mod.sens.fits.2ps4r.10, function(x) x[[2]])
sens.2ps4r.30 <- lapply(mod.sens.fits.2ps4r.30, function(x) x[[2]])


# plot sensitivity
# w/o constraints
lapply(sens.2pp, function(x) plot(x, which = c("bulkC", "resp")))
lapply(sens.2ps, function(x) plot(x, which = c("bulkC", "resp")))
# w/o stock constraint
lapply(sens.2pp3, function(x) plot(x, which = c("bulkC", "cStock")))
lapply(sens.2ps3, function(x) plot(x, which = c("bulkC", "cStock")))
lapply(sens.2pp3s, function(x) plot(x, which = c("bulkC", "cStock")))
lapply(sens.2ps3s, function(x) plot(x, which = c("bulkC", "cStock")))
# with stock constraint, w/o resp
lapply(sens.2pp4.10, function(x) plot(x, which = c("bulkC", "cStock")))
lapply(sens.2pp4.30, function(x) plot(x, which = c("bulkC", "cStock")))
lapply(sens.2ps4.10, function(x) plot(x, which = c("bulkC", "cStock")))
lapply(sens.2ps4.30, function(x) plot(x, which = c("bulkC", "cStock")))
# with stock constraint + resp
lapply(sens.2pp4r.10, function(x) plot(x, which = c("bulkC", "cStock")))
lapply(sens.2pp4r.30, function(x) plot(x, which = c("bulkC", "cStock")))
lapply(sens.2ps4r.10, function(x) plot(x, which = c("bulkC", "cStock")))
lapply(sens.2ps4r.30, function(x) plot(x, which = c("bulkC", "cStock")))


# look at identifiability
inden.df.fx <- function(ls, mod) {
  lapply(ls, function(x) {
    df <- collin(x)
    if (mod == "2pp") {
      df$ParCombo <- factor(c("k1 + k2", "k1 + gam", "k2 + gam", "k1 + k2 + gam"))
    } else {
      df$ParCombo <- factor(c("k1 + k2", "k1 + a21", "k2 + a21", "k1 + k2 + a21"))
    }
    return(df)
  })
}

iden.2pp <- inden.df.fx(sens.2pp, mod = "2pp")
iden.2ps <- inden.df.fx(sens.2ps, mod = "2ps")
iden.2pp3 <- inden.df.fx(sens.2pp3, mod = "2pp")
iden.2ps3 <- inden.df.fx(sens.2ps3, mod = "2ps")
iden.2pp3s <- inden.df.fx(sens.2pp3s, mod = "2pp")
iden.2ps3s <- inden.df.fx(sens.2ps3s, mod = "2ps")
# with stock constraint, w/o resp
iden.2pp4.10 <- inden.df.fx(sens.2pp4.10, mod = "2pp")
iden.2pp4.30 <- inden.df.fx(sens.2pp4.30, mod = "2pp")
iden.2ps4.10 <- inden.df.fx(sens.2ps4.10, mod = "2ps")
iden.2ps4.30 <- inden.df.fx(sens.2ps4.30, mod = "2ps")
# with stock constraint + resp
iden.2pp4r.10 <- inden.df.fx(sens.2pp4r.10, mod = "2pp")
iden.2pp4r.30 <- inden.df.fx(sens.2pp4r.30, mod = "2pp")
iden.2ps4r.10 <- inden.df.fx(sens.2ps4r.10, mod = "2ps")
iden.2ps4r.30 <- inden.df.fx(sens.2ps4r.30, mod = "2ps")

# identifiability plot function
coll.plot.fx <- function(df, mod, PMeco_depth, col.max) {
  ggplot(df, aes(N, log(collinearity), color = ParCombo)) +
    geom_hline(yintercept = log(20)) +
    geom_point(size = 3.5, position = position_dodge(width = .1)) +
    scale_y_continuous(limits = c(0, log(col.max))) +
    scale_x_continuous(limits = c(1.5, 3.5), breaks = c(2, 3)) +
    labs(title = paste(PMeco_depth, mod)) +
    theme_bw() +
    theme(panel.grid = element_blank()) +
    if (mod == "2pp" | mod == "2pp + stock") {
     scale_color_manual(
       name = "Parameter combination",
       values = c("k1 + k2" = "#EF476F",
                  "k1 + gam" = "#FFD166",
                  "k2 + gam" = "#118AB2",
                  "k1 + k2 + gam" = "073B4C")) 
    } else {
      scale_color_manual(
        name = "Parameter combination",
        values = c("k1 + k2" = "#EF476F",
                  "k1 + a21" = "#FFD166",
                  "k2 + a21" = "#118AB2",
                  "k1 + k2 + a21" = "073B4C"))
    }
}
lapply(seq_along(iden.2pp), function(i) {
  coll.plot.fx(iden.2pp[[i]], mod = "2pp", names(iden.2pp)[i], max(iden.2pp[[i]]["collinearity"]))
})
lapply(seq_along(iden.2ps), function(i) {
  coll.plot.fx(iden.2ps[[i]], mod = "2ps", names(iden.2ps)[i], max(iden.2ps[[i]]["collinearity"]))
})
lapply(seq_along(iden.2pp3), function(i) {
  coll.plot.fx(iden.2pp3[[i]], mod = "2pp", names(iden.2pp3)[i])
})
lapply(seq_along(iden.2pp3s), function(i) {
  coll.plot.fx(iden.2pp3s[[i]], mod = "2pp + stock", names(iden.2pp3s)[i])
})
lapply(seq_along(iden.2ps3), function(i) {
  coll.plot.fx(iden.2ps3[[i]], mod = "2ps", names(iden.2ps3)[i])
})
lapply(seq_along(iden.2ps3s), function(i) {
  coll.plot.fx(iden.2ps3s[[i]], mod = "2ps + stock", names(iden.2ps3s)[i])
})
# stock constraint, w/o resp
col.max <- max(unlist(list(lapply(iden.2ps4.10, function(df) df[["collinearity"]]),
                           lapply(iden.2ps4.30, function(df) df[["collinearity"]]),
                           lapply(iden.2pp4.10, function(df) df[["collinearity"]]),
                           lapply(iden.2pp4.30, function(df) df[["collinearity"]]))))
lapply(seq_along(iden.2ps4.10), function(i) {
  coll.plot.fx(iden.2ps4.10[[i]], mod = "2ps + stock", names(iden.2ps4.10)[i], col.max)
})
lapply(seq_along(iden.2ps4.30), function(i) {
  coll.plot.fx(iden.2ps4.30[[i]], mod = "2ps + stock", names(iden.2ps4.30)[i], col.max)
})
lapply(seq_along(iden.2pp4.10), function(i) {
  coll.plot.fx(iden.2pp4.10[[i]], mod = "2pp + stock", names(iden.2pp4.10)[i], col.max)
})
lapply(seq_along(iden.2pp4.30), function(i) {
  coll.plot.fx(iden.2pp4.30[[i]], mod = "2pp + stock", names(iden.2pp4.30)[i], col.max)
})

# stock constraint + resp
col.max.r <- max(unlist(list(lapply(iden.2ps4r.10, function(df) df[["collinearity"]]),
                             lapply(iden.2ps4r.30, function(df) df[["collinearity"]]),
                             lapply(iden.2pp4r.10, function(df) df[["collinearity"]]),
                             lapply(iden.2pp4r.30, function(df) df[["collinearity"]]))))
lapply(seq_along(iden.2pp4r.10), function(i) {
  coll.plot.fx(iden.2pp4r.10[[i]], mod = "2pp", names(iden.2pp4r.10)[i], col.max)
})
lapply(seq_along(iden.2pp4r.30), function(i) {
  coll.plot.fx(iden.2pp4r.30[[i]], mod = "2ps", names(iden.2pp4r.30)[i], col.max)
})
lapply(seq_along(iden.2ps4r.10), function(i) {
  coll.plot.fx(iden.2ps4r.10[[i]], mod = "2ps + stock", names(iden.2ps4r.10)[i], col.max)
})
lapply(seq_along(iden.2ps4r.30), function(i) {
  coll.plot.fx(iden.2ps4r.30[[i]], mod = "2ps + stock", names(iden.2ps4r.30)[i], col.max)
})
```


```{r plot-modFit-pars}
## plot pars
par.plot.fx <- function(mod, depth, par.df, initial = FALSE) {
  par.df %>%
    { if (initial == TRUE) . else filter(., est == "fit") } %>%
    filter(depth == depth) %>%
    pivot_longer(!(est:depth), names_to = "par", values_to = "value") %>%
    mutate(PM = factor(PM),
           eco = factor(eco, levels = c("pp", "wf", "rf"))) %>%
    ggplot(., aes(par, value, color = PM, shape = eco)) +
    # geom_jitter(size = 4) +
    geom_point(size = 4, position = position_dodge(width = .5)) +
    scale_color_manual(name = "parent material",
                      labels = c("AN" = "andesite",
                                 "BS" = "basalt",
                                 "GR" = "granite"),
                      values = c("AN" = "blue", 
                                 "BS" = "red", 
                                 "GR" = "darkgray")) +
    facet_wrap(. ~ par, scales = "free") +
    ggtitle(paste0("modFit pars ", mod, " ", depth)) +
    theme_bw() +
    theme(panel.grid.minor = element_blank())
}
# 0-10
# 2pp
par.plot.fx(mod = "2pp",
            depth = "0-10",
            par.df = pars.fit.2pp.df,
            initial = FALSE)
# 2pp, gam = [.5,.95]
par.plot.fx(mod = "2pp (gam = [0.5, 0.95])",
            depth = "0-10",
            par.df = pars.fit.2pp.p3.5.95.df,
            initial = FALSE)
# 2pp2
par.plot.fx(mod = "2pp2",
            depth = "0-10",
            par.df = pars.fit.2pp2.df,
            initial = FALSE)
# 2ps
par.plot.fx(mod = "2ps",
            depth = "0-10",
            par.df = pars.fit.2ps.df,
            initial = FALSE)
# 2ps2
par.plot.fx(mod = "2ps2",
            depth = "0-10",
            par.df = pars.fit.2ps2.df,
            initial = FALSE)

# w/ and w/o stock constraint
par.plot.fx(mod = "2pp3",
            depth = "0-10",
            par.df = pars.fit.2pp3.df,
            initial = FALSE)
par.plot.fx(mod = "2pp3s",
            depth = "0-10",
            par.df = pars.fit.2pp3s.df,
            initial = FALSE)
par.plot.fx(mod = "2ps3",
            depth = "0-10",
            par.df = pars.fit.2ps3.df,
            initial = FALSE)
par.plot.fx(mod = "2ps3s",
            depth = "0-10",
            par.df = pars.fit.2ps3s.df,
            initial = FALSE)

## flux est inputs by eco
# stock and bulk 14C only
par.plot.fx(mod = "2pp4",
            depth = "0-10",
            par.df = pars.fit.2pp4.10.df,
            initial = FALSE)
par.plot.fx(mod = "2pp4",
            depth = "20-30",
            par.df = pars.fit.2pp4.30.df,
            initial = FALSE)
par.plot.fx(mod = "2ps4",
            depth = "0-10",
            par.df = pars.fit.2ps4.10.df,
            initial = FALSE)
par.plot.fx(mod = "2ps4",
            depth = "20-30",
            par.df = pars.fit.2ps4.30.df,
            initial = FALSE)

# stock and bulk + resp 14C
par.plot.fx(mod = "2pp4r",
            depth = "0-10",
            par.df = pars.fit.2pp4r.10.df,
            initial = FALSE)
par.plot.fx(mod = "2pp4r",
            depth = "20-30",
            par.df = pars.fit.2pp4r.30.df,
            initial = FALSE)
par.plot.fx(mod = "2ps4r",
            depth = "0-10",
            par.df = pars.fit.2ps4r.10.df,
            initial = FALSE)
par.plot.fx(mod = "2ps4r",
            depth = "20-30",
            par.df = pars.fit.2ps4r.30.df,
            initial = FALSE)
```

```{r fit-soc-in}
## Find best inputs
# 2pp
in.fit.2pp <- lapply(seq_along(pars.fit.2pp), function(i) {
  PMeco_depth <- names(pars.fit.2pp)[i]
  SOC <- csoc.19.0_30[[PMeco_depth]][ ,"lyr_soc"]
  return(in.fit.fx("2pp", pars.fit.2pp[[i]], in.i[ix.10][[i]], SOC))
})
names(in.fit.2pp) <- names(mod.fits.2pp)
# 2pp gam = [.5, .95]
in.fit.2pp.p3.5.95 <- lapply(seq_along(pars.fit.2pp.p3.5.95), function(i) {
  PMeco_depth <- names(pars.fit.2pp.p3.5.95)[i]
  SOC <- csoc.19.0_30[[PMeco_depth]][ ,"lyr_soc"]
  return(in.fit.fx("2pp", pars.fit.2pp.p3.5.95[[i]], in.i[ix.10][[i]], SOC))
})
names(in.fit.2pp.p3.5.95) <- names(mod.fits.2pp.p3.5.95)
# 2pp2
in.fit.2pp2 <- lapply(seq_along(pars.fit.2pp2), function(i) {
  PMeco_depth <- names(pars.fit.2pp2)[i]
  SOC <- csoc.19.0_30[[PMeco_depth]][ ,"lyr_soc"]
  return(in.fit.fx("2pp", pars.fit.2pp2[[i]], in.flx.stock[[i]], SOC))
})
names(in.fit.2pp2) <- names(mod.fits.2pp2)
# 2ps
in.fit.2ps <- lapply(seq_along(pars.fit.2ps), function(i) {
  PMeco_depth <- names(pars.fit.2ps)[i]
  SOC <- csoc.19.0_30[[PMeco_depth]][ ,"lyr_soc"]
  return(in.fit.fx("2ps", pars.fit.2ps[[i]], in.i[ix.10][[i]], SOC))
})
names(in.fit.2ps) <- names(mod.fits.2ps)
# 2ps2
in.fit.2ps2 <- lapply(seq_along(pars.fit.2ps2), function(i) {
  PMeco_depth <- names(pars.fit.2ps2)[i]
  SOC <- csoc.19.0_30[[PMeco_depth]][ ,"lyr_soc"]
  return(in.fit.fx("2ps", pars.fit.2ps2[[i]], in.flx.stock[[i]], SOC))
})
names(in.fit.2ps2) <- names(mod.fits.2ps2)

## Calc modeled stocks and compare with measured stocks
# 2pp
mod.socs.2pp.ls <- lapply(seq_along(pars.fit.2pp), function(i) {
  soc.fx("2pp", pars.fit.2pp[[i]], in.fit.2pp[[i]])
})
names(mod.socs.2pp.ls) <- names(pars.fit.2pp)
socs.2pp.ls <- mapply(cbind,
                      csoc.19.0_30[ix.10], 
                      lapply(mod.socs.2pp.ls, colSums), 
                      SIMPLIFY = FALSE)
# 2pp gam = [.5, .95]
mod.socs.2pp.p3.5.95.ls <- lapply(seq_along(pars.fit.2pp.p3.5.95), function(i) {
  soc.fx("2pp", pars.fit.2pp.p3.5.95[[i]], in.fit.2pp.p3.5.95[[i]])
})
names(mod.socs.2pp.p3.5.95.ls) <- names(pars.fit.2pp.p3.5.95)
socs.2pp.p3.5.95ls <- mapply(cbind,
                             csoc.19.0_30[ix.10], 
                             lapply(mod.socs.2pp.p3.5.95.ls, colSums), 
                             SIMPLIFY = FALSE)
# 2pp2
mod.socs.2pp2.ls <- lapply(seq_along(pars.fit.2pp2), function(i) {
  soc.fx("2pp", pars.fit.2pp2[[i]], in.fit.2pp2[[i]])
})
names(mod.socs.2pp2.ls) <- names(pars.fit.2pp2)

# 2ps
mod.socs.2ps.ls <- lapply(seq_along(pars.fit.2ps), function(i) {
  soc.fx("2ps", pars.fit.2ps[[i]], in.fit.2ps[[i]])
})
names(mod.socs.2ps.ls) <- names(pars.fit.2ps)
socs.2ps.ls <- mapply(cbind,
                      csoc.19.0_30[ix.10], 
                      lapply(mod.socs.2ps.ls, colSums), 
                      SIMPLIFY = FALSE)
# 2ps2
mod.socs.2ps2.ls <- lapply(seq_along(pars.fit.2ps2), function(i) {
  soc.fx("2ps", pars.fit.2ps2[[i]], in.fit.2ps2[[i]])
})
names(mod.socs.2ps2.ls) <- names(pars.fit.2ps2)

## stock and bulk 14C costs only
# 2pp
mod.socs.2pp4.10.ls <- lapply(seq_along(pars.fit.2pp4.10), function(i) {
  soc.fx("2pp", pars.fit.2pp4.10[[i]], in.est[ix.10][[i]])
})
names(mod.socs.2pp4.10.ls) <- names(pars.fit.2pp4.10)
mod.socs.2pp4.30.ls <- lapply(seq_along(pars.fit.2pp4.30), function(i) {
  soc.fx("2pp", pars.fit.2pp4.30[[i]], in.est[ix.30][[i]])
})
names(mod.socs.2pp4.30.ls) <- names(pars.fit.2pp4.30)
# 2ps
mod.socs.2ps4.10.ls <- lapply(seq_along(pars.fit.2ps4.10), function(i) {
  soc.fx("2ps", pars.fit.2ps4.10[[i]], in.est[ix.10][[i]])
})
names(mod.socs.2ps4.10.ls) <- names(pars.fit.2ps4.10)
mod.socs.2ps4.30.ls <- lapply(seq_along(pars.fit.2ps4.30), function(i) {
  soc.fx("2ps", pars.fit.2ps4.30[[i]], in.est[ix.30][[i]])
})
names(mod.socs.2ps4.30.ls) <- names(pars.fit.2ps4.30)

## stock and bulk + resp 14C costs
# 2pp
mod.socs.2pp4r.10.ls <- lapply(seq_along(pars.fit.2pp4r.10), function(i) {
  soc.fx("2pp", pars.fit.2pp4r.10[[i]], in.est[ix.10][[i]])
})
names(mod.socs.2pp4r.10.ls) <- names(pars.fit.2pp4r.10)
mod.socs.2pp4r.30.ls <- lapply(seq_along(pars.fit.2pp4r.30), function(i) {
  soc.fx("2pp", pars.fit.2pp4r.30[[i]], in.est[ix.30][[i]])
})
names(mod.socs.2pp4r.30.ls) <- names(pars.fit.2pp4r.30)
# 2ps
mod.socs.2ps4r.10.ls <- lapply(seq_along(pars.fit.2ps4r.10), function(i) {
  soc.fx("2ps", pars.fit.2ps4r.10[[i]], in.est[ix.10][[i]])
})
names(mod.socs.2ps4r.10.ls) <- names(pars.fit.2ps4r.10)
mod.socs.2ps4r.30.ls <- lapply(seq_along(pars.fit.2ps4r.30), function(i) {
  soc.fx("2ps", pars.fit.2ps4r.30[[i]], in.est[ix.30][[i]])
})
names(mod.socs.2ps4r.30.ls) <- names(pars.fit.2ps4r.30)


## Return data frames of model fits with adjusted inputs and optimal parameters
# 2pp
Twopp.fits <- lapply(seq_along(pars.fit.2pp), function(i) {
  par.fx(pars.fit.2pp[[i]], in.fit.2pp[[i]], verbose = FALSE, mod = "2pp")
})
names(Twopp.fits) <- names(pars.fit.2pp)
# 2pp gam = [.5, .95]
Twopp.p3.5.95.fits <- lapply(seq_along(pars.fit.2pp.p3.5.95), function(i) {
  par.fx(pars.fit.2pp.p3.5.95[[i]], in.fit.2pp.p3.5.95[[i]], verbose = FALSE, mod = "2pp")
})
names(Twopp.p3.5.95.fits) <- names(pars.fit.2pp.p3.5.95)
# 2pp2
Twopp2.fits <- lapply(seq_along(pars.fit.2pp2), function(i) {
  par.fx(pars.fit.2pp2[[i]], in.fit.2pp2[[i]], verbose = FALSE, mod = "2pp")
})
names(Twopp2.fits) <- names(pars.fit.2pp2)
# 2ps
Twops.fits <- lapply(seq_along(pars.fit.2ps), function(i) {
  par.fx(pars.fit.2ps[[i]], in.fit.2ps[[i]], verbose = FALSE, mod = "2ps")
})
names(Twops.fits) <- names(pars.fit.2ps)
# 2ps2
Twops2.fits <- lapply(seq_along(pars.fit.2ps2), function(i) {
  par.fx(pars.fit.2ps2[[i]], in.fit.2ps2[[i]], verbose = FALSE, mod = "2ps", pass = TRUE)
})
names(Twops2.fits) <- names(pars.fit.2ps2)

## stock and bulk 14C costs only
# 2pp
Twopp4.10.fits <- lapply(seq_along(pars.fit.2pp4.10), function(i) {
  par.fx(pars.fit.2pp4.10[[i]], in.est[ix.10][[i]], verbose = FALSE, mod = "2pp", pass = FALSE)
})
names(Twopp4.10.fits) <- names(pars.fit.2pp4.10)
Twopp4.30.fits <- lapply(seq_along(pars.fit.2pp4.30), function(i) {
  par.fx(pars.fit.2pp4.30[[i]], in.est[ix.30][[i]], verbose = FALSE, mod = "2pp", pass = FALSE)
})
names(Twopp4.30.fits) <- names(pars.fit.2pp4.30)
# 2ps
Twops4.10.fits <- lapply(seq_along(pars.fit.2ps4.10), function(i) {
  par.fx(pars.fit.2ps4.10[[i]], in.est[ix.10][[i]], verbose = FALSE, mod = "2ps", pass = FALSE)
})
names(Twops4.10.fits) <- names(pars.fit.2ps4.10)
Twops4.30.fits <- lapply(seq_along(pars.fit.2ps4.30), function(i) {
  par.fx(pars.fit.2ps4.30[[i]], in.est[ix.30][[i]], verbose = FALSE, mod = "2ps", pass = FALSE)
})
names(Twops4.30.fits) <- names(pars.fit.2ps4.30)

## stock and bulk + resp 14C costs
# 2pp
Twopp4r.10.fits <- lapply(seq_along(pars.fit.2pp4r.10), function(i) {
  par.fx(pars.fit.2pp4r.10[[i]], in.est[ix.10][[i]], verbose = FALSE, mod = "2pp", pass = FALSE)
})
names(Twopp4r.10.fits) <- names(pars.fit.2pp4r.10)
Twopp4r.30.fits <- lapply(seq_along(pars.fit.2pp4r.30), function(i) {
  par.fx(pars.fit.2pp4r.30[[i]], in.est[ix.30][[i]], verbose = FALSE, mod = "2pp", pass = FALSE)
})
names(Twopp4r.30.fits) <- names(pars.fit.2pp4r.30)
# 2ps
Twops4r.10.fits <- lapply(seq_along(pars.fit.2ps4r.10), function(i) {
  par.fx(pars.fit.2ps4r.10[[i]], in.est[ix.10][[i]], verbose = FALSE, mod = "2ps", pass = FALSE)
})
names(Twops4r.10.fits) <- names(pars.fit.2ps4r.10)
Twops4r.30.fits <- lapply(seq_along(pars.fit.2ps4r.30), function(i) {
  par.fx(pars.fit.2ps4r.30[[i]], in.est[ix.30][[i]], verbose = FALSE, mod = "2ps", pass = FALSE)
})
names(Twops4r.30.fits) <- names(pars.fit.2ps4r.30)
```

```{r plot-soc-stocks}
# Plot optimized model SOC stocks
mod.socs.df.fx <- function(mod, mod.socs.ls, pools) {
  n <- vapply(mod.socs.ls, nrow, numeric(1))
  return(data.frame(SOC = do.call(rbind, mod.socs.ls),
                    pool = rep(pools, length(mod.socs.ls)),
                    PMeco_depth = rep(names(mod.socs.ls), n),
                    Model = rep(mod, sum(n))))       
}
# run fx
# mod.socs.2p.df <- rbind(mod.socs.df.fx("2pp", mod.socs.2pp.ls, c("fast", "slow"))
#                         ,mod.socs.df.fx("2ps", mod.socs.2ps.ls, c("fast", "slow"))
#                         ,mod.socs.df.fx("2pp [.5,.95]", mod.socs.2pp.p3.5.95.ls, c("fast", "slow"))
#                         ,mod.socs.df.fx("2ps2", mod.socs.2ps2.ls, c("fast", "slow"))
#                         ,mod.socs.df.fx("2pp2", mod.socs.2pp2.ls, c("fast", "slow"))
#                         )
mod.socs.2p.df <- rbind(mod.socs.df.fx("2pp", mod.socs.2pp.ls, c("fast", "slow"))
                        ,mod.socs.df.fx("2ps", mod.socs.2ps.ls, c("fast", "slow"))
                        )


# stocks and bulk 14C only
mod.socs.2p4.10.df <- rbind(mod.socs.df.fx("2pp4 0-10", mod.socs.2pp4.10.ls, c("fast", "slow")), mod.socs.df.fx("2ps4 0-10", mod.socs.2ps4.10.ls, c("fast", "slow")))
mod.socs.2p4.30.df <- rbind(mod.socs.df.fx("2pp4 20-30", mod.socs.2pp4.30.ls, c("fast", "slow")) ,mod.socs.df.fx("2ps4 20-30", mod.socs.2ps4.30.ls, c("fast", "slow")))

# stocks and bulk + resp 14C
mod.socs.2p4r.10.df <- rbind(mod.socs.df.fx("2pp4r 0-10", mod.socs.2pp4r.10.ls, c("fast", "slow")), mod.socs.df.fx("2ps4r 0-10", mod.socs.2ps4r.10.ls, c("fast", "slow")))
mod.socs.2p4r.30.df <- rbind(mod.socs.df.fx("2pp4r 20-30", mod.socs.2pp4r.30.ls, c("fast", "slow")) ,mod.socs.df.fx("2ps4r 20-30", mod.socs.2ps4r.30.ls, c("fast", "slow")))

# combine inputs to compare
# in.fits.df <- pivot_longer(do.call(bind_rows, list(in.fit.2pp,
#                                                 in.fit.2pp.p3.5.95,
#                                                 in.fit.2pp2,
#                                                 in.fit.2ps,
#                                                 in.fit.2ps2)),
#                            everything(),
#                            names_to = "PMeco_depth",
#                            values_to = "inputs")
# in.fits.df$mod <- rep(c("2pp",
#                         "2pp.5.95",
#                         "2pp2",
#                         "2ps",
#                         "2ps2"),
#                       each = 9)
in.fits.df <- pivot_longer(do.call(bind_rows, list(in.fit.2pp,
                                                   in.fit.2ps)),
                           everything(),
                           names_to = "PMeco_depth",
                           values_to = "inputs")
in.fits.df$mod <- rep(c("2pp",
                        "2ps"),
                      each = 9)
                        
## plot stocks
# stock and bulk 14C only
mod.socs.2p4.10.df %>%
  mutate(PM = substr(PMeco_depth, 1, 2),
         eco = factor(substr(PMeco_depth, 3, 4), levels = c("pp", "wf", "rf"))) %>%
  ggplot(., aes(pool, SOC, fill = Model)) +
  geom_col(position = position_dodge()) +
  facet_grid(rows = vars(eco), cols = vars(PM)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
mod.socs.2p4.30.df %>%
  mutate(PM = substr(PMeco_depth, 1, 2),
         eco = factor(substr(PMeco_depth, 3, 4), levels = c("pp", "wf", "rf"))) %>%
  ggplot(., aes(pool, SOC, fill = Model)) +
  geom_col(position = position_dodge()) +
  facet_grid(rows = vars(eco), cols = vars(PM)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
# stock and bulk + resp 14C
mod.socs.2p4r.10.df %>%
  mutate(PM = substr(PMeco_depth, 1, 2),
         eco = factor(substr(PMeco_depth, 3, 4), levels = c("pp", "wf", "rf"))) %>%
  ggplot(., aes(pool, SOC, fill = Model)) +
  geom_col(position = position_dodge()) +
  facet_grid(rows = vars(eco), cols = vars(PM)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
mod.socs.2p4r.30.df %>%
  mutate(PM = substr(PMeco_depth, 1, 2),
         eco = factor(substr(PMeco_depth, 3, 4), levels = c("pp", "wf", "rf"))) %>%
  ggplot(., aes(pool, SOC, fill = Model)) +
  geom_col(position = position_dodge()) +
  facet_grid(rows = vars(eco), cols = vars(PM)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())

# inputs
in.fits.df %>%
  mutate(PM = substr(PMeco_depth, 1, 2),
         # Model = factor(Model, levels = c("2pp [.5,.95]", "2pp", "2ps")),
         eco = factor(substr(PMeco_depth, 3, 4), levels = c("pp", "wf", "rf"))) %>%
  ggplot(., aes(mod, inputs, fill = mod)) +
  geom_col(position = position_dodge()) +
  facet_grid(rows = vars(eco), cols = vars(PM)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```

```{r plot-opt-mod-2pp}
# plot fx
Twop.fit.plot.fx <- function(fit1, fit1.name, fit2, fit2.name, fit3 = NULL, fit3.name = NULL) {
  lapply(seq_along(fit1), function(i) {
    PMeco <- substr(names(fit1)[i], 1, 4)
    lyr_bot <- substr(names(fit1)[i], 
                      nchar(names(fit1)[i]) - 1, 
                      nchar(names(fit1)[i]))
    lyr_top <- ifelse(lyr_bot == 10, 0, ifelse(lyr_bot == 20, 10, 20))
    PMeco_depth <- names(fit1)[i]
    con.df <- con.df.fx(PMeco_depth)
    plot.df <- rbind(fit1[[i]],
                     fit2[[i]],
                     fit3[[i]])
    plot.df$Model <- factor(c(rep(fit1.name, nrow(fit1[[i]])),
                              rep(fit2.name, nrow(fit2[[i]])),
                              rep(fit3.name, nrow(fit3[[i]]))),
                            levels = c(fit1.name, fit2.name, fit3.name))
    return(plot.df %>%
             filter(pool == "bulk C" | pool == "respiration" | pool == "atm") %>%
             ggplot(., aes(years, d14C, color = pool)) +
             geom_path(aes(linetype = Model)) +
             geom_point(data = con.df, aes(Year, d14c, color = pool), size = 3) +
             scale_color_manual(
               name = "Model pool",
               values = c("atm" = 8,
                          "bulk C" = "black",
                          "fast" = "#D81B60",
                          "slow" = "#1E88E5",
                          "respiration" = "#FFC107")) +
             scale_x_continuous(limits = c(1950, 2022)) +
             ggtitle(paste0(PMeco_depth, " 2p mod fits")) +
             xlab("Year") +
             ylab(expression(''*Delta*''^14*'C (‰)')) +
             theme_bw() +
             theme(panel.grid = element_blank()))
  })
}
# 2p modFit optimal model comparison
Twop.fits.plots <- Twop.fit.plot.fx(Twopp.fits, "2pp", Twops.fits, "2ps")
Twop.fits.plots
# Twop.fits.plots2 <- Twop.fit.plot.fx(Twopp.fits, "2pp", Twopp.p3.5.95.fits, "2pp gam = [.5, .95]")
# Twop.fits.plots2
Twop.fits.plots3 <- Twop.fit.plot.fx(Twopp.p3.5.95.fits, "2pp gam = [.5, .95]", Twopp2.fits, "2pp2")
Twop.fits.plots3

## compare fits w/ and w/o resp constraint (2p4 mods)
# 2pp
Twopp4.fits.plots.10 <- Twop.fit.plot.fx(Twopp4.10.fits, "2pp4 0-10cm w/o resp", Twopp4r.10.fits, "2pp4r 0-10cm w/ resp")
Twopp4.fits.plots.30 <- Twop.fit.plot.fx(Twopp4.30.fits, "2pp4 20-30cm w/o resp", Twopp4r.10.fits, "2pp4r 20-30cm w/ resp")
# 2ps
Twops4.fits.plots.10 <- Twop.fit.plot.fx(Twops4.10.fits, "2ps4 0-10cm w/o resp", Twops4r.10.fits, "2ps4r 0-10cm w/ resp")
Twops4.fits.plots.30 <- Twop.fit.plot.fx(Twops4.30.fits, "2ps4 20-30cm w/o resp", Twops4r.10.fits, "2ps4r 20-30cm w/ resp")
# plot
Twopp4.fits.plots.10
Twopp4.fits.plots.30
Twops4.fits.plots.10
Twops4.fits.plots.30
```

```{r SAB-obs}
p <- sra.ts.all %>%
    filter(d14c > -200) %>%
    filter(ECO != "rf") %>%
    filter(lyr_bot == 20) %>%
    filter(year != 2009) %>%
    ggplot(., aes(year, d14c)) +
    geom_path(data = atm.14c) +
    geom_point(aes(color = pm, shape = ecoType), size = 3.5) +
    geom_path(aes(color = pm, linetype = Type), size = 1, alpha = 0.3) +
    geom_errorbar(
        aes(ymin = d14c_l, 
            ymax = d14c_u,
            color = pm), 
        width = .5) +
    scale_color_manual(name = "Parent material",
                       values = c("andesite" = "blue", 
                                  "basalt" = "red", 
                                  "granite" = "darkgray")) +
    scale_shape_manual(name = "Ecosystem (type)",
                       values = c("warm (inc)" = 0,
                                  "cool (inc)" = 1,
                                  "cold (inc)" = 2,
                                  "warm (bulk)" = 15,
                                  "cool (bulk)" = 16,
                                  "cold (bulk)" = 17)) +
    facet_grid(rows = vars(eco), cols = vars(pm)) +
    ylab(expression(Delta*''^14*'C (‰)')) +
    xlab("Year") +
    ggtitle("Bulk/inc 10-20 cm") +
    theme_bw() +
    theme(panel.grid = element_blank(),
          axis.text.x = element_text(size = 8))
ggsave("sra.ts.ppwf20.blk.inc.pdf", p, dpi = 300, width = 6.97, height = 5, units = "in")
# inc/bulk profiles
p <- sra.19.01.09 %>%
  filter(lyr_bot < 31) %>%
  select(Year, PM, ECO, PMeco, lyr_bot, d14c, d14c_sd) %>%
  mutate(Type = "bulk",
         d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         year = as.numeric(as.character(Year))) %>%
  select(-d14c_sd) %>%
  bind_rows(.,
            sra.19.01.inc %>%
              select(year, PM, ECO, PMeco, lyr_bot, d14c, d14c_min, d14c_max) %>%
              rename(d14c_l = d14c_min,
                     d14c_u = d14c_max) %>%
              mutate(Type = "inc")
  ) %>%
  mutate(depth = factor(lyr_bot),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite")),
         ecoType = paste0(eco, " (", Type, ")"))
ggsave("sra.ts.ppwf20.blk.pdf", p, dpi = 300, width = 6.97, height = 5, units = "in")
```

```{r SAB-modfits}
### Run modfit
## 14C bulk only
# 0-10
mod.sens.fits.2ps.10b <- mod.fits.fx(mod = "2ps",
                                     pars = pars.i.2ps, 
                                     sub = ix.10,
                                     In = in.est,
                                     upper = c(1, .02, .999),
                                     lower = c(.02, .0001, .001),
                                     cost = "14C bulk only")
names(mod.sens.fits.2ps.10b) <- names(pars.i.2ps)[ix.10]
save(mod.sens.fits.2ps.10b, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps.10b", "_", Sys.Date(), ".Rdata"))
# # 20-30
# mod.sens.fits.2ps.30b <- mod.fits.fx(mod = "2ps",
#                                      pars = pars.i.2ps, 
#                                      sub = ix.30,
#                                      In = in.est,
#                                      upper = c(1, .02, .15),
#                                      lower = c(.005, .0001, .0004),
#                                      cost = "14C bulk only")
# names(mod.sens.fits.2ps.30b) <- names(pars.i.2ps)[ix.30]
# save(mod.sens.fits.2ps.30b, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps.30b", "_", Sys.Date(), ".Rdata"))
# mod.fits.2ps.30b <- lapply(mod.sens.fits.2ps.30b, function(x) x[[1]])

## 14C (bulk + resp)
# 0-10
mod.sens.fits.2ps.10br <- mod.fits.fx(mod = "2ps",
                                     pars = pars.i.2ps, 
                                     sub = ix.10,
                                     In = in.est,
                                     upper = c(1, .02, .999),
                                     lower = c(.02, .0001, .001),
                                     cost = "14C")
names(mod.sens.fits.2ps.10br) <- names(pars.i.2ps)[ix.10]
save(mod.sens.fits.2ps.10br, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps.10br", "_", Sys.Date(), ".Rdata"))
# 10-20, lag = 5
mod.sens.fits.2ps.20br.l <- mod.fits.fx(mod = "2ps",
                                       pars = pars.i.2ps,
                                       sub = ix.20,
                                       In = in.est,
                                      lag = 5,
                                       upper = c(1, .02, .99),
                                       lower = c(.02, .0001, .01),
                                       cost = "14C")
names(mod.sens.fits.2ps.20br.l) <- names(pars.i.2ps)[ix.20]
save(mod.sens.fits.2ps.20br.l, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps.20br.l", "_", Sys.Date(), ".Rdata"))
# # 20-30
# mod.sens.fits.2ps.30br <- mod.fits.fx(mod = "2ps",
#                                      pars = pars.i.2ps, 
#                                      sub = ix.30,
#                                      In = in.est,
#                                      upper = c(1, .02, .15),
#                                      lower = c(.005, .0001, .0004),
#                                      cost = "14C")
# names(mod.sens.fits.2ps.30br) <- names(pars.i.2ps)[ix.30]
# save(mod.sens.fits.2ps.30br, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps.30br", "_", Sys.Date(), ".Rdata"))
# mod.fits.2ps.30br <- lapply(mod.sens.fits.2ps.30br, function(x) x[[1]])

## 14C bulk + stocks
# 0-10
mod.sens.fits.2ps.10bs <- mod.fits.fx(mod = "2ps",
                                      pars = pars.i.2ps,
                                      sub = ix.10,
                                      In = in.est,
                                      upper = c(1, .02, .999),
                                      lower = c(.02, .0001, .001),
                                      cost = "14C bulk + cStock")
names(mod.sens.fits.2ps.10bs) <- names(pars.i.2ps)[ix.10]
save(mod.sens.fits.2ps.10bs, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps.10bs", "_", Sys.Date(), ".Rdata"))
mod.fits.2ps.10bs <- lapply(mod.sens.fits.2ps.10bs, function(x) x[[1]])
# # 20-30
# mod.sens.fits.2ps.30b <- mod.fits.fx(mod = "2ps",
#                                      pars = pars.i.2ps, 
#                                      sub = ix.30,
#                                      In = in.est,
#                                      upper = c(1, .02, .15),
#                                      lower = c(.005, .0001, .0004),
#                                      cost = "14C bulk only")
# names(mod.sens.fits.2ps.30b) <- names(pars.i.2ps)[ix.30]
# save(mod.sens.fits.2ps.30b, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps.30b", "_", Sys.Date(), ".Rdata"))
# mod.fits.2ps.30b <- lapply(mod.sens.fits.2ps.30b, function(x) x[[1]])

## 14C + cStock (14C resp, 14C bulk, stocks)
# 0-10
mod.sens.fits.2ps.10rbs <- mod.fits.fx(mod = "2ps",
                                       pars = pars.i.2ps,
                                       sub = ix.10,
                                       In = in.est,
                                       upper = c(1, .02, .999),
                                       lower = c(.02, .0001, .001),
                                       cost = "14C + cStock")
names(mod.sens.fits.2ps.10rbs) <- names(pars.i.2ps)[ix.10]
save(mod.sens.fits.2ps.10rbs, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps.10rbs", "_", Sys.Date(), ".Rdata"))
mod.fits.2ps.10rbs <- lapply(mod.sens.fits.2ps.10rbs, function(x) x[[1]])
# 10-20
# w/o lag
mod.sens.fits.2ps.20rbs <- mod.fits.fx(mod = "2ps",
                                       pars = pars.i.2ps,
                                       sub = ix.20,
                                       In = in.est,
                                       upper = c(1, .02, .99),
                                       lower = c(.02, .0001, .01),
                                       cost = "14C + cStock")
names(mod.sens.fits.2ps.20rbs) <- names(pars.i.2ps)[ix.20]
save(mod.sens.fits.2ps.20rbs, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps.20rbs", "_", Sys.Date(), ".Rdata"))
# w/ lag = 12
mod.sens.fits.2ps.20rbs.l <- mod.fits.fx(mod = "2ps",
                                       pars = pars.i.2ps,
                                       sub = ix.20,
                                       In = in.est,
                                       lag = 12,
                                       upper = c(1, .02, .99),
                                       lower = c(.02, .0001, .01),
                                       cost = "14C + cStock")
names(mod.sens.fits.2ps.20rbs.l) <- names(pars.i.2ps)[ix.20]
save(mod.sens.fits.2ps.20rbs.l, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps.20rbs.l", "_", Sys.Date(), ".Rdata"))
# # 20-30
# mod.sens.fits.2ps.30b <- mod.fits.fx(mod = "2ps",
#                                      pars = pars.i.2ps, 
#                                      sub = ix.30,
#                                      In = in.est,
#                                      upper = c(1, .02, .15),
#                                      lower = c(.005, .0001, .0004),
#                                      cost = "14C bulk only")
# names(mod.sens.fits.2ps.30b) <- names(pars.i.2ps)[ix.30]
# save(mod.sens.fits.2ps.30b, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps.30b", "_", Sys.Date(), ".Rdata"))
# mod.fits.2ps.30b <- lapply(mod.sens.fits.2ps.30b, function(x) x[[1]])
```

```{r SAB-mod-fits}
# SAB fits
load("../data/derived/modFit_pars/mod.fits.2ps.10b_2021-04-07.Rdata")
load("../data/derived/modFit_pars/mod.fits.2ps.10br_2021-04-07.Rdata")
load("../data/derived/modFit_pars/mod.fits.2ps.10bs_2021-04-07.Rdata")
load("../data/derived/modFit_pars/mod.fits.2ps.10rbs_2021-04-07.Rdata")
load("../data/derived/modFit_pars/mod.fits.2ps.20rbs_2021-04-12.Rdata")
load("../data/derived/modFit_pars/mod.fits.2ps.20rbs.l_2021-04-13.Rdata")
load("../data/derived/modFit_pars/mod.fits.2ps.20br.l_2021-04-13.Rdata")
load("../data/derived/modFit_pars/pars.i.2ps_2021-04-06.Rdata")

# extract mod fits
mod.fits.2ps.10b <- lapply(mod.sens.fits.2ps.10b, function(x) x[[1]])
mod.fits.2ps.10bs <- lapply(mod.sens.fits.2ps.10bs, function(x) x[[1]])
mod.fits.2ps.10br <- lapply(mod.sens.fits.2ps.10br, function(x) x[[1]])
mod.fits.2ps.10rbs <- lapply(mod.sens.fits.2ps.10rbs, function(x) x[[1]])
mod.fits.2ps.20rbs <- lapply(mod.sens.fits.2ps.20rbs, function(x) x[[1]])
mod.fits.2ps.20rbs.l <- lapply(mod.sens.fits.2ps.20rbs.l, function(x) x[[1]])
mod.fits.2ps.20br.l <- lapply(mod.sens.fits.2ps.20br.l, function(x) x[[1]]) 
  
# Sensitivity/Identifiability
#####
# extract at sensFun output
sens.2ps.10b <- lapply(mod.sens.fits.2ps.10b, function(x) x[[2]])
sens.2ps.10br <- lapply(mod.sens.fits.2ps.10br, function(x) x[[2]])
sens.2ps.10bs <- lapply(mod.sens.fits.2ps.10bs, function(x) x[[2]])
sens.2ps.10rbs <- lapply(mod.sens.fits.2ps.10rbs, function(x) x[[2]])
sens.2ps.20rbs <- lapply(mod.sens.fits.2ps.20rbs, function(x) x[[2]])
sens.2ps.20rbs.l <- lapply(mod.sens.fits.2ps.20rbs.l, function(x) x[[2]])
sens.2ps.20br.l <- lapply(mod.sens.fits.2ps.20br.l, function(x) x[[2]])

# plot sensitivity
lapply(sens.2ps.10b, function(x) plot(x, which = c("bulkC", "resp")))
lapply(sens.2ps.10br, function(x) plot(x, which = c("bulkC", "resp")))
lapply(sens.2ps.10bs, function(x) plot(x, which = c("bulkC", "resp")))
lapply(sens.2ps.10rbs, function(x) plot(x, which = c("bulkC", "resp")))

# look at identifiability
iden.2ps.10b <- inden.df.fx(sens.2ps.10b, mod = "2ps")
iden.2ps.10br <- inden.df.fx(sens.2ps.10br, mod = "2ps")
iden.2ps.10bs <- inden.df.fx(sens.2ps.10bs, mod = "2ps")
iden.2ps.10rbs <- inden.df.fx(sens.2ps.10rbs, mod = "2ps")
iden.2ps.20rbs <- inden.df.fx(sens.2ps.20rbs, mod = "2ps")
iden.2ps.20rbs.l <- inden.df.fx(sens.2ps.20rbs.l, mod = "2ps")
iden.2ps.20br.l <- inden.df.fx(sens.2ps.20br.l, mod = "2ps")

# plot
lapply(seq_along(iden.2ps.10bs), function(i) {
  coll.plot.fx(iden.2ps.10bs[[i]], mod = "2ps", 
               names(iden.2ps.10bs)[i], 
               max(iden.2ps.10bs[[i]]["collinearity"]))
})
lapply(seq_along(iden.2ps.10br), function(i) {
  coll.plot.fx(iden.2ps.10br[[i]], mod = "2ps", 
               names(iden.2ps.10br)[i], 
               max(iden.2ps.10br[[i]]["collinearity"]))
})
lapply(seq_along(iden.2ps.10rbs), function(i) {
  coll.plot.fx(iden.2ps.10rbs[[i]], mod = "2ps", 
               names(iden.2ps.10rbs)[i], 
               max(iden.2ps.10rbs[[i]]["collinearity"]))
})
lapply(seq_along(iden.2ps.20rbs), function(i) {
  coll.plot.fx(iden.2ps.20rbs[[i]], mod = "2ps", 
               names(iden.2ps.20rbs)[i], 
               max(iden.2ps.20rbs[[i]]["collinearity"]))
})
lapply(seq_along(iden.2ps.20rbs.l), function(i) {
  coll.plot.fx(iden.2ps.20rbs.l[[i]], mod = "2ps", 
               names(iden.2ps.20rbs.l)[i], 
               max(iden.2ps.20rbs.l[[i]]["collinearity"]))
})
lapply(seq_along(iden.2ps.20br.l), function(i) {
  coll.plot.fx(iden.2ps.20br.l[[i]], mod = "2ps", 
               names(iden.2ps.20br.l)[i], 
               max(iden.2ps.20br.l[[i]]["collinearity"]))
})
#####

# Extract optimized pars from modfit output
#####
## bulk 14c only
# 0-10
pars.fit.2ps.10b <- lapply(mod.fits.2ps.10b, "[[", 1)
names(pars.fit.2ps.10b) <- names(pars.i.2ps)[ix.10]
# # 20-30
# pars.fit.2ps.30b <- lapply(mod.fits.2ps.30b, "[[", 1)
# names(pars.fit.2ps.30b) <- names(pars.i.2ps)[ix.30]

## resp + bulk 14c
# 0-10
pars.fit.2ps.10br <- lapply(mod.fits.2ps.10br, "[[", 1)
names(pars.fit.2ps.10br) <- names(pars.i.2ps)[ix.10]
# 10-20 w/ lag = 5y
pars.fit.2ps.20br.l <- lapply(mod.fits.2ps.20br.l, "[[", 1)
names(pars.fit.2ps.20br.l) <- names(pars.i.2ps)[ix.20]
# # 20-30
# pars.fit.2ps.30br <- lapply(mod.fits.2ps.30br, "[[", 1)
# names(pars.fit.2ps.30br) <- names(pars.i.2ps)[ix.30]

## bulk 14c + stocks
# 0-10
pars.fit.2ps.10bs <- lapply(mod.fits.2ps.10bs, "[[", 1)
names(pars.fit.2ps.10bs) <- names(pars.i.2ps)[ix.10]
# # 20-30
# pars.fit.2ps.30br <- lapply(mod.fits.2ps.30br, "[[", 1)
# names(pars.fit.2ps.30br) <- names(pars.i.2ps)[ix.30]

## resp, bulk 14c, stocks
# 0-10
pars.fit.2ps.10rbs <- lapply(mod.fits.2ps.10rbs, "[[", 1)
names(pars.fit.2ps.10rbs) <- names(pars.i.2ps)[ix.10]
# 10-20
pars.fit.2ps.20rbs <- lapply(mod.fits.2ps.20rbs, "[[", 1)
names(pars.fit.2ps.20rbs) <- names(pars.i.2ps)[ix.20]
# 10-20 w/ lag = 12y
pars.fit.2ps.20rbs.l <- lapply(mod.fits.2ps.20rbs.l, "[[", 1)
names(pars.fit.2ps.20rbs.l) <- names(pars.i.2ps)[ix.20]
# # 20-30
# pars.fit.2ps.30br <- lapply(mod.fits.2ps.30br, "[[", 1)
# names(pars.fit.2ps.30br) <- names(pars.i.2ps)[ix.30]
#####

# SOC stocks
#####
# w/o stock constraint
mod.socs.2ps.10b.ls <- lapply(seq_along(pars.fit.2ps.10b), function(i) {
  soc.fx("2ps", pars.fit.2ps.10b[[i]], in.est[[i]])
})
names(mod.socs.2ps.10b.ls) <- names(pars.fit.2ps.10b)
mod.socs.2ps.10br.ls <- lapply(seq_along(pars.fit.2ps.10br), function(i) {
  soc.fx("2ps", pars.fit.2ps.10br[[i]], in.est[[i]])
})
names(mod.socs.2ps.10br.ls) <- names(pars.fit.2ps.10br)
socs.2ps.10br.ls <- mapply(cbind,
                           csoc.19.0_30[ix.10], 
                           lapply(mod.socs.2ps.10br.ls, colSums), 
                           SIMPLIFY = FALSE)
# w/ stock constraint
mod.socs.2ps.10bs.ls <- lapply(seq_along(pars.fit.2ps.10bs), function(i) {
  soc.fx("2ps", pars.fit.2ps.10bs[[i]], in.est[[i]])
})
names(mod.socs.2ps.10bs.ls) <- names(pars.fit.2ps.10bs)
mod.socs.2ps.10rbs.ls <- lapply(seq_along(pars.fit.2ps.10rbs), function(i) {
  soc.fx("2ps", pars.fit.2ps.10rbs[[i]], in.est[[i]])
})
names(mod.socs.2ps.10rbs.ls) <- names(pars.fit.2ps.10rbs)
mod.socs.2ps.20rbs.ls <- lapply(seq_along(pars.fit.2ps.20rbs), function(i) {
  soc.fx("2ps", pars.fit.2ps.20rbs[[i]], in.est[ix.20][[i]])
})
names(mod.socs.2ps.20rbs.ls) <- names(pars.fit.2ps.20rbs)
socs.2ps.10rbs.ls <- mapply(cbind,
                           csoc.19.0_30[ix.10], 
                           lapply(mod.socs.2ps.10rbs.ls, colSums), 
                           SIMPLIFY = FALSE)

## make df for plotting
# resp + bulk, w/ and w/o stocks
mod.socs.2ps.10brrbs.df <- rbind(mod.socs.df.fx("2ps w/o stock", mod.socs.2ps.10br.ls, c("fast", "slow"))
                                 ,mod.socs.df.fx("2ps w/ stock", mod.socs.2ps.10rbs.ls, c("fast", "slow"))
                                 ,data.frame(SOC = unlist(lapply(csoc.19.0_30[ix.10], "[[", 4)),
                                             PMeco_depth = paste0(
                                               unlist(lapply(csoc.19.0_30[ix.10], "[[", 1)),
                                               "_",
                                               unlist(lapply(csoc.19.0_30[ix.10], "[[", 2)),
                                               "-",
                                               unlist(lapply(csoc.19.0_30[ix.10], "[[", 3))),
                                             Model = "measured",
                                             pool = "total")
                                 )
# bulk + stock, vs. resp, bulk, + stock
mod.socs.2ps.10bsrbs.df <- rbind(mod.socs.df.fx("2ps bulk + stock only", mod.socs.2ps.10bs.ls, c("fast", "slow"))
                                 ,mod.socs.df.fx("2ps bulk, resp, + stock", mod.socs.2ps.10rbs.ls, c("fast", "slow"))
                                 ,data.frame(SOC = unlist(lapply(csoc.19.0_30[ix.10], "[[", 4)),
                                             PMeco_depth = paste0(
                                               unlist(lapply(csoc.19.0_30[ix.10], "[[", 1)),
                                               "_",
                                               unlist(lapply(csoc.19.0_30[ix.10], "[[", 2)),
                                               "-",
                                               unlist(lapply(csoc.19.0_30[ix.10], "[[", 3))),
                                             Model = "measured",
                                             pool = "total")
                                 )


## plot
mod.socs.2ps.10brrbs.df %>%
  mutate(PM = substr(PMeco_depth, 1, 2),
         eco = factor(substr(PMeco_depth, 3, 4), levels = c("pp", "wf", "rf"))) %>%
  ggplot(., aes(pool, SOC, fill = Model)) +
  geom_col(position = position_dodge()) +
  facet_grid(rows = vars(eco), cols = vars(PM)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
mod.socs.2ps.10bsrbs.df %>%
  mutate(PM = substr(PMeco_depth, 1, 2),
         eco = factor(substr(PMeco_depth, 3, 4), levels = c("pp", "wf", "rf"))) %>%
  ggplot(., aes(pool, SOC, fill = Model)) +
  geom_col(position = position_dodge()) +
  facet_grid(rows = vars(eco), cols = vars(PM)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
#####

### Summarize optimized par data for plotting
## bulk 14c only
# 0-10
pars.fit.2ps.10b.df <- par.fit.df.fx(mod = "2ps",
                                     pars.fit = pars.fit.2ps.10b,
                                     pars.i = pars.i.2ps[ix.10])
# # 20-30
# pars.fit.2ps.30b.df <- par.fit.df.fx(mod = "2ps",
#                                       pars.fit = pars.fit.2ps.30b,
#                                       pars.i = pars.i.2ps[ix.30])

## resp + bulk 14c
# 0-10
pars.fit.2ps.10br.df <- par.fit.df.fx(mod = "2ps",
                                       pars.fit = pars.fit.2ps.10br,
                                       pars.i = pars.i.2ps[ix.10])
# 10-20
pars.fit.2ps.20br.l.df <- par.fit.df.fx(mod = "2ps",
                                       pars.fit = pars.fit.2ps.20br.l,
                                       pars.i = pars.i.2ps[ix.10])
# # 20-30
# pars.fit.2ps.30br.df <- par.fit.df.fx(mod = "2ps",
#                                        pars.fit = pars.fit.2ps.30br,
#                                        pars.i = pars.i.2ps[ix.30])

## bulk 14c + stocks
# 0-10
pars.fit.2ps.10bs.df <- par.fit.df.fx(mod = "2ps",
                                       pars.fit = pars.fit.2ps.10bs,
                                       pars.i = pars.i.2ps[ix.10])
# # 20-30
# pars.fit.2ps.30br.df <- par.fit.df.fx(mod = "2ps",
#                                        pars.fit = pars.fit.2ps.30br,
#                                        pars.i = pars.i.2ps[ix.30])

## resp, bulk, stocks
# 0-10
pars.fit.2ps.10rbs.df <- par.fit.df.fx(mod = "2ps",
                                       pars.fit = pars.fit.2ps.10rbs,
                                       pars.i = pars.i.2ps[ix.10])
# 10-20
pars.fit.2ps.20rbs.df <- par.fit.df.fx(mod = "2ps",
                                       pars.fit = pars.fit.2ps.20rbs,
                                       pars.i = pars.i.2ps[ix.20])
# w/ lag
pars.fit.2ps.20rbs.l.df <- par.fit.df.fx(mod = "2ps",
                                       pars.fit = pars.fit.2ps.20rbs.l,
                                       pars.i = pars.i.2ps[ix.20])
# # 20-30
# pars.fit.2ps.30br.df <- par.fit.df.fx(mod = "2ps",
#                                        pars.fit = pars.fit.2ps.30br,
#                                        pars.i = pars.i.2ps[ix.30])

### Par fits
par.plot.fx(mod = "2ps bulk 14c",
            depth = "0-10",
            par.df = pars.fit.2ps.10b.df,
            initial = FALSE)
par.plot.fx(mod = "2ps resp + bulk 14c",
            depth = "0-10",
            par.df = pars.fit.2ps.10br.df,
            initial = FALSE)
par.plot.fx(mod = "2ps bulk 14c + stocks",
            depth = "0-10",
            par.df = pars.fit.2ps.10bs.df,
            initial = FALSE)
par.plot.fx(mod = "2ps resp, bulk, stocks",
            depth = "0-10",
            par.df = pars.fit.2ps.10rbs.df,
            initial = FALSE)
par.plot.fx(mod = "2ps resp, bulk, stocks",
            depth = "10-20",
            par.df = pars.fit.2ps.20rbs.df,
            initial = FALSE)
par.plot.fx(mod = "2ps resp, bulk, stocks",
            depth = "10-20",
            par.df = pars.fit.2ps.20rbs.l.df,
            initial = FALSE)
par.plot.fx(mod = "2ps resp, bulk",
            depth = "10-20",
            par.df = pars.fit.2ps.20br.l.df,
            initial = FALSE)
# par.plot.fx(mod = "2ps bulk 14c",
#             depth = "20-30",
#             par.df = pars.fit.2ps.30b.df,
#             initial = FALSE)
# par.plot.fx(mod = "2ps resp + bulk 14c",
#             depth = "20-30",
#             par.df = pars.fit.2ps.30br.df,
#             initial = FALSE)

### Fit models with optimized pars
## bulk 14C only
# 0-10
Twops.10b.fits <- lapply(seq_along(pars.fit.2ps.10b), function(i) {
  tryCatch(
    par.fx(pars.fit.2ps.10b[[i]], in.est[ix.10][[i]], verbose = FALSE, mod = "2ps", pass = FALSE),
    error = function (e) {cat("ERROR :", conditionMessage(e), "\n")})
})
names(Twops.10b.fits) <- names(pars.fit.2ps.10b)
# # 20-30
# Twops.30b.fits <- lapply(seq_along(pars.fit.2ps.30b), function(i) {
#   tryCatch(
#     par.fx(pars.fit.2ps.30b[[i]], in.est[ix.30][[i]], verbose = FALSE, mod = "2ps", pass = FALSE),
#     error = function (e) {cat("ERROR :", conditionMessage(e), "\n")})
# })
# names(Twops.30b.fits) <- names(pars.fit.2ps.30b)

## resp + bulk 14C
# 0-10
Twops.10br.fits <- lapply(seq_along(pars.fit.2ps.10br), function(i) {
  tryCatch(
    par.fx(pars.fit.2ps.10br[[i]], in.est[ix.10][[i]], verbose = FALSE, mod = "2ps", pass = FALSE),
    error = function (e) {cat("ERROR :", conditionMessage(e), "\n")})
})
names(Twops.10br.fits) <- names(pars.fit.2ps.10br)
# 10-20
Twops.20br.l.fits <- lapply(seq_along(pars.fit.2ps.20br.l), function(i) {
  tryCatch(
    par.fx(pars.fit.2ps.20br.l[[i]], in.est[ix.10][[i]], verbose = FALSE, mod = "2ps", pass = FALSE),
    error = function (e) {cat("ERROR :", conditionMessage(e), "\n")})
})
names(Twops.20br.l.fits) <- names(pars.fit.2ps.20br.l)
# # 20-30
# Twops.30br.fits <- lapply(seq_along(pars.fit.2ps.30br), function(i) {
#   tryCatch(
#     par.fx(pars.fit.2ps.30br[[i]], in.est[ix.30][[i]], verbose = FALSE, mod = "2ps", pass = FALSE),
#     error = function (e) {cat("ERROR :", conditionMessage(e), "\n")})
# })
# names(Twops.30br.fits) <- names(pars.fit.2ps.30br)

## bulk 14C + stocks
# 0-10
Twops.10bs.fits <- lapply(seq_along(pars.fit.2ps.10bs), function(i) {
  tryCatch(
    par.fx(pars.fit.2ps.10bs[[i]], in.est[ix.10][[i]], verbose = FALSE, mod = "2ps", pass = FALSE),
    error = function (e) {cat("ERROR :", conditionMessage(e), "\n")})
})
names(Twops.10bs.fits) <- names(pars.fit.2ps.10bs)

## resp, bulk, stocks
# 0-10
Twops.10rbs.fits <- lapply(seq_along(pars.fit.2ps.10rbs), function(i) {
  tryCatch(
    par.fx(pars.fit.2ps.10rbs[[i]], in.est[ix.10][[i]], verbose = FALSE, mod = "2ps", pass = FALSE),
    error = function (e) {cat("ERROR :", conditionMessage(e), "\n")})
})
names(Twops.10rbs.fits) <- names(pars.fit.2ps.10rbs)
# 10-20
Twops.20rbs.fits <- lapply(seq_along(pars.fit.2ps.20rbs), function(i) {
  tryCatch(
    par.fx(pars.fit.2ps.20rbs[[i]], in.est[ix.20][[i]], verbose = FALSE, mod = "2ps", pass = FALSE),
    error = function (e) {cat("ERROR :", conditionMessage(e), "\n")})
})
names(Twops.20rbs.fits) <- names(pars.fit.2ps.20rbs)

# # remove null entries
# Twops.10b.fits <- Filter(Negate(is.null), Twops.10b.fits)
# Twops.30b.fits <- Filter(Negate(is.null), Twops.30b.fits)
# Twops.10br.fits <- Filter(Negate(is.null), Twops.10br.fits)
# Twops.30br.fits <- Filter(Negate(is.null), Twops.30br.fits)

# Look at role of resp constraint in fit
# lapply(seq_along(Twops.10b.fits), function(i) {
#   C14.2p.plot.fx(Twops.10b.fits[[i]],
#                  con.df = con.df.fx(names(Twops.10b.fits)[i]), 
#                  mod = "2ps bulk only",
#                  PMeco_depth = names(Twops.10b.fits)[i])
# })
lapply(seq_along(Twops.10br.fits), function(i) {
  C14.2p.plot.fx(Twops.10br.fits[[i]], 
                 con.df = con.df.fx(names(Twops.10br.fits)[i]), 
                 mod = "2ps bulk + resp",
                 PMeco_depth = names(Twops.10br.fits)[i])
})
# lapply(seq_along(Twops.10bs.fits), function(i) {
#   C14.2p.plot.fx(Twops.10bs.fits[[i]],
#                  con.df = con.df.fx(names(Twops.10bs.fits)[i]), 
#                  mod = "2ps bulk + stock",
#                  PMeco_depth = names(Twops.10bs.fits)[i])
# })
lapply(seq_along(Twops.10rbs.fits), function(i) {
  C14.2p.plot.fx(Twops.10rbs.fits[[i]], 
                 con.df = con.df.fx(names(Twops.10rbs.fits)[i]), 
                 mod = "bulk, resp, stock",
                 PMeco_depth = names(Twops.10rbs.fits)[i])
})
# 10-20
lapply(seq_along(Twops.20rbs.fits), function(i) {
  C14.2p.plot.fx(Twops.20rbs.fits[[i]], 
                 con.df = con.df.fx(names(Twops.20rbs.fits)[i]), 
                 mod = "bulk, resp, stock",
                 PMeco_depth = names(Twops.20rbs.fits)[i])
})
# lapply(seq_along(Twops.30b.fits), function(i) {
#   C14.2p.plot.fx(Twops.30b.fits[[i]],
#                  con.df = con.df.fx(names(Twops.30b.fits)[i]), 
#                  mod = "2ps bulk only",
#                  PMeco_depth = names(Twops.30b.fits)[i])
# })
# lapply(seq_along(Twops.30br.fits), function(i) {
#   C14.2p.plot.fx(Twops.30br.fits[[i]], 
#                  con.df = con.df.fx(names(Twops.30br.fits)[i]), 
#                  mod = "2ps bulk + resp",
#                  PMeco_depth = names(Twops.30br.fits)[i])
# })

## Show role of resp in constraining models
# GRwf 0-10
Twop.fit.plot.fx(Twops.10bs.fits[which(names(Twops.10bs.fits) == "GRwf_0-10")], 
                 "2ps 0-10cm, bulk 14c + stock", 
                 Twops.10rbs.fits[which(names(Twops.10rbs.fits) == "GRwf_0-10")],
                 "2ps 0-10cm, resp & bulk 14c + stock")
# BSrf 0-10
Twop.fit.plot.fx(Twops.10br.fits[which(names(Twops.10br.fits) == "BSrf_0-10")], 
                 "2ps 0-10cm w/ resp", 
                 Twops.10b.fits[which(names(Twops.10b.fits) == "BSrf_0-10")],
                 "2ps 0-10cm w/o resp")
Twop.fit.plot.fx(Twops.10rbs.fits[which(names(Twops.10rbs.fits) == "BSrf_0-10")],
                 "2ps 0-10cm w/ resp, bulk, stocks",
                 Twops.10bs.fits[which(names(Twops.10bs.fits) == "BSrf_0-10")],
                 "2ps 0-10cm w/o resp (bulk + stocks only)")
Twop.fit.plot.fx(Twops.10rbs.fits[which(names(Twops.10rbs.fits) == "BSwf_10-20")],
                 "Basalt/cool 10-20",
                 Twops.10rbs.fits[which(names(Twops.10rbs.fits) == "GRwf_10-20")],
                 "Granite/cool 10-20")

# compare resp + bulk fits w/ and w/o stocks
Twop.fit.plot.fx(Twops.10rbs.fits, 
                 "2ps 0-10cm w/ resp, bulk, stocks", 
                 Twops.10br.fits,
                 "2ps 0-10cm w/ resp + bulk, no stock")
# compare resp + bulk fits w/ and w/o stocks
Twop.fit.plot.fx(Twops.10bs.fits, 
                 "2ps 0-10cm, bulk 14c + stock", 
                 Twops.10rbs.fits,
                 "2ps 0-10cm, resp & bulk 14c + stock")
# compare BSwf and GRwf 10-20
BSGRwf20.con.df <- cbind(rbind(con.df.fx("BSwf_10-20"), con.df.fx("GRwf_10-20")),
                               pm = factor(rep(c("basalt", "granite"), each = c(11))))
BSGRwf20.con.df <- BSGRwf20.con.df[-which(BSGRwf20.con.df$Year == 2009.5), ]
ANGRwf20.con.df <- cbind(rbind(con.df.fx("BSwf_10-20"), con.df.fx("GRwf_10-20")),
                               pm = factor(rep(c("basalt", "granite"), each = c(11))))
BSGRwf20.con.df <- BSGRwf20.con.df[-which(BSGRwf20.con.df$Year == 2009.5), ]
atm.14c2 <- Twops.20rbs.fits$`BSwf_10-20`[Twops.20rbs.fits$`BSwf_10-20`$years >= 1950 & Twops.20rbs.fits$`BSwf_10-20`$pool == "atm", ]
# plot
p <- rbind(Twops.20rbs.fits$`BSwf_10-20`,
      Twops.20rbs.fits$`GRwf_10-20`) %>%
  mutate(pm = rep(c("basalt", "granite"), 
                  each = nrow(Twops.20rbs.fits$`BSwf_10-20`))) %>%
  filter(pool == "bulk C" | pool == "respiration") %>%
  ggplot(., aes(years, d14C)) +
  geom_path(data = atm.14c2) +
  geom_path(aes(linetype = pool, color = pm)) +
  geom_point(data = BSGRwf20.con.df, 
             aes(Year, d14c, color = pm, shape = pool), 
             size = 2.5,
             position = position_dodge(width = 1)) +
  scale_color_manual(
    name = "Parent material",
    values = c("basalt" = "red",
               "granite" = "darkgray")) +
  scale_shape_manual(
    name = "",
    values = c("bulk C" = 16,
               "respiration" = 1)) +
  scale_linetype_manual(
   name = "Pool",
   values = c("bulk C" = 1,
              "respiration" = 2)) +
  scale_x_continuous(limits = c(1950, 2022)) +
  xlab("Year") +
  ylab(expression(''*Delta*''^14*'C (‰)')) +
  theme_bw() +
  theme(panel.grid = element_blank())
ggsave("sra.2ps.BSGRwf20.pdf", p, dpi = 300, width = 6, height = 5, units = "in")
# compare resp + bulk fits w/ and w/o stocks
Twop.fit.plot.fx(Twops.20br.l.fits, 
                 "2ps 0-10cm, bulk 14c + stock", 
                 Twops.20rbs.fits,
                 "2ps 0-10cm, resp & bulk 14c + stock")
#####

# ages and transit times
#####
# 2ps
SA.2ps.20.rbs.ls <- lapply(seq_along(pars.fit.2ps.20rbs), function(i) {
  ks <- pars.fit.2ps.20rbs[[i]][1:2]
  tc <- pars.fit.2ps.20rbs[[i]][3]
  In <- in.est[ix.20][[i]]
  A <- diag(-ks)
  A[2, 1] <- tc * ks[1]
  return(systemAge(A = A, u = c(In, 0)))
})
names(SA.2ps.20.rbs.ls) <- names(pars.fit.2ps.20rbs)
lapply(SA.2ps.20.rbs.ls, "[[", 1)

## Transit time
# 2ps
TT.2ps.20.rbs.ls <- lapply(seq_along(pars.fit.2ps.20rbs), function(i) {
  ks <- pars.fit.2ps.20rbs[[i]][1:2]
  tc <- pars.fit.2ps.20rbs[[i]][3]
  In <- in.est[ix.20][[i]]
  A <- diag(-ks)
  A[2, 1] <- tc * ks[1]
  return(transitTime(A = A, u = c(In, 0)))
})
names(TT.2ps.20.rbs.ls) <- names(pars.fit.2ps.20rbs)
lapply(TT.2ps.20.rbs.ls, "[[", 1)
# 0-10
TT.MA.2ps.10.rbs.ls <- lapply(seq_along(pars.fit.2ps.10rbs), function(i) {
  ks <- pars.fit.2ps.10rbs[[i]][1:2]
  tc <- pars.fit.2ps.10rbs[[i]][3]
  In <- in.est[ix.10][[i]]
  A <- diag(-ks)
  A[2, 1] <- tc * ks[1]
  TT <- transitTime(A = A, u = c(In, 0))
  Age <- systemAge(A = A, u = c(In, 0))
  return(list(TT = TT$meanTransitTime, Age = Age$meanSystemAge))
})
names(TT.MA.2ps.10.rbs.ls) <- names(pars.fit.2ps.10rbs)
lapply(TT.MA.2ps.10.rbs.ls, unlist)
# 
ageD.2ps.10.rbs.ls <- lapply(seq_along(pars.fit.2ps.10rbs), function(i) {
  ks <- pars.fit.2ps.10rbs[[i]][1:2]
  tc <- pars.fit.2ps.10rbs[[i]][3]
  In <- in.est[ix.10][[i]]
  A <- diag(-ks)
  A[2, 1] <- tc * ks[1]
  return(systemAge(A = A, u = c(In, 0)))
})
names(ageD.2ps.10.rbs.ls) <- names(pars.fit.2ps.10rbs)
```

```{r modFit-2p-comparison}
# compare output of 2pp and 2ps model fits
merge(ssr.2pp.df, ssr.2ps.df, by = "PMeco_depth", suffixes = c("_2pp", "_2ps")) %>%
  mutate(ssr_2pp = round(ssr_2pp, 1),
         ssr_2ps = round(ssr_2ps, 1),
         dif = ssr_2pp - ssr_2ps)
merge(var_ms.2pp.df,
      var_ms.2ps.df,
      by = c("PMeco_depth", "var"),
      suffixes = c("_2pp", "_2ps")) %>%
  mutate(var_ms_2pp = round(var_ms_2pp, 4),
         var_ms_2ps = round(var_ms_2ps, 4),
         dif = var_ms_2pp - var_ms_2ps)

## Plot
# SSR, PM
rbind(ssr.2pp.df, ssr.2ps.df) %>%
  mutate(mod = rep(c("2pp", "2ps"), each = nrow(ssr.2pp.df)),
         PM = substr(PMeco_depth, 1, 2),
         eco = substr(PMeco_depth, 3, 4)) %>%
  group_by(PM, mod) %>%
  summarize(mean.ssr = mean(ssr), sd = sd(ssr)) %>%
  mutate(err_u = mean.ssr + sd/sqrt(3),
         err_l = mean.ssr - sd/sqrt(3)) %>%
  ggplot(., aes(mod, mean.ssr, fill = PM)) +
  geom_col(position = "dodge") +
  geom_errorbar(
    aes(ymax = err_u, ymin = err_l), 
    position = position_dodge(width = .9),
    width = .3) +
  scale_fill_manual(name = "Parent material",
                    labels = c("AN" = "andesite",
                               "BS" = "basalt",
                               "GR" = "granite"),
                    values = c("AN" = "blue", 
                               "BS" = "red", 
                               "GR" = "darkgray")) +
  facet_wrap(. ~ PM) +
  ggtitle("SSR 2-pool models 0-10 cm") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
# SSR, eco
rbind(ssr.2pp.df, ssr.2ps.df) %>%
  mutate(mod = rep(c("2pp", "2ps"), each = nrow(ssr.2pp.df)),
         PM = substr(PMeco_depth, 1, 2),
         eco = substr(PMeco_depth, 3, 4)) %>%
  group_by(eco, mod) %>%
  summarize(mean.ssr = mean(ssr), sd = sd(ssr)) %>%
  mutate(err_u = mean.ssr + sd/sqrt(3),
         err_l = mean.ssr - sd/sqrt(3)) %>%
  ggplot(., aes(mod, mean.ssr, fill = eco)) +
  geom_col(position = "dodge") +
  geom_errorbar(
    aes(ymax = err_u, ymin = err_l), 
    position = position_dodge(width = .9),
    width = .3) +
  facet_wrap(. ~ eco) +
  ggtitle("SSR 2-pool models 0-10 cm (eco)") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())

# var_ms, PM
rbind(var_ms.2pp.df, var_ms.2ps.df) %>%
  mutate(mod = rep(c("2pp", "2ps"), each = nrow(var_ms.2pp.df)),
         PM = substr(PMeco_depth, 1, 2),
         eco = substr(PMeco_depth, 3, 4)) %>%
  group_by(var, PM, mod) %>%
  summarize(mean.var_ms = mean(var_ms), sd = sd(var_ms)) %>%
  mutate(err_u = mean.var_ms + sd/sqrt(3),
         err_l = mean.var_ms - sd/sqrt(3)) %>%
  ggplot(., aes(mod, mean.var_ms, fill = PM)) +
  geom_col(position = "dodge") +
  geom_errorbar(
    aes(ymax = err_u, ymin = err_l), 
    position = position_dodge(width = .9),
    width = .3) +
  scale_fill_manual(name = "Parent material",
                    labels = c("AN" = "andesite",
                               "BS" = "basalt",
                               "GR" = "granite"),
                    values = c("AN" = "blue", 
                               "BS" = "red", 
                               "GR" = "darkgray")) +
  facet_wrap(. ~ var, scales = "free") +
  ggtitle("Residual error 2-pool models 0-10 cm") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
# var_ms, eco
rbind(var_ms.2pp.df, var_ms.2ps.df) %>%
  mutate(mod = rep(c("2pp", "2ps"), each = nrow(var_ms.2pp.df)),
         PM = substr(PMeco_depth, 1, 2),
         eco = substr(PMeco_depth, 3, 4)) %>%
  group_by(var, eco, mod) %>%
  summarize(mean.var_ms = mean(var_ms), sd = sd(var_ms)) %>%
  mutate(err_u = mean.var_ms + sd/sqrt(3),
         err_l = mean.var_ms - sd/sqrt(3)) %>%
  ggplot(., aes(mod, mean.var_ms, fill = eco)) +
  geom_col(position = "dodge") +
  geom_errorbar(
    aes(ymax = err_u, ymin = err_l), 
    position = position_dodge(width = .9),
    width = .3) +
  facet_wrap(. ~ var, scales = "free") +
  ggtitle("Residual error 2-pool models 0-10 cm") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```

```{r ages-tt-modFit}
## System age
# 2pp
SA.2pp.ls <- lapply(seq_along(pars.fit.2pp), function(i) {
  ks <- pars.fit.2pp[[i]][1:2]
  gam <- pars.fit.2pp[[i]][3]
  In <- in.fit.2pp[[i]]
  return(systemAge(, u = In))
})
names(SA.2pp.ls) <- names(pars.fit.2pp)
# 2pp gam = [.5, .95]
SA.2pp.p3.5.95.ls <- lapply(seq_along(pars.fit.2pp.p3.5.95), function(i) {
  ks <- pars.fit.2pp.p3.5.95[[i]][1:2]
  gam <- pars.fit.2pp.p3.5.95[[i]][3]
  In <- in.fit.2pp.p3.5.95[[i]]
  return(systemAge(A = -1 * diag(ks), u = c(In * gam, In * (1 - gam))))
})
names(SA.2pp.p3.5.95.ls) <- names(pars.fit.2pp.p3.5.95)
# 2ps
SA.2ps.ls <- lapply(seq_along(pars.fit.2ps), function(i) {
  ks <- pars.fit.2ps[[i]][1:2]
  gam <- pars.fit.2ps[[i]][3]
  In <- in.fit.2ps[[i]]
  return(systemAge(A = -1 * diag(ks), u = c(In * gam, In * (1 - gam))))
})
names(SA.2ps.ls) <- names(pars.fit.2ps)

## Transit time
# 2pp
TT.2pp.ls <- lapply(seq_along(pars.fit.2pp), function(i) {
  ks <- pars.fit.2pp[[i]][1:2]
  gam <- pars.fit.2pp[[i]][3]
  In <- in.fit.2pp[[i]]
  return(transitTime(A = -1 * diag(ks), u = c(In * gam, In * (1 - gam))))
})
names(TT.2pp.ls) <- names(pars.fit.2pp)
# 2pp gam = [.5, .95]
TT.2pp.p3.5.95.ls <- lapply(seq_along(pars.fit.2pp.p3.5.95), function(i) {
  ks <- pars.fit.2pp.p3.5.95[[i]][1:2]
  gam <- pars.fit.2pp.p3.5.95[[i]][3]
  In <- in.fit.2pp.p3.5.95[[i]]
  return(transitTime(A = -1 * diag(ks), u = c(In * gam, In * (1 - gam))))
})
names(TT.2pp.p3.5.95.ls) <- names(pars.fit.2pp.p3.5.95)
# 2ps
TT.2ps.ls <- lapply(seq_along(pars.fit.2ps), function(i) {
  ks <- pars.fit.2ps[[i]][1:2]
  gam <- pars.fit.2ps[[i]][3]
  In <- in.fit.2ps[[i]]
  return(transitTime(A = -1 * diag(ks), u = c(In * gam, In * (1 - gam))))
})
names(TT.2ps.ls) <- names(pars.fit.2ps)
```

```{r SA-TT-comp}
# compare ages and transit times among the two model structures
SA.2p.ls <- list(SA.2pp.ls, SA.2ps.ls, SA.2pp.p3.5.95.ls)
SA.df <- bind_rows(
  lapply(SA.2p.ls, function(ls) {
    lapply(seq_along(ls), function(i) {
      data.frame(age = c(ls[[i]][["meanSystemAge"]],
                         ls[[i]][["meanPoolAge"]]),
                 component = c("system", "fast pool", "slow pool"))
    })
  })
)
SA.df$PMeco_depth <- rep(names(SA.2pp.ls), each = 3, times = length(SA.2p.ls))
SA.df$Model <- rep(c("2pp", "2ps", "2pp [.5, .95]"), each = 27)
TT.2p.ls <- list(TT.2pp.ls, TT.2ps.ls, TT.2pp.p3.5.95.ls)
TT.df <- bind_rows(
  lapply(TT.2p.ls, function(ls) {
    lapply(seq_along(ls), function(i) {
     data.frame(age = ls[[i]][["meanTransitTime"]],
                component = "transit")
    })
  })
)
TT.df$PMeco_depth <- rep(names(TT.2pp.ls), times = length(TT.2p.ls))
TT.df$Model <- rep(c("2pp", "2ps", "2pp [.5, .95]"), each = 9)
SA.TT.df <- rbind(SA.df, TT.df)
SA.TT.df$PM <- substr(SA.TT.df$PMeco_depth, start = 1, stop = 2)
SA.TT.df$eco <- substr(SA.TT.df$PMeco_depth, start = 3, stop = 4)

## Plot ages and transit times
# by PM
SA.TT.df %>%
  select(!c(PMeco_depth, eco)) %>%
  group_by(component, PM, Model) %>%
  summarize_all(list(mean_age = mean, sd = sd)) %>%
  mutate(err_u = mean_age + sd,
         err_l = mean_age - sd) %>%
  ggplot(., aes(Model, mean_age, fill = PM)) +
  geom_col(position = "dodge") +
  # geom_errorbar(
  #   aes(ymax = err_u, ymin = err_l), 
  #   position = position_dodge(width = .9),
  #   width = .3) +
  scale_fill_manual(name = "Parent material",
                    labels = c("AN" = "andesite",
                               "BS" = "basalt",
                               "GR" = "granite"),
                    values = c("AN" = "blue", 
                               "BS" = "red", 
                               "GR" = "darkgray")) +
  facet_wrap(. ~ component, scales = "free") +
  ylab("mean age") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
# by eco
SA.TT.df %>%
  select(!c(PMeco_depth, PM)) %>%
  group_by(component, eco, Model) %>%
  summarize_all(list(mean_age = mean, sd = sd)) %>%
  mutate(err_u = mean_age + sd,
         err_l = mean_age - sd) %>%
  ggplot(., aes(Model, mean_age, fill = eco)) +
  geom_col(position = "dodge") +
  # geom_errorbar(
  #   aes(ymax = err_u, ymin = err_l),
  #   position = position_dodge(width = .9),
  #   width = .3) +
  facet_wrap(. ~ component, scales = "free") +
  ylab("mean age") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```

### Bayesian parameter estimation (MCMC)

```{r MCMC-fits, eval = FALSE}
# the following .RData files are generated by script "sra-ts/source/sra-ts-mcmc-bayes.R"
load(file = "../data/derived/bayes-par-fit-2020-11-06/bayes_fit_2pp_0-10_5000iter.RData")
load(file = "../data/derived/bayes-par-fit-2020-11-17/bayes_fit_2ps_0-10_5000iter.RData")

# # plot parameter convergence
# lapply(bayes_fit_2pp_0_10, plot)
# lapply(bayes_fit_2ps_0_10, plot)

# plot collinearity
iter <- 5000
lapply(bayes_fit_2pp_0_10, pairs, nsample = floor(iter/4))
lapply(bayes_fit_2ps_0_10, pairs, nsample = floor(iter/4))

## look at model performance
pars.bayes.df.fx <- function(mod, pars.bayes, pars.fit) {
  bind_rows(lapply(seq_along(pars.bayes), function(i) {
    ix <- match(unique(pars.bayes[[i]][["pars"]][, 1]), pars.bayes[[i]][["pars"]][, 1])
    df <- data.frame(k1 = pars.bayes[[i]][["pars"]][ix, 1],
                     k2 = pars.bayes[[i]][["pars"]][ix, 2],
                     p3 = pars.bayes[[i]][["pars"]][ix, 3])
    df <- cbind(df,
                PMeco_depth = rep(names(pars.fit)[i], length(ix)),
                mod = rep(mod, length(ix)))
    df <- cbind(df, 
                PM = factor(substr(df$PMeco_depth, 1, 2)),
                eco = factor(substr(df$PMeco_depth, 3, 4), levels = c("pp", "wf", "rf")))
    return(df)
  }))
}
pars.bayes.2pp.df <- pars.bayes.df.fx("2pp", bayes_fit_2pp_0_10, pars.fit.2pp)
pars.bayes.2ps.df <- pars.bayes.df.fx("2ps", bayes_fit_2ps_0_10, pars.fit.2ps)

# # linear fits
# summary(lm(k2 ~ PM, pars.bayes.2pp.df))
# summary(lm(k2 ~ eco, pars.bayes.2pp.df))
# summary(lm(k1 ~ PM, pars.bayes.2pp.df))
# summary(lm(k1 ~ eco, pars.bayes.2pp.df))
# summary(lm(p3 ~ PM, pars.bayes.2pp.df))
# summary(lm(p3 ~ eco, pars.bayes.2pp.df))

# best par set
bestPars.bayes.ls <- lapply(bayes_fit_2pp_0_10, function(x) {
  round(data.frame(k1 = x$bestpar[1],
                   k2 = x$bestpar[2],
                   gam = x$bestpar[3]),
        4)
})
bestPars.bayes.df <- cbind(PM = rep(c("AN", "BS", "GR"), each = 3),
                           eco = rep(c("pp", "rf", "wf"), 3),
                           depth = rep("0-10", 9),
                           bind_rows(bestPars.bayes.ls))

# summarize by PM
pars.bayes.PM <- bestPars.bayes.df %>%
  select(!c(eco, depth)) %>%
  group_by(PM) %>%
  summarize_all(list(mean = mean, sd = sd)) %>%
  mutate_if(is.numeric, format, digits = 3)
# summarize by ECO
pars.bayes.eco <- bestPars.bayes.df %>%
  select(!c(PM, depth)) %>%
  group_by(eco) %>%
  summarize_all(list(mean = mean, sd = sd)) %>%
  mutate_if(is.numeric, format, digits = 3)

# plot best pars
bestPars.bayes.df %>%
  pivot_longer(!(PM:depth), names_to = "par", values_to = "value") %>%
  mutate(PM = factor(PM),
         eco = factor(eco, levels = c("pp", "wf", "rf"))) %>%
  ggplot(., aes(par, value, color = PM, shape = eco)) +
  geom_jitter(size = 4) +
  scale_color_manual(name = "parent material",
                    labels = c("AN" = "andesite",
                               "BS" = "basalt",
                               "GR" = "granite"),
                    values = c("AN" = "blue", 
                               "BS" = "red", 
                               "GR" = "darkgray")) +
  facet_wrap(. ~ par, scales = "free") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())

# plot accepted pars by PM and then by eco
pars.bayes.df %>%
  pivot_longer(!c(PM, eco, PMeco_depth), names_to = "par", values_to = "value") %>%
  mutate(PM = factor(PM),
         eco = factor(eco, levels = c("pp", "wf", "rf"))) %>%
  ggplot(., aes(par, value, fill = PM)) +
  geom_boxplot() +
  scale_fill_manual(name = "parent material",
                    labels = c("AN" = "andesite",
                               "BS" = "basalt",
                               "GR" = "granite"),
                    values = c("AN" = "blue", 
                               "BS" = "red", 
                               "GR" = "darkgray")) +
  facet_wrap(. ~ par, scales = "free") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
pars.bayes.df %>%
  pivot_longer(!c(PM, eco, PMeco_depth), names_to = "par", values_to = "value") %>%
  mutate(PM = factor(PM),
         eco = factor(eco, levels = c("pp", "wf", "rf"))) %>%
  ggplot(., aes(par, value, fill = eco)) +
  geom_boxplot() +
  facet_wrap(. ~ par, scales = "free") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```