---
title: "Sierra Nevada Time Series"
author: "J. Beem-Miller"
date: "21 Oct 2020"
output:
  pdf_document:
    latex_engine: xelatex
  html_notebook:
    toc: yes
    toc_depth: 2
    css: custom.css
header_includes:
  - \usepackage[utf8]{inputenc}
  - \usepackage{float}
---
```{r global_options, include = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE,
                      fig.align = 'center', dev = 'cairo_pdf')
```

```{r setup, include = FALSE}
library(ggplot2)
library(dplyr)
# suppress grouping information message
options(dplyr.summarise.inform = FALSE)
library(ISRaD)
library(GSIF)
library(aqp)
library(SoilR)
library(FME)
library(tidyr)
```

# Data preparation script for Sierra Nevada time series analysis

```{r load ams-jena-ingest fx}
# 1. Read in isotope data from various sources
# First load helper functions 'read_jena_ams_results.R', 'read_jena_iso_results.R' 
source("./utilities/jena_ams_ingest.R")
source("./utilities/jena_iso_ingest.R")
source("./utilities/jena_elm_ingest.R")
```

```{r read-cn-iso-data, include = FALSE}
# 2. Next read in data from the appropriate directories in 'data/raw'
# 14C
# identify subdirectories in 'raw' directory with "ams_jena" in name
ams_jena_results_dirs <- list.files("../data/raw", pattern = "ams_jena_results", full.names = TRUE)
ams_results_ls <- lapply(seq_along(ams_jena_results_dirs), function(i) {
  read_jena_ams_results(ams_jena_results_dirs[i])
})
names(ams_results_ls) <- list.files("../data/raw", pattern = "ams_jena_results")

# # 13C
# # identify subdirectories in 'raw' directory with "iso_jena" in name
# iso_jena_results_dirs <- list.files("../data/raw", pattern = "iso_jena_results", full.names = TRUE)
# iso_results_ls <- lapply(seq_along(iso_jena_results_dirs), function(i) {
#   read_jena_iso_results(iso_jena_results_dirs[i])
# })
# names(iso_results_ls) <- list.files("../data/raw", pattern = "iso_jena_results")

# Read in C and N data
elm_results_dir <- list.files("../data/raw", pattern = "elm_jena_results", full.names = TRUE)
elm_results_ls <- lapply(seq_along(elm_results_dir), function(i) {
  read_jena_elm_results(elm_results_dir[i])
})
names(elm_results_ls) <- list.files("../data/raw", pattern = "elm_jena_results")
```

```{r data-template}
# Create template for bulk soil data
template19.fx <- function(pm, eco, ndepth) {
  df <- data.frame(Year = rep(2019, ndepth * 3),
                   PM = rep(pm, ndepth * 3),
                   ECO = rep(eco, ndepth * 3),
                   pro_rep = rep(seq(1,3), each = ndepth),
                   lyr_top = rep(seq(0, (ndepth-1) * 10, by = 10), 3),
                   lyr_bot = rep(seq(10, (ndepth) * 10, by = 10), 3))
  df$pro_name <- paste0(df$PM, df$ECO, "_", df$pro_rep)
  df$lyr_name <- paste0(df$pro_name, "_", df$lyr_top, "-", df$lyr_bot)
  return(df)
}

# Create template for composite soil data (incubations, density fractions, etc.)
template19.comp.fx <- function(pm, eco, ndepth) {
  df <- data.frame(Year = rep(2019, 3),
                   PM = rep(pm, 3),
                   ECO = rep(eco, 3),
                   lyr_top = rep(seq(0, (ndepth-1) * 10, by = 10)),
                   lyr_bot = rep(seq(10, (ndepth) * 10, by = 10)))
  df$pro_name <- paste0(df$PM, df$ECO, "_comp")
  df$lyr_name <- paste0(df$pro_name, "_", df$lyr_top, "-", df$lyr_bot)
  return(df)
}

# templates for bulk soil data
# GRrf 
GRrf <- template19.fx("GR", "rf", 7)
GRrf <- if(any(GRrf$lyr_name == "GRrf_1_60_70")) {
  GRrf <- GRrf[-which(GRrf$lyr_name == "GRrf_1_60_70"), ] # NB: GRrf_1_60_70 doesn't exist
} else {
  GRrf <- GRrf
}
# GRwf
GRwf <- template19.fx("GR", "wf", 9)
# GRpp
GRpp <- template19.fx("GR", "pp", 8)

# ANrf 
ANrf <- template19.fx("AN", "rf", 6)
# ANwf
ANwf <- template19.fx("AN", "wf", 6)
# ANpp
ANpp <- template19.fx("AN", "pp", 8)

# BSrf 
BSrf <- template19.fx("BS", "rf", 8)
BSrf <- if(any(BSrf$lyr_name == "GRrf_1_60_70")) {
  BSrf <- BSrf[-which(BSrf$lyr_name == "BSrf_1_70_80"), ] # NB: BSrf_1_70_80 doesn't exist
} else {
  BSrf <- BSrf
} 
# BSwf
BSwf <- template19.fx("BS", "wf", 7)
# BSpp
BSpp <- template19.fx("BS", "pp", 8)
BSpp[BSpp$lyr_bot == 80, "lyr_bot"] <- 75 # only sampled to 75cm, not 80

sra.2019.df <- rbind(GRrf, GRwf, GRpp,
                     ANrf, ANwf, ANpp,
                     BSrf, BSwf, BSpp)

# template for 2019 incubation data
GRrf_inc <- template19.comp.fx("GR", "rf", 3)
GRwf_inc <- template19.comp.fx("GR", "wf", 3)
GRpp_inc <- template19.comp.fx("GR", "pp", 3)

ANrf_inc <- template19.comp.fx("AN", "rf", 3)
ANwf_inc <- template19.comp.fx("AN", "wf", 3)
ANpp_inc <- template19.comp.fx("AN", "pp", 3)

BSrf_inc <- template19.comp.fx("BS", "rf", 3)
BSwf_inc <- template19.comp.fx("BS", "wf", 3)
BSpp_inc <- template19.comp.fx("BS", "pp", 3)

sra.2019.inc.df <- rbind(GRrf_inc, GRwf_inc, GRpp_inc,
                         ANrf_inc, ANwf_inc, ANpp_inc,
                         BSrf_inc, BSwf_inc, BSpp_inc)

# 2001 bulk soil template
sra.2001 <- vector(mode = "list", length = length(unique(sra.2019.df$pro_name)))
names(sra.2001) <- unique(sra.2019.df$pro_name)

# 2009 data (from C. Rasmussen)
ras18.lyr <- read.csv("/Users/jeff/R/14Constraint/ras_2018.csv")
ras18.lyr$ECO <- factor(ras18.lyr$MAST, labels = c("rf","wf","pp"))

# 2019 bulk soil template
sra.2019 <- sra.2001

# 2019 inc template
sra.2019.inc <- vector(mode = "list", length = length(unique(sra.2019.inc.df$pro_name)))
names(sra.2019.inc) <- unique(sra.2019.inc.df$pro_name)
# copies for reps of incubations
sra.2019.inc_1 <- sra.2019.inc
sra.2019.inc_2 <- sra.2019.inc
```

*Merge templates with 14C, C, and N data*

Radiocarbon analyses for the 2001 samples were not run originally, but were completed on archived samples in 2020.

```{r merge-iso-data-S01-soil}
# Extract 14C data for 2001 samples
ams_results_ls_S01 <- ams_results_ls[grep("S01", names(ams_results_ls))]
for(i in seq_along(sra.2001)) {
  sra.2001[[i]] <- lapply(ams_results_ls_S01, function(ls) {
    lapply(ls, function(df) {
      if(any(grepl(names(sra.2001)[i], df$Probe))) {
       df[grep(names(sra.2001)[i], df$Probe), ] 
      }
    })
  })
  sra.2001[[i]] <- Filter(Negate(is.null), unlist(sra.2001[[i]], recursive = FALSE))
}
sra.2001 <- bind_rows(unlist(sra.2001, recursive = FALSE))

# create ID field, trim df, and add depths
sra.2001$ID <- unlist(strsplit(sra.2001$Probe, "_Sierra Nevada_2001"))
sra.2001 <- sra.2001[ , c("ID", "F14C", "err", "∆14C.(‰)", "err.(‰)")]
names(sra.2001) <- c("ID", "fm", "fm_err", "d14c", "d14c_err")
sra.2001$lyr_top <- as.numeric(ifelse(substr(sra.2001$ID, 9, 9) == "-",
                                      substr(sra.2001$ID, 8, 8),
                                      substr(sra.2001$ID, 8, 9)))
sra.2001$lyr_bot <- as.numeric(ifelse(substr(sra.2001$ID, 9, 9) == "-", 
                                      substr(sra.2001$ID, 10, nchar(sra.2001$ID)),
                                      substr(sra.2001$ID, 11, nchar(sra.2001$ID))))
sra.2001$pro_rep <- substr(sra.2001$ID, 6, 6)
sra.2001$PM <- factor(substr(sra.2001$ID, 1, 2))
sra.2001$ECO <- factor(substr(sra.2001$ID, 3, 4), levels = c("pp", "wf", "rf"))
sra.2001$pro_name <- substr(sra.2001$ID, 1, 6)
sra.2001$PMeco <- substr(sra.2001$ID, 1, 4)

# remove outlier ANpp sample
sra.2001 <- sra.2001[-which(sra.2001$ID == "ANpp_3_6-13"), ]

# make list by PMeco
sra.2001.ls <- split(sra.2001, sra.2001$PMeco)
```

```{r merge-iso-data-soil-S19}
# Extract 14C data for 2019 samples
ams_results_ls_S19 <- ams_results_ls[grep("soil-S19", names(ams_results_ls))]
for(i in seq_along(sra.2019)) {
  sra.2019[[i]] <- lapply(ams_results_ls_S19, function(ls) {
    lapply(ls, function(df) {
      if(any(grepl(names(sra.2019)[i], df$Probe))) {
       df[grep(names(sra.2019)[i], df$Probe), ] 
      }
    })
  })
  sra.2019[[i]] <- Filter(Negate(is.null), unlist(sra.2019[[i]], recursive = FALSE))
}
sra.2019 <- bind_rows(unlist(sra.2019, recursive = FALSE))

## merge w/ 2019 template
# rename cols in AMS tables
sra.2019 <- sra.2019[ , c("Probe", "F14C", "err", "∆14C.(‰)", "err.(‰)")]
names(sra.2019) <- c("ID", "fm", "fm_err", "d14c", "d14c_err")
# merge
sra.2019.ls <- lapply(split(sra.2019.df, sra.2019.df$lyr_name), function(df) {
  df <- merge(df, sra.2019[grep(df$lyr_name, sra.2019$ID), ])
  df$ID <- NULL
  df$PMeco <- paste0(df$PM, df$ECO)
  return(df)
})

# reshape list by PMeco
sra.2019.ls <- split(bind_rows(sra.2019.ls), bind_rows(sra.2019.ls)[["PMeco"]])
```

```{r merge-iso-data-co2-S19}
# Extract 14C data for 2019 samples
# rep 1 data
ams_results_ls_co2_S19_1 <- ams_results_ls[grep("co2-S19-1", names(ams_results_ls))]
for(i in seq_along(sra.2019.inc)) {
  sra.2019.inc_1[[i]] <- lapply(ams_results_ls_co2_S19_1, function(ls) {
    lapply(ls, function(df) {
      if(any(grepl(names(sra.2019.inc)[i], df$Probe))) {
       df[grep(names(sra.2019.inc)[i], df$Probe), ] 
      }
    })
  })
  sra.2019.inc_1[[i]] <- Filter(Negate(is.null), unlist(sra.2019.inc_1[[i]], recursive = FALSE))
}
sra.2019.inc_1 <- bind_rows(unlist(sra.2019.inc_1, recursive = FALSE))

## merge w/ 2019 template
# rename cols in AMS tables
sra.2019.inc_1 <- sra.2019.inc_1[ , c("Probe", "F14C", "err", "∆14C.(‰)", "err.(‰)")]
names(sra.2019.inc_1) <- c("ID", "fm", "fm_err", "d14c", "d14c_err")
# merge
sra.2019.inc.ls_1 <- lapply(split(sra.2019.inc.df, sra.2019.inc.df$lyr_name), function(df) {
  df <- merge(df, sra.2019.inc_1[grep(df$lyr_name, sra.2019.inc_1$ID), ])
  df$ID <- NULL
  df$PMeco <- paste0(df$PM, df$ECO)
  return(df)
})

# reshape list by PMeco
sra.2019.inc.ls_1 <- split(bind_rows(sra.2019.inc.ls_1), bind_rows(sra.2019.inc.ls_1)[["PMeco"]])
```

```{r plot-2001-profiles, include = FALSE}
pro.plot <- function(df, maxDepth, min14C, rep) {
  ggplot(df, aes(d14c, lyr_bot, color = PM, shape = ECO, group = rep)) +
    geom_vline(xintercept = 0) +
    geom_hline(yintercept = 0) +
    geom_point(size = 3) +
    geom_path() +
    scale_y_reverse(limits = c(maxDepth, 0)) +
    scale_x_continuous(limits = c(min14C, 180)) +
    scale_color_manual(name = "parent material",
                       labels = c("AN" = "andesite",
                                  "BS" = "basalt",
                                  "GR" = "granite"),
                       values = c("AN" = "blue", 
                                  "BS" = "red", 
                                  "GR" = "darkgray")) +
    scale_shape_manual(name = "ecosystem",
                       labels = c("pp" = expression(italic("P. ponderosa")),
                                  "rf" = expression(italic("A. magnifica")),
                                  "wf" = expression(italic("A. concolor"))),
                       values = c("pp" = 15, 
                                  "rf" = 16, 
                                  "wf" = 17)) +
    xlab(expression(Delta*''^14*'C (‰)')) +
    ylab("Depth (cm)") +
    theme_bw() +
    theme(panel.grid.minor = element_blank())
}

# lapply(sra.2001.ls, function(df) pro.plot(df, max(df$lyr_bot), min(df$d14c), df$pro_rep))
```

```{r plot-2019-profiles, include = FALSE}
# lapply(sra.2019.ls, function(df) pro.plot(df, max(df$lyr_bot), min(df$d14c), df$pro_rep))
```

```{r plot-2019-co2-profiles, include = FALSE}
# lapply(sra.2019.inc.ls_1, function(df) pro.plot(df, max(df$lyr_bot), min(df$d14c), NA))
```

## 2001 mean radiocarbon profiles
```{r plot-2001-avg-profiles}
# fm and d14c conversion functions
lambda <- 1/8267 # = 1/(true mean life of 14C)
calc_fm <- function(d14c, obs_date_y) {
  ((d14c/1000) + 1)/exp(lambda * (1950 - obs_date_y))
}
calc_14c <- function(fm, obs_date_y) {
  (fm * exp(lambda * (1950 - obs_date_y)) - 1) * 1000
}

# calc atm in 2001, 2009, 2019
Datm <- rbind(graven, future14C)
atm.d14.2001 <- Datm[Datm$Date == 2001.5, "NHc14"]
atm.fm.2001 <- calc_fm(atm.d14.2001, 2001)
atm.d14.2009 <- Datm[Datm$Date == 2009.5, "NHc14"]
atm.fm.2009 <- calc_fm(atm.d14.2009, 2009)
atm.d14.2019 <- Datm[Datm$Date == 2019.5, "NHc14"]
atm.fm.2019 <- calc_fm(atm.d14.2019, 2019)

# combine reps
sra.2001.sum.ls  <- lapply(sra.2001.ls, function(df) {
  df <- data.frame(df %>%
                     filter(lyr_bot <= 40) %>%
                     mutate(lyr_top_ch = as.character(lyr_top),
                            lyr_bot_ch = as.character(lyr_bot)) %>%
                     select(PM, ECO, PMeco, fm, d14c, lyr_top_ch, lyr_bot_ch) %>%
                     group_by(PM, ECO, PMeco, lyr_top_ch, lyr_bot_ch) %>%
                     summarize_all(list(mean = mean, sd = sd), na.rm = TRUE))
  names(df) <- c("PM", "ECO", "PMeco", "lyr_top", "lyr_bot", "fm", "d14c", "fm_sd", "d14c_sd")
  df$lyr_top <- as.numeric(df$lyr_top)
  df$lyr_bot <- as.numeric(df$lyr_bot)
  return(df)
})
sra.01.sum <- bind_rows(sra.2001.sum.ls)
sra.01.sum <- sra.01.sum[order(sra.01.sum$lyr_bot), ]

sra.01.sum <- sra.01.sum %>%
  mutate(d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite")))

# plot
fig.n <- 1
sra.01.sum %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = eco, group = PMeco)) +
  geom_vline(xintercept = atm.d14.2001) +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  geom_path() +
  scale_y_reverse(limits = c(40, 0)) +
  scale_x_continuous(limits = c(-100, 180)) +    
  scale_color_manual(name = "parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Mean profile $\Delta$^14^C for 2001 samples**

>*Caption:* Mean $\Delta$^14^C by depth for each site in 2001. Error bars show ±1 standard deviation, solid vertical line shows $\Delta$^14^C of the atmosphere in the year of sampling.

## 2009 radiocarbon profiles
```{r plot-2009-profiles}
# add PMeco col
ras18.lyr$ECO <- factor(ras18.lyr$MAST, labels = c("rf","wf","pp"))
ras18.lyr$PMeco <- paste0(ras18.lyr$PM, ras18.lyr$ECO)

sra.09.sum <- ras18.lyr %>%
  mutate(eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite")))

fig.n <- fig.n + 1
sra.09.sum %>%
  ggplot(., aes(lyr_14c, lyr_bot, color = pm, shape = eco, group = PMeco)) +
  geom_vline(xintercept = atm.d14.2009) +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_path(linetype = "dashed") +
  scale_y_reverse() +
  scale_x_continuous(limits = c(-100, 180)) +    
  scale_color_manual(name = "parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "ecosystem",
                     values = c("warm" = 0, 
                                "cool" = 1, 
                                "cold" = 2)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Profile $\Delta$^14^C for 2009 samples**

>*Caption:* Profile $\Delta$^14^C by depth for each site in 2009. Solid vertical line shows $\Delta$^14^C of the atmosphere in the year of sampling. Error bars not shown as only a single replicate profile was analyzed per site.

## 2019 mean radiocarbon profiles
```{r plot-2019-avg-profiles}
# combine reps
sra.2019.sum.ls  <- lapply(sra.2019.ls, function(df) {
  df <- data.frame(df %>%
                     mutate(lyr_top_ch = as.character(lyr_top),
                            lyr_bot_ch = as.character(lyr_bot)) %>%
                     select(PM, ECO, PMeco, fm, d14c, lyr_top_ch, lyr_bot_ch) %>%
                     group_by(PM, ECO, PMeco, lyr_top_ch, lyr_bot_ch) %>%
                     summarize_all(list(mean = mean, sd = sd), na.rm = TRUE))
  names(df) <- c("PM", "ECO", "PMeco", "lyr_top", "lyr_bot", "fm", "d14c", "fm_sd", "d14c_sd")
  df$lyr_top <- as.numeric(df$lyr_top)
  df$lyr_bot <- as.numeric(df$lyr_bot)
  return(df)
})
sra.19.sum <- bind_rows(sra.2019.sum.ls)

sra.19.sum <- sra.19.sum %>%
  mutate(d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) 

# plot
fig.n <- fig.n + 1
sra.19.sum %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = eco, group = PMeco)) +
  geom_vline(xintercept = atm.d14.2019) +
  geom_hline(yintercept = 0) +
  geom_point(size = 2.7) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  geom_path() +
  scale_y_reverse(limits = c(max(sra.19.sum$lyr_bot), 0)) +
  scale_x_continuous(limits = c(min(sra.19.sum$d14c), 180)) +    
  scale_color_manual(name = "parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Mean profile $\Delta$^14^C for 2019 samples**

>*Caption:* Mean $\Delta$^14^C by depth for each site in 2019. Error bars show ±1 standard deviation, solid vertical line shows $\Delta$^14^C of the atmosphere in the year of sampling.

## Change in $\Delta$^14^C over time between 2001 and 2019 

```{r plot-all-avg}
# combine '01 and '19 data for plotting
sra.01.sum$Year <- 2001
sra.19.sum$Year <- 2019

sra.all <- rbind(sra.01.sum, sra.19.sum)
sra.all$Year <- as.factor(sra.all$Year)

fig.n <- fig.n + 1
sra.all %>%
  mutate(PMeco_year = paste0(PMeco, Year),
         ecoYear = paste0(ECO, Year),
         ecoYear2 = ifelse(ecoYear == "pp2001", "warm (2001)",
                           ifelse(ecoYear == "pp2019", "warm (2019)",
                                  ifelse(ecoYear == "wf2001", "cool (2001)",
                                         ifelse(ecoYear == "wf2019", "cool (2019)",
                                                ifelse(ecoYear == "rf2001", "cold (2001)", "cold (2019)")))))) %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = ecoYear2, group = PMeco_year)) +
  geom_vline(xintercept = atm.d14.2001) +
  geom_vline(xintercept = atm.d14.2019, linetype = "dashed") +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  geom_path(aes(linetype = Year)) +
  scale_y_reverse(limits = c(41, 0)) +
  scale_color_manual(name = "parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem (year)",
                     values = c("warm (2001)" = 15, 
                                "cool (2001)" = 16, 
                                "cold (2001)" = 17,
                                "warm (2019)" = 0, 
                                "cool (2019)" = 1, 
                                "cold (2019)" = 2)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Mean profile $\Delta$^14^C for 2001 and 2019 samples**

>*Caption:* Mean $\Delta$^14^C by depth for each site in 2001 and 2019. Error bars show ±1 standard deviation. Vertical lines show $\Delta$^14^C of the atmosphere in 2001 (solid) and 2019 (dashed).

## Incubation $\Delta$^14^C-CO~2~ for 2019 bulk soils

```{r plot-inc-d14c}
sra.2019.inc.df_1 <- bind_rows(sra.2019.inc.ls_1)

fig.n <- fig.n + 1
sra.2019.inc.df_1 %>%
  mutate(d14c = replace(d14c, which(d14c < -300), NA), # remove GRrf 10-20 point
         eco = factor(ifelse(ECO == "pp", "warm",
                             ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = ECO)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  # geom_errorbarh(
  #   aes(xmin = d14c_l, 
  #       xmax = d14c_u,
  #       color = pm), 
  #   height = 1.5) +
  geom_path(linetype = "dashed") +
  scale_y_reverse() +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("pp" = 0, 
                                "wf" = 1, 
                                "rf" = 2),
                     labels = c("pp" = "warm", 
                                "wf" = "cool", 
                                "rf" = "cold")) +
  xlab(expression('Incubation '*Delta*''^14*'C-CO'[2]*' (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(ECO)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Rep 1 $\Delta$^14^C-CO~2~ of 2019 bulk soil incubations**

>*Caption:* $\Delta$^14^CO~2~ by depth for each site in 2019. (Still waiting for data from laboratory duplicates). Note that the 10-20 cm increment sample from the cold granite site appears to have been contaminated: $\Delta$^14^C-CO~2~ = `r {sra.2019.inc.df_1[sra.2019.inc.df_1$PMeco == "GRrf" & sra.2019.inc.df_1$lyr_bot == 20, "d14c"]}`.

## Incubation vs. bulk soil $\Delta$^14^C

```{r plot-inc-bulk-d14c}
# bind rows of inc list
sra.19.inc <- sra.2019.inc.df_1[ , !(names(sra.2019.inc.df_1) %in% c("fm", "fm_err"))]
sra.19.inc$Type <- "inc"
sra.19.inc$d14c_l <- NA
sra.19.inc$d14c_u <- NA

# rbind bulk data
sra.19.bulk <- sra.19.inc
sra.19.bulk[ , c("d14c", "d14c_l", "d14c_u")] <- sra.19.sum[which(sra.19.sum$lyr_bot < 31), c("d14c", "d14c_l", "d14c_u")]
sra.19.bulk$Type <- "bulk"
sra.19.inc.blk <- rbind(sra.19.inc, sra.19.bulk)

fig.n <- fig.n + 1
sra.19.inc.blk %>%
  mutate(ECOtype = paste0(ECO, Type),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = ECOtype, linetype = Type)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  geom_path() +
  scale_y_reverse() +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem (type)",
                     values = c("ppbulk" = 15, 
                                "wfbulk" = 16, 
                                "rfbulk" = 17,
                                "ppinc" = 0, 
                                "wfinc" = 1, 
                                "rfinc" = 2),
                     labels = c("ppbulk" = "warm (bulk)", 
                                "wfbulk" = "cool (bulk)", 
                                "rfbulk" = "cold (bulk)",
                                "ppinc" ="warm (inc)", 
                                "wfinc" = "cool (inc)", 
                                "rfinc" = "cold (inc)")) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. $\Delta$^14^C of 2019 bulk soil incubations and corresponding bulk soil**

>*Caption:* $\Delta$^14^C of bulk soil and respired CO~2~ by depth for each site in 2019. Error bars show one standard deviation for bulk soil, points show mean of three replicate profiles for bulk soils and single observations for respired CO~2~ (still waiting for data from laboratory duplicates). 

```{r plot-inc-bulk-14c-2019}
# first merge mean 14C data from 2019 samples with composite incubation data
nms.inc.blk <- c("PM", "ECO", "PMeco", "lyr_top", "lyr_bot", "Year")
sra.19.inc.blk2 <- merge(sra.19.sum[which(sra.19.sum$lyr_bot < 31), c(nms.inc.blk, "d14c", "d14c_u", "d14c_l")], 
                        sra.2019.inc.df_1[ , c(nms.inc.blk, "d14c")],
                        by = nms.inc.blk, suffixes = c(".bulk", ".inc"))

# regress bulk vs. inc
min.inc.blk <- min(sra.19.inc.blk2$d14c_l) # exclude highly negative incubation sample from GRwf
max.inc.blk <- max(sra.19.inc.blk2$d14c_u, sra.19.inc.blk$d14c.inc)

# What is the ideal grouping/expected relationship?
fig.n <- fig.n + 1
sra.19.inc.blk2 %>%
  mutate(depth = ifelse(lyr_top == 0, "0-10cm", ifelse(lyr_top == 10, "10-20cm", "20-30cm"))) %>%
  ggplot(., aes(d14c.bulk, d14c.inc, color = PM, shape = ECO, group = PM)) +
  # geom_vline(xintercept = atm.d14.2019, linetype = "dashed") +
  geom_vline(xintercept = 0) +
  # geom_hline(yintercept = atm.d14.2019, linetype = "dashed") +
  geom_hline(yintercept = 0) +
  geom_point(size = 3) +
  # geom_smooth(method = "lm", se = FALSE) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = PM), 
    height = 1.5) +
  scale_color_manual(name = "Parent material",
                     values = c("AN" = "blue",
                                "BS" = "red",
                                "GR" = "darkgray"),
                     labels = c("AN" = "andesite",
                                "BS"= "basalt",
                                "GR" = "granite")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("pp" = 0,
                                "wf" = 1,
                                "rf" = 2),
                     labels = c("pp" = "warm",
                                "wf" = "cool",
                                "rf" = "cold")) +
  scale_x_continuous(limits = c(min.inc.blk, max.inc.blk)) +
  scale_y_continuous(limits = c(min.inc.blk, max.inc.blk)) +
  coord_fixed() +
  xlab(expression('Bulk soil '*Delta*''^14*'C (‰)')) +
  ylab(expression('Incubation '*Delta*''^14*'C (‰)')) +
  facet_grid(cols = vars(depth)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())

# all depths together, by PM
# sra.19.inc.blk %>%
#   mutate(depth = ifelse(lyr_top == 0, "0-10cm", ifelse(lyr_top == 10, "10-20cm", "20-30cm"))) %>%
#   ggplot(., aes(d14c.bulk, d14c.inc, color = depth, shape = ECO)) +
#   geom_vline(xintercept = atm.d14.2019, linetype = "dashed") +
#   geom_vline(xintercept = 0) +
#   geom_hline(yintercept = atm.d14.2019, linetype = "dashed") +
#   geom_hline(yintercept = 0) +
#   geom_point(size = 3) +
#   geom_errorbarh(
#     aes(xmin = d14c_l, 
#         xmax = d14c_u,
#         color = depth), 
#     height = 1.5) +
#   scale_shape_manual(name = "Ecosystem",
#                      values = c("pp" = 0, 
#                                 "wf" = 1, 
#                                 "rf" = 2)) +
#   scale_x_continuous(limits = c(min.inc.blk, max.inc.blk)) +
#   scale_y_continuous(limits = c(min.inc.blk, max.inc.blk)) +
#   coord_fixed() +
#   xlab(expression('Bulk soil '*Delta*''^14*'C (‰)')) +
#   ylab(expression('Incubation '*Delta*''^14*'C (‰)')) +
#   facet_grid(cols = vars(PM)) +
#   theme_bw() +
#   theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Regression of 2019 bulk soil incubations and corresponding bulk soil $\Delta$^14^C**

>*Caption:* Regressions of $\Delta$^14^C of bulk soil and respired CO~2~ by depth for each site in 2019. Error bars show one standard deviation for bulk soil, points show mean of three replicate profiles for bulk soils and single observations for respired CO~2~ (still waiting for data from laboratory duplicates).

## Time series: $\Delta$^14^C by depth (as measured)
```{r plot-timeseries-meas-depths}
# combine '01, '09, '19 data
sra.01.09.19.raw <- rbind(bind_rows(sra.2001.sum.ls),
                          bind_rows(sra.2019.sum.ls))
sra.2009.ls <- split(ras18.lyr, ras18.lyr$PMeco)
sra.2009.df <- bind_rows(sra.2009.ls)
colnames(sra.2009.df)[which(colnames(sra.2009.df) == "lyr_14c")] <- "d14c"
sra.2009.df <- sra.2009.df[ , which(names(sra.2009.df) %in% names(sra.01.09.19.raw))]
sra.2009.df <- cbind(sra.2009.df, 
                     fm = NA,
                     d14c_sd = NA,
                     fm_sd = NA)
sra.01.09.19.raw <- rbind(sra.01.09.19.raw, sra.2009.df)
sra.01.09.19.raw$Year <- factor(c(rep(2001, nrow(bind_rows(sra.2001.sum.ls))),
                                  rep(2019, nrow(bind_rows(sra.2019.sum.ls))),
                                  rep(2009, nrow(sra.2009.df))),
                                levels = c("2001", "2009", "2019"))

# plot
# w/ ribbons
# sra.01.09.19.raw %>%
#   mutate(PMeco_year = paste0(PMeco, Year),
#          eco = factor(ifelse(ECO == "pp", "warm",
#                       ifelse(ECO == "wf", "cool", "cold")),
#                       levels = c("warm", "cool", "cold")),
#          d14c_u = d14c + d14c_sd,
#          d14c_l = d14c - d14c_sd,
#          pm = ifelse(PM == "AN", "andesite",
#                      ifelse(PM == "BS", "basalt", "granite"))) %>%
#   ggplot(., aes(d14c, lyr_bot, group = PMeco_year)) +
#   geom_vline(xintercept = 0) +
#   geom_hline(yintercept = 0) +
#   geom_ribbon(aes(xmin = d14c_l, xmax = d14c_u, fill = pm, alpha = Year, group = PMeco_year),
#               color = NA, show.legend = FALSE) +
#   geom_point(aes(fill = pm, color = pm, shape = eco, alpha = Year), size = 2) +
#   geom_point(aes(shape = eco), color = "black", size = 3) +
#   geom_path(aes(linetype = Year, color = pm), size = 0.7) +
#   scale_y_reverse() +
#   scale_color_manual(name = "Parent material",
#                      values = c("andesite" = "blue", 
#                                 "basalt" = "red", 
#                                 "granite" = "darkgray")) +
#   scale_fill_manual(name = "Parent material",
#                     values = c("andesite" = "blue", 
#                                "basalt" = "red", 
#                                "granite" = "darkgray")) +
#   scale_shape_manual(name = "Ecosystem",
#                      values = c("warm" = 22, 
#                                 "cool" = 21, 
#                                 "cold" = 24)) +
#   scale_alpha_manual(values = c("2001" = .6,
#                                 "2009" = 0.4,
#                                 "2019" = 0.2)) +
#   facet_grid(rows = vars(eco), cols = vars(pm)) +
#   xlab(expression(Delta*''^14*'C (‰)')) +
#   ylab("Depth (cm)") +
#   theme_bw() +
#   theme(panel.grid.minor = element_blank())

# with error bars
# sra.01.09.19.raw %>%
#   mutate(PMeco_year = paste0(PMeco, Year),
#          eco = factor(ifelse(ECO == "pp", "warm",
#                       ifelse(ECO == "wf", "cool", "cold")),
#                       levels = c("warm", "cool", "cold")),
#          d14c_u = d14c + d14c_sd,
#          d14c_l = d14c - d14c_sd,
#          pm = ifelse(PM == "AN", "andesite",
#                      ifelse(PM == "BS", "basalt", "granite"))) %>%
#   ggplot(., aes(d14c, lyr_bot, group = PMeco_year)) +
#   geom_vline(xintercept = 0) +
#   geom_hline(yintercept = 0) +
#   geom_point(aes(fill = pm, color = pm, shape = eco, alpha = Year), size = 3.5) +
#   geom_path(aes(linetype = Year, color = pm), size = 0.7) +
#   geom_errorbarh(
#     aes(xmin = d14c_l,
#         xmax = d14c_u,
#         color = pm,
#         alpha = Year),
#     height = 1.5) +
#   scale_y_reverse() +
#   scale_color_manual(name = "Parent material",
#                      values = c("andesite" = "blue", 
#                                 "basalt" = "red", 
#                                 "granite" = "darkgray")) +
#   scale_fill_manual(name = "Parent material",
#                     values = c("andesite" = "blue", 
#                                "basalt" = "red", 
#                                "granite" = "darkgray")) +
#   scale_shape_manual(name = "Ecosystem",
#                      values = c("warm" = 15, 
#                                 "cool" = 16, 
#                                 "cold" = 17)) +
#   scale_alpha_manual(values = c("2001" = 1,
#                                 "2009" = 0.6,
#                                 "2019" = 0.3)) +
#   facet_grid(rows = vars(eco), cols = vars(pm)) +
#   xlab(expression(Delta*''^14*'C (‰)')) +
#   ylab("Depth (cm)") +
#   theme_bw() +
#   theme(panel.grid.minor = element_blank())

# just topsoil, w/ error bars
fig.n <- fig.n + 1
sra.01.09.19.raw <- sra.01.09.19.raw[order(sra.01.09.19.raw$lyr_top), ]
sra.01.09.19.raw %>%
  mutate(PMeco_year = paste0(PMeco, Year),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  ggplot(., aes(d14c, lyr_bot, group = PMeco_year)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point(aes(fill = pm, color = pm, shape = eco, alpha = Year), size = 3) +
  geom_path(aes(linetype = Year, color = pm), size = 0.7) +
  geom_errorbarh(
    aes(xmin = d14c_l,
        xmax = d14c_u,
        color = pm,
        alpha = Year),
    height = 1.5) +
  scale_y_reverse(limits = c(41, 0)) +
  scale_x_continuous(limits = c(-160, 190)) +
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_fill_manual(name = "Parent material",
                    values = c("andesite" = "blue", 
                               "basalt" = "red", 
                               "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  scale_alpha_manual(values = c("2001" = 1,
                                "2009" = 0.6,
                                "2019" = 0.3)) +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Time series of $\Delta$^14^C by depth, as measured**

>*Caption:* Points show mean of three profile replicates for 2001 and 2019 samples. Error bars show ± 1 standard deviation of the mean (only a single profile was analyzed in 2009). 

## Spline fitting
*Fit splines to 2009 data to predict at 2001 depths*

Soils collected in both the 2001 and 2009 sampling campaigns were sampled by horizon, but the depth intervals differed between the two sampling years. In 2009, full profiles were excavated for each site, as opposed to the shorter profiles collected in 2001 from the GR and AN sites. Radiocarbon was measured on all three replicate profiles at each site for the 2001 samples, but only for one of the replicate profiles at each site in 2009, e.g. ANpp rep2, etc.

In order to compare the radiocarbon profiles between 2001, 2009, and 2019 we interpolated both radiocarbon and carbon stock data at 1 cm intervals for each site in the 2009 and 2019 datasets, and then summed the carbon-stock-weighted radiocarbon values for each depth interval sampled in 2001. A monotonic cubic spline fit was used for the carbon stock interpolation (Wendt and Hauser 2013), and a mass-preserving spline was used to fit the radiocarbon data (Bishop, T.F.A., McBratney, A.B., Laslett, G.M., (1999) Modelling soil attribute depth functions with equal-area quadratic smoothing splines. Geoderma, 91(1-2): 27-45).

```{r cn-clean, include = FALSE}
elm_results_df <- bind_rows(unlist(elm_results_ls, recursive = FALSE))
# Split IDs
PMeco_rep_depth <- bind_rows(
  lapply(strsplit(elm_results_df$ID, "_"), function(x) { 
    df <-  data.frame(PMeco = x[2],
                      pro_rep = x[3],
                      depth = x[4])
    df$PM <- substr(df$PMeco, 1, 2)
    df$ECO <- substr(df$PMeco, 3, 4)
    return(df)
  })
)
elm_results_df <- cbind(elm_results_df, PMeco_rep_depth)
```

```{r soc-2001, include = FALSE}
# add SOC data (lyr_soc_kgm2) to sra.2001.ls
soc.2001 <- data.frame(read_excel("../data/external/sra_ras_sum/sierra_data_summary_2020.xlsx",
                                  sheet = "2001_bulk_data"))
soc.2001 <- type.convert(soc.2001[complete.cases(soc.2001), ])
soc.2001$lyr_soc_kgm2 <- soc.2001$C. * soc.2001$bd.g.cm3 * soc.2001$lyr_bot - soc.2001$lyr_top * 10^-1
nms.2001 <- c("PMeco", "lyr_top", "lyr_bot", "pro_rep")
sra.2001.ls <- lapply(sra.2001.ls, function(df) {
  merge(df, soc.2001[ , c(nms.2001, "lyr_soc_kgm2")], by = nms.2001)
})

# calculate cumulative stocks
# order 2001 data
sra.2001.ls <- lapply(sra.2001.ls, function(df) {
  ls <- split(df, df$pro_name)
  ls <- lapply(ls, function(x) {
    x <- x[order(x$lyr_bot), ]
    x$lyr_soc_cmtv <- NA
    for(i in seq_along(x$lyr_bot)) {
      if(i == 1) {
        x$lyr_soc_cmtv[i] <- x$lyr_soc_kgm2[i]
      } else {
        x$lyr_soc_cmtv[i] <- x$lyr_soc_kgm2[i] + x$lyr_soc_cmtv[i-1] 
      }
    }
    return(x)
  })
  return(unsplit(ls, df$pro_name))
})
```

```{r spline-fm, include = FALSE}
## spline fit for fm
sra.2001.fm.sp <- lapply(sra.2001.ls, function(df) {
  lapply(split(df, df$pro_name), function(x) {
    depths(x) <- pro_name ~ lyr_top + lyr_bot
    x.mps <- mpspline(x, var.name = "fm")
    x.mps$var.1cm <- x.mps$var.1cm[1:max(x$lyr_bot)]
    return(x.mps)
  })
})
# 2009
sra.2009.fm.sp <- lapply(sra.2009.ls, function(x) {
  depths(x) <- pro_name ~ lyr_top + lyr_bot
  x.mps <- mpspline(x, var.name = "lyr_fraction_modern")
  x.mps$var.1cm <- x.mps$var.1cm[1:max(x$lyr_bot)]
  return(x.mps)
})
# 2019
sra.2019.fm.sp <- lapply(sra.2019.ls, function(df) {
  lapply(split(df, df$pro_name), function(x) {
    depths(x) <- pro_name ~ lyr_top + lyr_bot
    x.mps <- mpspline(x, var.name = "fm")
    x.mps$var.1cm <- x.mps$var.1cm[1:max(x$lyr_bot)]
    return(x.mps)
  })
})
```

```{r spline-bd-soc-19, include = FALSE}
# Need SOC stock data for 2019 samples: use BD from 2009 samples 
# spline fit for bulk density
sra.2009.bd.sp <- lapply(sra.2009.ls, function(x) {
  depths(x) <- pro_name ~ lyr_top + lyr_bot
  x.mps <- mpspline(x, var.name = "lyr_bd_samp")
  x.mps$var.1cm <- x.mps$var.1cm[1:100]
  return(x.mps)
})
sra.2009.bd.sp <- lapply(sra.2009.bd.sp, function(ls) {
  df <- data.frame(ls["var.1cm"])
  ix <- which(is.na(df$var.1cm))
  df$var.1cm[ix] <- df$var.1cm[ix[1]-1]
  return(df)
})

# calculate mean of 1cm BD predictions for each depth increment
bd_pred <- lapply(seq_along(sra.2009.bd.sp), function(i) {
  ls <- split(sra.2019.ls[[i]], sra.2019.ls[[i]]["pro_rep"]) # split each replicate profile
  ls <- lapply(seq_along(ls), function(df) {
    d <- ls[[df]][["lyr_bot"]] # depth intervals
    c <- vector(mode = "list", length = length(d)) # vector for averaging 1 cm bd pred
    for(j in seq_along(d)) {
      if(j == 1) {
        c[[j]] <- mean(sra.2009.bd.sp[[i]][1:d[j], "var.1cm"]) # 1-10
      } else {
        c[[j]] <- mean(sra.2009.bd.sp[[i]][(d[j-1]+1):d[j], "var.1cm"]) # 10 cm increments
      }
    }
    return(unlist(c))
    })
  return(unsplit(ls, sra.2019.ls[[i]]["pro_rep"]))
})

# merge predicted bd values with sra.2019.ls
nms <- names(sra.2019.ls)
sra.2019.ls <- lapply(seq_along(sra.2019.ls), function(df) {
  cbind(sra.2019.ls[[df]], bd = bd_pred[[df]])
})
names(sra.2019.ls) <- nms

# add c conc
sra.2019.ls <- lapply(sra.2019.ls, function(df) {
  df$depth <- paste0(df$lyr_top, "-", df$lyr_bot)
  df <- merge(df, elm_results_df[ , c("PMeco", "pro_rep", "depth", "C", "N")], by = c("PMeco", "depth", "pro_rep"))
  return(df)
})

# calculate stocks
sra.2019.ls <- lapply(sra.2019.ls, function(df) {
  df$lyr_soc <- df$bd * df$C # units work out to kg_m2 
  return(df)
})
# calculate cmtv stocks
sra.2019.ls <- lapply(sra.2019.ls, function(df) {
  ls <- split(df, df$pro_name)
  ls <- lapply(ls, function(x) {
    x$lyr_soc_cmtv <- NA
    for(i in seq_along(x$lyr_bot)) {
      if(i == 1) {
        x$lyr_soc_cmtv[i] <- x$lyr_soc[i]
      } else {
        x$lyr_soc_cmtv[i] <- x$lyr_soc[i] + x$lyr_soc_cmtv[i-1] 
      }
    }
    return(x)
  })
  return(unsplit(ls, df$pro_name))
})
```

```{r spline-soc, include = FALSE}
# spline fit for carbon stocks (for calc weighted averages)
depth.spline <- function(x) {
  sp <- spline(x, method = "hyman") # fit monotonic cubic spline
  sp.ss <- smooth.spline(sp) # convert to class "spline" with smooth.spline fxn
  std <- seq(0, 100) # in cm (linear beyond last measured depth)
  sp <- predict(sp.ss, std) 
  df <- data.frame(sp)
  colnames(df) <- c("lyr_bot","lyr_soc")
  for(i in seq_along(df$lyr_bot)) {
    if(i == 1) {
      df$lyr_soc[i] <- df$lyr_soc[i]
    } else {
      df$lyr_soc[i] <- df$lyr_soc[i + 1] - df$lyr_soc[i]
    }
  }
  df <- df[-1,]
  return(df[-length(df$lyr_soc), ])
}

# add (0, 0) point for (lyr_bot, lyr_cmtv_stock)
sra.2001.sp.ls <- lapply(sra.2001.ls, function(df) {
  ls <- lapply(split(df, df$pro_name), function(x) {
    t0 <- data.frame(matrix(nrow = 1, ncol = ncol(x)))
    xy <- c(which(names(x) == "lyr_bot"), which(names(x) == "lyr_soc_cmtv"))
    t0[ , xy] <- 0
    names(t0) <- names(x)
    t0$pro_name <- unique(x$pro_name)
    return(rbind(t0, x))
  })
  return(bind_rows(ls))
})

# 2009
sra.2009.sp.ls <- lapply(sra.2009.ls, function(df) {
  t0 <- data.frame(matrix(nrow = 1, ncol = ncol(df)))
  xy <- c(which(names(df) == "lyr_bot"), which(names(df) == "lyr_soc_cmtv"))
  t0[ , xy] <- 0
  names(t0) <- names(df)
  new <- rbind(t0, df)
  return(new)
})

# 2019
sra.2019.sp.ls <- lapply(sra.2019.ls, function(df) {
  ls <- lapply(split(df, df$pro_name), function(x) {
    t0 <- data.frame(matrix(nrow = 1, ncol = ncol(x)))
    xy <- c(which(names(x) == "lyr_bot"), which(names(x) == "lyr_soc_cmtv"))
    t0[ , xy] <- 0
    names(t0) <- names(x)
    t0$pro_name <- unique(x$pro_name)
    return(rbind(t0, x))
  })
  return(bind_rows(ls))
})

## run spline
# 2001
sra.2001.oc.sp <- lapply(sra.2001.sp.ls, function(df) {
  lapply(split(df, df$pro_name), function(x) {
    depth.spline(x[, c("lyr_bot", "lyr_soc_cmtv")])
  })
})
# 2009
sra.2009.oc.sp <- lapply(sra.2009.sp.ls, function(x) {
  depth.spline(x[, c("lyr_bot", "lyr_soc_cmtv")])
})
# 2019
sra.2019.oc.sp <- lapply(sra.2019.sp.ls, function(df) {
  lapply(split(df, df$pro_name), function(x) {
    depth.spline(x[, c("lyr_bot", "lyr_soc_cmtv")])
  })
})
```

```{r cwt-d14c-01, include = FALSE}
## calculate stock weights
## 2001 depths
# order '01 data
sra.2001.sum.ls <- lapply(sra.2001.sum.ls, function(df) df[order(df$lyr_bot), ])
# 2009
cwt.01.09 <- lapply(seq_along(sra.2009.oc.sp), function(i) {
  d <- sra.2001.sum.ls[[i]][["lyr_bot"]] # map onto '01 depths
  c <- vector(mode = "list", length = length(d))
  for(j in seq_along(d)) {
    if(j == 1) {
      c[[j]] <- sra.2009.oc.sp[[i]][1:d[j], "lyr_soc"]
    } else {
      c[[j]] <- sra.2009.oc.sp[[i]][(d[j-1]+1):d[j], "lyr_soc"] 
    }
  }
  return(unlist(lapply(c, function(x) x/sum(x)))) # return weights
})
names(cwt.01.09) <- names(sra.2009.oc.sp)
# 2019 (second list level from profile reps)
cwt.01.19 <- lapply(seq_along(sra.2019.oc.sp), function(i) {
  lapply(sra.2019.oc.sp[[i]], function(df) {
    d <- sra.2001.sum.ls[[i]][["lyr_bot"]] # map onto '01 depths
    c <- vector(mode = "list", length = length(d))
    for(j in seq_along(d)) {
      if(j == 1) {
        c[[j]] <- df[1:d[j], "lyr_soc"]
      } else {
        c[[j]] <- df[(d[j-1]+1):d[j], "lyr_soc"] 
      }
    }
    return(unlist(lapply(c, function(x) x/sum(x))))  # return weights
  })
})
names(cwt.01.19) <- names(sra.2019.oc.sp)


## calculate fm_wts
## '01 depths
# 2019
fm.wt.01.19 <- lapply(seq_along(cwt.01.19), function(i) {
  lapply(seq_along(cwt.01.19[[i]]), function(j) {
    df <- data.frame(cwt = cwt.01.19[[i]][[j]])
    df$fm <- sra.2019.fm.sp[[i]][[j]][["var.1cm"]][1:length(cwt.01.19[[i]][[j]])]
    df$fm_wt <- df$fm * df$cwt
  return(df)
  })
}) 
names(fm.wt.01.19) <- names(cwt.01.19)
# 2009
fm.wt.01.09 <- lapply(seq_along(cwt.01.09), function(i) {
  df <- data.frame(cwt = cwt.01.09[[i]])
  df$fm <- sra.2009.fm.sp[[i]][["var.1cm"]][1:length(cwt.01.09[[i]])]
  df$fm_wt <- df$fm * df$cwt
  return(df)
})
names(fm.wt.01.09) <- names(cwt.01.09)


## calculate weighted average of fm for each interval
## '01 depths
# 2009
sra.01.09.ls <- lapply(seq_along(sra.2001.sum.ls), function(i) {
  d <- sra.2001.sum.ls[[i]][["lyr_bot"]]
  f <- vector(mode = "list", length = length(d))
  for(j in seq_along(d)) {
    if(j == 1) {
      f[[j]] <- sum(fm.wt.01.09[[i]][1:d[j], "fm_wt"])
    } else {
      f[[j]] <- sum(fm.wt.01.09[[i]][(d[j-1]+1):d[j], "fm_wt"])
    }
  }
  return(cbind(sra.2001.sum.ls[[i]], fm_09 = unlist(f)))
})
names(sra.01.09.ls) <- names(fm.wt.01.09)
# 2019
sra.01.19.ls <- fm.wt.01.19 # initialize list with fm wt structure
sra.01.19.ls <- lapply(seq_along(sra.2001.sum.ls), function(i) {
  sra.01.19.ls[[i]] <- lapply(seq_along(fm.wt.01.19[[i]]), function(x) {
    d <- sra.2001.sum.ls[[i]][["lyr_bot"]]
    f <- vector(mode = "list", length = length(d))
    for(j in seq_along(d)) {
      if(j == 1) {
        f[[j]] <- sum(fm.wt.01.19[[i]][[x]][1:d[j], "fm_wt"])
      } else {
        f[[j]] <- sum(fm.wt.01.19[[i]][[x]][(d[j-1]+1):d[j], "fm_wt"])
      }
    }
    return(unlist(f)) 
  })
  fm <- lapply(seq_along(sra.01.19.ls[[i]][[1]]), function(z) {
    data.frame(fm_19_mean = mean(sapply(sra.01.19.ls[[i]], "[", z), na.rm = TRUE),
               fm_19_sd = sd(sapply(sra.01.19.ls[[i]], "[", z), na.rm = TRUE))
    })
  fm <- bind_rows(fm)
  return(fm)
})
sra.01.09.19.ls <- lapply(seq_along(sra.01.09.ls), function(i) {
  data.frame(sra.01.09.ls[[i]], sra.01.19.ls[[i]])
})
names(sra.01.09.19.ls) <- names(sra.01.09.ls)

## create tidy combined '01, '09, '19 data frame
nms <- c("PM", "ECO", "PMeco", "lyr_top", "lyr_bot", "fm", "fm_sd")
sra.01.09.19.df <- bind_rows(sra.01.09.19.ls)
sra.01.09.19 <- sra.01.09.19.df[, nms]
sra.01.09.19 <- rbind(cbind(sra.01.09.19, Year = as.character(2001)),
                      data.frame(sra.01.09.19[, nms[1:5]],
                                 fm = sra.01.09.19.df$fm_09,
                                 fm_sd = NA,
                                 Year = as.character(2009)),
                      data.frame(sra.01.09.19[, nms[1:5]],
                                 fm = sra.01.09.19.df$fm_19_mean,
                                 fm_sd = sra.01.09.19.df$fm_19_sd,
                                 Year = as.character(2019)))

# calc d14c from fm
sra.01.09.19$d14c <- calc_14c(sra.01.09.19$fm, as.numeric(as.character(sra.01.09.19$Year)))
sra.01.09.19$d14c_sd <- abs(sra.01.09.19$d14c - calc_14c(sra.01.09.19$fm + sra.01.09.19$fm_sd, as.numeric(as.character(sra.01.09.19$Year))))
```

```{r cwt-d14c-19, include = FALSE}
## calculate stock weights
## 2019 depths
# 2001
cwt.19.01 <- lapply(seq_along(sra.2001.oc.sp), function(i) {
  lapply(sra.2001.oc.sp[[i]], function(df) {
    d <- sra.2019.sum.ls[[i]][["lyr_bot"]]
    c <- vector(mode = "list", length = length(d))
    for(j in seq_along(d)) {
      if(j == 1) {
        c[[j]] <- df[1:d[j], "lyr_soc"]
      } else {
        c[[j]] <- df[(d[j-1]+1):d[j], "lyr_soc"] 
      }
    }
    return(unlist(lapply(c, function(x) x/sum(x))))
  })
})
names(cwt.19.01) <- names(sra.2001.oc.sp)
# 2009
cwt.19.09 <- lapply(seq_along(sra.2009.oc.sp), function(i) {
  d <- sra.2019.sum.ls[[i]][["lyr_bot"]]
  c <- vector(mode = "list", length = length(d))
  for(j in seq_along(d)) {
    if(j == 1) {
      c[[j]] <- sra.2009.oc.sp[[i]][1:d[j], "lyr_soc"]
    } else {
      c[[j]] <- sra.2009.oc.sp[[i]][(d[j-1]+1):d[j], "lyr_soc"] 
    }
  }
  return(unlist(lapply(c, function(x) x/sum(x))))
})
names(cwt.19.09) <- names(sra.2009.oc.sp)

## calculate fm_wts
## '19 depths
# 2001
fm.wt.19.01 <- lapply(seq_along(cwt.19.01), function(i) {
  lapply(seq_along(cwt.19.01[[i]]), function(j) {
    df <- data.frame(cwt = cwt.19.01[[i]][[j]])
    df$fm <- sra.2001.fm.sp[[i]][[j]][["var.1cm"]][1:length(cwt.19.01[[i]][[j]])]
    # linear extrapolation for filling 20-30cm fm data
    fm_1_30 <- df$fm[1:30] # 0-30cm fm
    if(length(which(is.na(fm_1_30))) > 0) {
     ix <- which(is.na(fm_1_30))
     ix.min <- min(ix) # first is.na(fm)
     m <- fm_1_30[ix.min-1]-fm_1_30[ix.min-2] # slope at last two measurement points
     for(i in ix.min:30) {
      fm_1_30[i] <- fm_1_30[i - 1] + m 
     }
     df$fm[1:30] <- fm_1_30 
    }
    df$fm_wt <- df$fm * df$cwt
  return(df)
  })
})
names(fm.wt.19.01) <- names(cwt.19.01)
# 2009
fm.wt.19.09 <- lapply(seq_along(cwt.19.09), function(i) {
  df <- data.frame(cwt = cwt.19.09[[i]])
  df$fm <- sra.2009.fm.sp[[i]][["var.1cm"]][1:length(cwt.19.09[[i]])]
  df$fm_wt <- df$fm * df$cwt
  return(df)
})
names(fm.wt.19.09) <- names(cwt.19.09)


## calculate weighted average of fm for each interval
## '19 depths
# 2001
# calculate weighted spline values for each profile rep
sra.19.01.rep.ls <- fm.wt.19.01
sra.19.01.rep.ls <- lapply(seq_along(sra.2019.sum.ls), function(i) {
  sra.19.01.rep.ls[[i]] <- lapply(seq_along(fm.wt.19.01[[i]]), function(x) {
    d <- sra.2019.sum.ls[[i]][["lyr_bot"]]
    f <- vector(mode = "list", length = length(d))
    for(j in seq_along(d)) {
      if(j == 1) {
        f[[j]] <- sum(fm.wt.19.01[[i]][[x]][1:d[j], "fm_wt"])
      } else {
        f[[j]] <- sum(fm.wt.19.01[[i]][[x]][(d[j-1]+1):d[j], "fm_wt"])
      }
    }
    return(unlist(f)) 
  })})
sra.19.01.rep.ls <- lapply(seq_along(sra.19.01.rep.ls), function(i) {
  names(sra.19.01.rep.ls[[i]]) <- names(cwt.19.01[[i]])
  return(sra.19.01.rep.ls[[i]])
})
names(sra.19.01.rep.ls) <- names(fm.wt.19.01)

# average reps
sra.19.01.ls <- lapply(seq_along(sra.2019.sum.ls), function(i) {
  fm <- lapply(seq_along(sra.19.01.rep.ls[[i]][[1]]), function(z) {
    data.frame(fm_01_mean = mean(sapply(sra.19.01.rep.ls[[i]], "[", z), na.rm = TRUE),
               fm_01_sd = sd(sapply(sra.19.01.rep.ls[[i]], "[", z), na.rm = TRUE))
    })
  return(bind_rows(fm))
})
names(sra.19.01.ls) <- names(fm.wt.19.01)

# 2009
sra.19.09.ls <- lapply(seq_along(sra.2019.sum.ls), function(i) {
  d <- sra.2019.sum.ls[[i]][["lyr_bot"]]
  f <- vector(mode = "list", length = length(d))
  for(j in seq_along(d)) {
    if(j == 1) {
      f[[j]] <- sum(fm.wt.19.09[[i]][1:d[j], "fm_wt"])
    } else {
      f[[j]] <- sum(fm.wt.19.09[[i]][(d[j-1]+1):d[j], "fm_wt"])
    }
  }
  return(cbind(sra.2019.sum.ls[[i]], fm_09 = unlist(f)))
})
names(sra.19.09.ls) <- names(sra.19.01.ls)

# combine
sra.19.01.09.ls <- lapply(seq_along(sra.19.01.ls), function(i) {
  data.frame(sra.19.01.ls[[i]], sra.19.09.ls[[i]])
})
names(sra.19.01.09.ls) <- names(sra.19.01.ls)

## create tidy combined '01, '09, '19 data frame
sra.19.01.09.df <- bind_rows(sra.19.01.09.ls)
sra.19.01.09 <- sra.19.01.09.df[, nms]
sra.19.01.09 <- rbind(data.frame(sra.19.01.09[, nms[1:5]],
                                 fm = sra.19.01.09.df$fm_01_mean,
                                 fm_sd = sra.19.01.09.df$fm_01_sd,
                                 Year = as.character(2001)),
                     data.frame(sra.19.01.09[, nms[1:5]],
                                fm = sra.19.01.09.df$fm_09,
                                fm_sd = NA,
                                Year = as.character(2009)),
                     cbind(sra.19.01.09, Year = as.character(2019)))

# calc d14c from fm
sra.19.01.09$d14c <- calc_14c(sra.19.01.09$fm, as.numeric(as.character(sra.19.01.09$Year)))
sra.19.01.09$d14c_sd <- abs(sra.19.01.09$d14c - calc_14c(sra.19.01.09$fm + sra.19.01.09$fm_sd, as.numeric(as.character(sra.19.01.09$Year))))
```

```{r plot-01-09-19-14c-profiles}
fig.n <- fig.n + 1
sra.01.09.19 %>%
  mutate(PMeco_year = paste0(PMeco, Year),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = eco, linetype = Year, group = PMeco_year)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point(aes(alpha = Year), size = 3) +
  geom_path(aes(linetype = Year)) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  scale_y_reverse() +
  scale_x_continuous() +    
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  scale_alpha_manual(values = c("2001" = 1,
                                "2009" = 0.6,
                                "2019" = 0.3)) +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Time series of $\Delta$^14^C by depth (2001, 2009, 2019)**

>*Caption:* Points for 2001 samples show the mean $\Delta$^14^C values at the measured depths. Points for 2009 and 2019 samples are spline-fitted estimates of $\Delta$^14^C predicted for the same depth intervals as measured in 2001. Error bars show ± 1 standard deviation of the mean of three replicate profiles for 2001 and 2019 samples (only a single profile was analyzed in 2009). 

```{r plot-19-01-09-14c-profiles}
fig.n <- fig.n + 1
sra.19.01.09 %>%
  mutate(PMeco_year = paste0(PMeco, Year),
         eco = factor(ifelse(ECO == "pp", "warm",
                      ifelse(ECO == "wf", "cool", "cold")),
                      levels = c("warm", "cool", "cold")),
         d14c_u = d14c + d14c_sd,
         d14c_l = d14c - d14c_sd,
         pm = ifelse(PM == "AN", "andesite",
                     ifelse(PM == "BS", "basalt", "granite"))) %>%
  ggplot(., aes(d14c, lyr_bot, color = pm, shape = eco, linetype = Year, group = PMeco_year)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point(aes(alpha = Year), size = 3) +
  geom_path(aes(linetype = Year)) +
  geom_errorbarh(
    aes(xmin = d14c_l, 
        xmax = d14c_u,
        color = pm), 
    height = 1.5) +
  scale_y_reverse(limits = c(30, 0)) +
  scale_x_continuous() +    
  scale_color_manual(name = "Parent material",
                     values = c("andesite" = "blue", 
                                "basalt" = "red", 
                                "granite" = "darkgray")) +
  scale_shape_manual(name = "Ecosystem",
                     values = c("warm" = 15, 
                                "cool" = 16, 
                                "cold" = 17)) +
  scale_alpha_manual(values = c("2001" = 1,
                                "2009" = 0.6,
                                "2019" = 0.3)) +
  facet_grid(rows = vars(eco), cols = vars(pm)) +
  xlab(expression(Delta*''^14*'C (‰)')) +
  ylab("Depth (cm)") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```
>**Fig. `r {fig.n}`. Time series of $\Delta$^14^C by depth (splined to 2019 depths)**

>*Caption:* Points for 2019 samples show the mean $\Delta$^14^C values at the measured depths. Points for 2001 and 2009 samples are spline-fitted estimates of $\Delta$^14^C predicted for the same depth intervals as measured in 2019. Error bars show ± 1 standard deviation of the mean of three replicate profiles for 2001 and 2019 samples (only a single profile was analyzed in 2009). 
>*NB: Only two depth intervals were measured at the cool and cold andesite sites (max depth of 27 and 28 cm, respectively), so linear extrapolation (using the slope of the last 1cm spline-fitted depth increment) was used to extend the profiles to 30 cm.*

## Initial modeling

The goal of this modeling exercise is to see how parent material and climate/ecosystem affect estimates of soil carbon ages and transit times. Bulk soil ^14^C observations from 2001, 2009, and 2019 will be used to constrain the carbon models, as well as observations of ^14^C-CO~2~ from laboratory soil incubations of soils collected in 2001 and 2019. Previous work has indicated that the carbon stocks at these sites is likely at equilibrium, so we will apply the steady-state assumption to the modeling.

### Two-pool models

One pool models have been shown repeatedly to be inadequate for describing soil carbon dynamics. However, as simple models are easier to constrain, we will start with a two-pool parallel and two-series models, as these are the simplest model system beyond the single pool approach. 

The two-pool parallel model requires the following parameters:
* decomposition constants for each pool (*k*~1~, *k*~2~)
* input partitioning coefficient ($\gamma$)
* steady-state carbon stocks (C)
* inputs (I)
* initial values of ^14^C

The two-pool series model requires the following parameters:
* decomposition constants for each pool (*k*~1~, *k*~2~)
* transfer coefficient ($\alpha$)
* steady-state carbon stocks (C)
* inputs (I)
* initial values of ^14^C

Decomposition rates (*k*) are related to the amount of ^14^C in a pre-bomb system (fraction modern, *F*) at steady-state by the following equations (cf. Schuur, Druffle, and Trumbore, 2016):
>**Eq. 1**

$$F = \frac{k}{k + \lambda}$$
>**Eq. 2**

$$k = \frac{\lambda \cdot F}{1 - F}$$
>where $\lambda$ is the radioactive decay constant (1/8267).

As the decomposition rates will vary, the initial ^14^C content can be determined dynamically with equation 1.

Carbon stocks are known, while inputs will be estimated and are related to the steady-state conditions by the following equation: 
>**Eq. 3**

$$I = (k_{1} \cdot C_{1}) + (k_{2} \cdot C_{2})$$
>where *C~1~* and *C~2~* are the carbon stocks of the two model pools.

Both stocks and inputs can be scaled to the known value of the total carbon pool once the steady-state parameters (*k~1~*, *k~2~*, and $\gamma$ or $\alpha$) have been determined. Pool sizes are a function of the inputs and input partitioning coefficient at steady-state.

A Monte-Carlo Markov chain approach will be used for parameter estimation in combination with an initial optimization algorithm to determine the best set of initial parameters.

## Workflow

Initial model fitting was performed for both model structures using generous parameter ranges [0, 1] for all three parameters (*k~1~*, *k~2~*, $\gamma$ or $\alpha$). The initial parameter set was found by fitting the models by eye, followed by optimization with the function "modFit" (R package FME), using the Nelder-Mead algorithm. The best set of parameters found by modFit was then used as the input to a Monte Carlo Markov Chain (MCMC), using the function "modMCMC" (R package FME). The number of iterations for the MCMC optimization was set at 5000 intially, with delayed rejection employed to increase efficiency. 

The sum of the mean squared error for the best parameter set was slightly lower for the parallel structure than for the series structure. Additionally, the overall mean error of the residuals was also lower for the parallel structure, moderately so for the bulk C observations but substantially so for the respiration observations (in andesite and granite soils in particular).

However, these initial fits yielded unrealistic parameter estimates for multiple sites, particularly at the lower depths. Additionally, the modFit output showed very high correlation between the parameters for both model structures (slightly higher for the two-pool series model). 

```{r mod-utils}
# k from fraction modern
k <- function (Fm) {
  (Fm * lambda)/(1 - Fm)
}

# d14C from fraction modern 
fm_14c <- function (fm, date) {
  (fm * exp(lambda * (1950 - date)) - 1) * 1000
}

# pre-bomb fraction modern from k (steady-state assumed)
fm <- function (k){
  k/(k + lambda)
}
```

```{r mod-constraints, include = FALSE}
## SOC stocks
# use 2019 SOC stocks for steady-state estimates
csoc.19.0_30 <- bind_rows(
  lapply(sra.2019.sp.ls, function(df) {
    df <- suppressMessages(
      df %>% 
        filter(lyr_bot < 31 & lyr_bot > 0) %>%
        select(PMeco, lyr_top, lyr_bot, lyr_soc) %>%
        group_by(PMeco, lyr_top, lyr_bot) %>%
        summarize(lyr_soc = mean(lyr_soc)))
    return(data.frame(df))
  })
)
# convert to 27 element list
csoc.19.0_30 <- split(csoc.19.0_30, paste0(csoc.19.0_30$PMeco, "_", csoc.19.0_30$lyr_top, "-", csoc.19.0_30$lyr_bot))

## Inputs
# Inputs may vary among sites, and I could use respiration data from incubations as a constraint
# However, initial inputs will be set at 4% of the layer carbon stocks
in.i <- lapply(csoc.19.0_30, function(x) .04 * x$lyr_soc)
# Inputs will be adjusted based on the fitted parameters to match measured stocks later

## 14C constraints
# bulk
obs.bulk.14c <- unlist(
  lapply(seq_along(sra.19.01.rep.ls), function(i) {
  # index along depth intervals 0-10, 10-20, 20-30
  depth.ls <- lapply(seq_along(1:3), function(j) {
    c(unlist(lapply(sra.19.01.rep.ls[[i]], "[[", j)),
      split(split(sra.19.01.09, sra.19.01.09$PMeco)[[i]],
            split(sra.19.01.09, sra.19.01.09$PMeco)[[i]]["lyr_bot"])[[j]][ , "fm"][2],
      unlist(split(sra.2019.ls[[i]], sra.2019.ls[[i]]["lyr_bot"])[[j]]["fm"]))
  })
  reps01 <- length(sra.19.01.rep.ls[[i]])
  depth.dfs <- lapply(depth.ls, function(fm) {
    data.frame(time = c(rep(2001.5, reps01), 2009.5, rep(2019.5, 3)),
               bulkC = Delta14C_from_AbsoluteFractionModern(fm))
  })
  return(depth.dfs)
}), recursive = FALSE)
names(obs.bulk.14c) <- paste0(rep(c("AN", "BS", "GR"), each = 9),
                              rep(c("pp", "rf", "wf"), each = 3, times = 3),
                              rep(c("_0-10", "_10-20", "_20-30"), times = 9))

# respiration
obs.resp.14c <- split(sra.2019.inc.df_1, gsub("comp_", "", sra.2019.inc.df_1$lyr_name))
obs.resp.14c <- lapply(obs.resp.14c, function(df) {
  df$resp <- df$d14c
  df$time <- df$Year + .5
  return(df[ , c("time", "resp")])
})
```

```{r mod-funs-gen}
# index of years for which bulk/resp 14C are known
year.ix <- c(which(Datm$Date == 2001.5),
             which(Datm$Date == 2009.5),
             which(Datm$Date == 2019.5))

# function for saving constraint data in a dataframe for plotting in ggplot'
# NB should change this to reference obs.bulk.14c and obs.resp.14c dfs
# con.df.fx <- function(PMeco, depth) {
#   bulk.df <- obs.bulk.14[[paste0(PMeco, "_", depth)]]
#   resp.df <- cbind(sra.2019.inc.df_1[sra.2019.inc.df_1$PMeco == PMeco &
#                                        sra.2019.inc.df_1$lyr_bot == lyr_bot, c("Year", "d14c")], d14c_sd = NA)
#   con.df <- cbind(pool = c(rep("bulk C", nrow(bulk.df)), rep("respiration", nrow(resp.df))), rbind(bulk.df, resp.df))
#   con.df$d14c_l <- con.df$d14c - con.df$d14c_sd
#   con.df$d14c_u <- con.df$d14c + con.df$d14c_sd
#   con.df$Year <- as.numeric(as.character(con.df$Year))
#   return(con.df)
# }
con.df.fx <- function(PMeco, lyr_bot) {
  bulk.df <- sra.19.01.09[sra.19.01.09$PMeco == PMeco &
                           sra.19.01.09$lyr_bot == lyr_bot, c("Year", "d14c", "d14c_sd")]
  resp.df <- cbind(sra.2019.inc.df_1[sra.2019.inc.df_1$PMeco == PMeco &
                                       sra.2019.inc.df_1$lyr_bot == lyr_bot, c("Year", "d14c")], d14c_sd = NA)
  con.df <- cbind(pool = c(rep("bulk C", nrow(bulk.df)), rep("respiration", nrow(resp.df))), rbind(bulk.df, resp.df))
  con.df$d14c_l <- con.df$d14c - con.df$d14c_sd
  con.df$d14c_u <- con.df$d14c + con.df$d14c_sd
  con.df$Year <- as.numeric(as.character(con.df$Year))
  return(con.df)
}

# plot function
C14.2p.plot.fx <- function(plot.df, con.df, mod) {
  plot.df %>%
  filter(pool == "bulk C" | pool == "respiration" | pool == "atm") %>%
  ggplot(., aes(years, d14C, color = pool)) +
  geom_path() +
  geom_point(data = con.df, aes(Year, d14c, color = pool), size = 3) +
  geom_errorbar(data = con.df,
    aes(x = Year,
        ymin = d14c_l, 
        ymax = d14c_u, 
        color = pool), 
    width = .1,
    inherit.aes = FALSE) +
  scale_color_manual(
    name = "Model pool",
    values = c("atm" = 8,
               "bulk C" = "black",
               "fast" = "#D81B60",
               "slow" = "#1E88E5",
               "respiration" = "#FFC107")) +
  scale_x_continuous(limits = c(1950, 2022)) +
  ggtitle(paste0(PMeco, "_", lyr_top, "-", lyr_bot, " ", mod)) +
  xlab("Year") +
  ylab(expression(''*Delta*''^14*'C (‰)')) +
  theme_bw() +
  theme(panel.grid = element_blank())
}

# set up model function for optimization
modFun_2p <- function(pars, In, lag = 5, pass = TRUE, out = "modFit", mod) {
 
  # intial 14C
  F0_Delta14C <- unlist(lapply(pars[1:2], function(x) Delta14C_from_AbsoluteFractionModern(fm(x))))
  
  # model matrix
  A <- -1 * diag(pars[1:2])
  if (mod == "2ps") {
    A[2, 1] <- pars[3]
  }
    
  # steady-state C stocks
  ss.cstock <- (-1 * solve(A) %*% c(In * pars[3], In * (1 - pars[3])))
  
  # time index
  ix.t <- c((lag + 1):nrow(Datm))
  
  # model
  if (mod == "2pp") {
    mod <- TwopParallelModel14(t = Datm$Date[ix.t],
                               ks = pars[1:2],
                               C0 = c(ss.cstock[1], ss.cstock[2]),
                               F0_Delta14C = F0_Delta14C,
                               In = In,
                               gam = pars[3],
                               inputFc = Datm,
                               lag = lag,
                               pass = pass)
  } else {
    mod <- TwopSeriesModel14(t = Datm$Date[ix.t],
                             ks = pars[1:2],
                             C0 = c(ss.cstock[1], ss.cstock[2]),
                             F0_Delta14C = F0_Delta14C,
                             In = In,
                             a21 = pars[3],
                             inputFc = Datm,
                             lag = lag,
                             pass = pass)
  }
  
  # get mod values
  C14m <- getF14C(mod)
  C14p <- getF14(mod)
  C14r <- getF14R(mod)
  Ctot <- getC(mod)
  
  if(out == "modFit") {
    # dataframe for modFit fx
    return(data.frame(
      time = Datm$Date[ix.t],
      bulkC = C14m, 
      resp = C14r))
  } else {
    # data frame for plotting
    return(data.frame(
      years = rep(Datm$Date[ix.t], 5),
      d14C = c(C14p[,1], 
               C14p[,2], 
               C14m,
               C14r,
               Datm$NHc14[ix.t]),
      pool = rep(c("fast", "slow", "bulk C", "respiration", "atm"), each = nrow(C14p))))
  }
}

# function for trial and error approach to finding initial parameter set
par.fx <- function(pars, In, lag = 5, out = "plot.df", verbose = TRUE, mod) {
  
  # model matrix
  A <- -1 * diag(pars[1:2])
  if (mod == "2ps") {
    A[2, 1] <- pars[3]
  }
  
  # steady-state stocks
  ss.cstock <- (-1 * solve(A) %*% c(In * pars[3], In * (1 - pars[3])))
  
  # print site and steady-state stocks
  if(verbose) {
    cat(paste0(PMeco, "_", lyr_top, "-", lyr_bot), "\n")
    cat(round(colSums(ss.cstock), 1), " (modeled stocks)\n")
    cat(csoc.19.0_30[[paste0(PMeco, "_", lyr_top, "-", lyr_bot)]][ , "lyr_soc"], " (measured stocks)\n") 
  }
  
  if (mod == "2pp") {
   return(modFun_2p(pars = pars, In = In, lag = lag, out = out, mod = "2pp")) 
  } else {
    return(modFun_2p(pars = pars, In = In, lag = lag, out = out, mod = "2ps")) 
  }
}
```

```{r opt-mod, eval = FALSE}
# Note: this only runs if eval flag switched to TRUE
## Optimize model pars
# Cost function (evaluates error as model vs. obsv, per FME req)
# note that we have to set "pass" to TRUE so SoilR model doesn't fail (neg. resp)
mod.fits.fx <- function(mod, pars, sub, upper, lower) {
  # start loop
  lapply(seq_along(pars[sub]), function(i) {
    # start timer and print PMeco_depth
    start <- Sys.time()
    cat(paste0(names(pars)[sub][i], " parameter fitting\n"))
  
  # define cost function for current iteration
    if (mod == "2pp") {
      mod.Cost <- function(pars) {
        modelOutput <- modFun_2p(pars, in.i[sub][[i]], mod = "2pp")
        cost1 <- modCost(model = modelOutput, obs = obs.bulk.14c[sub][[i]], scaleVar = TRUE)
        return(modCost(model = modelOutput, obs = obs.resp.14c[sub][[i]], cost = cost1))
      }
    } else {
      mod.Cost <- function(pars) {
        modelOutput <- modFun_2p(pars, in.i[sub][[i]], mod = "2ps")
        cost1 <- modCost(model = modelOutput, obs = obs.bulk.14c[sub][[i]], scaleVar = TRUE)
        return(modCost(model = modelOutput, obs = obs.resp.14c[sub][[i]], cost = cost1))
      }
    }
    
    # fit pars
    fit <- tryCatch(
      modFit(f = mod.Cost,
             p = pars[sub][[i]],
             method = 'Nelder-Mead',
             upper = upper, 
             lower = lower),
      error = function (e) {cat("ERROR :", conditionMessage(e), "\n")})
    
    # End timer and print elapsed time
    end <- Sys.time()
    cat(paste0("time: ", end - start, "\n"))
    
    # Return fitted parameters
    return(fit)
}) 
}

# load initial parameter set
load("../data/derived/modFit_pars/pars.i.2pp_2020-11-16.Rdata")
load("../data/derived/modFit_pars/pars.i.2ps_2020-11-16.Rdata")

# Start with just 0-10 cm depth increment
ix.10 <- seq(1, 27, 3)

## 2pp
# par range [0, 1] for all pars
mod.fits.2pp <- mod.fits.fx(mod = "2pp",
                            pars = pars.i.2pp, 
                            sub = ix.10,
                            upper = c(1, 1, 1),
                            lower = c(0, 0, 0))
names(mod.fits.2pp) <- names(pars.i.2pp)[ix.10]
save(mod.fits.2pp, file = paste0("../data/derived/modFit_pars/", "mod.fits.2pp", "_", Sys.Date(), ".Rdata"))
# constrain gamma to [0.5, 0.95]
mod.fits.2pp.p3.5.95 <- mod.fits.fx(mod = "2pp",
                                    pars = pars.i.2pp,
                                    sub = ix.10,
                                    upper = c(1, 1, 0.951),
                                    lower = c(0, 0, 0.5))
names(mod.fits.2pp.p3.5.95) <- names(pars.i.2pp)[ix.10]
save(mod.fits.2pp.p3.5.95, file = paste0("../data/derived/modFit_pars/", "mod.fits.2pp.p3.5.95", "_", Sys.Date(), ".Rdata"))

## 2ps
# par range [0, 1] for all pars
mod.fits.2ps <- mod.fits.fx(mod = "2ps",
                            pars = pars.i.2ps, 
                            sub = ix.10,
                            upper = c(1, 1, 1),
                            lower = c(0, 0, 0))
names(mod.fits.2ps) <- names(pars.i.2ps)[ix.10]
save(mod.fits.2ps, file = paste0("../data/derived/modFit_pars/", "mod.fits.2ps", "_", Sys.Date(), ".Rdata"))
```

```{r report-par-fit}
# index for 0-10 cm depth increments
ix.10 <- seq(1, 27, 3)

# load initial parameters as needed
if (!exists("pars.i.2pp")) {
 load("../data/derived/modFit_pars/pars.i.2pp_2020-11-16.Rdata") 
}
if (!exists("pars.i.2ps")) {
  load("../data/derived/modFit_pars/pars.i.2ps_2020-11-16.Rdata")  
}

# load fits as needed
if (!exists("mod.fits.2pp")) {
 load(file = "../data/derived/modFit_pars/mod.fits.2pp_2020-11-16.RData")
}
if (!exists("mod.fits.2pp.p3.5.95")) {
  load("../data/derived/modFit_pars/pars.i.2ps_2020-11-16.Rdata")  
}
if (!exists("mod.fits.2ps")) {
 load(file = "../data/derived/modFit_pars/mod.fits.2pp_2020-11-16.RData")
}

## Par estimates
# 2pp
pars.fit.2pp <- lapply(mod.fits.2pp, "[[", 1)
names(pars.fit.2pp) <- names(pars.i.2pp)[ix.10]
# 2pp gam = [.5, .95]
pars.fit.2pp.p3.5.95 <- lapply(mod.fits.2pp.p3.5.95, "[[", 1)
names(pars.fit.2pp.p3.5.95) <- names(pars.i.2pp)[ix.10]
# 2ps
pars.fit.2ps <- lapply(mod.fits.2ps, "[[", 1)
names(pars.fit.2ps) <- names(pars.i.2ps)[ix.10]

## Summary of fits
# 2pp
pars.fit.2pp.sum <- lapply(mod.fits.2pp, function(x) {
  tryCatch(summary(x), 
           error = function (e) {cat("ERROR :", conditionMessage(e), "\n")})
})
names(pars.fit.2pp.sum) <- names(pars.fit.2pp)
# 2ps
pars.fit.2ps.sum <- lapply(mod.fits.2ps, function(x) {
  tryCatch(summary(x), 
           error = function (e) {cat("ERROR :", conditionMessage(e), "\n")})
})
names(pars.fit.2ps.sum) <- names(pars.fit.2ps)

## Summary of errors
# best par set (ssr)
ssr.2pp.df <- data.frame(bind_rows(lapply(mod.fits.2pp, "[", "ssr"), .id = "PMeco_depth"))
ssr.2ps.df <- data.frame(bind_rows(lapply(mod.fits.2ps, "[", "ssr"), .id = "PMeco_depth"))
# mean residuals, by var (var_ms)
var_ms.df.fx <- function(mod.fits.ls) {
  df <- data.frame(bind_rows(lapply(mod.fits.ls, "[", "var_ms"), .id = "PMeco_depth"))
  df$var <- rep(c("resp", "bulkC"), nrow(df)/2)
  df$var_ms <- round(df$var_ms, 5)
  return(df)
}
var_ms.2pp.df <- var_ms.df.fx(mod.fits.2pp)
var_ms.2ps.df <- var_ms.df.fx(mod.fits.2ps)

# bind fitted pars with initial pars into data frame for plotting/summarizing
par.fit.df.fx <- function(mod, pars.fit, pars.i) {
  df <- bind_rows(
    lapply(
      mapply(rbind, 
             pars.fit,
             pars.i,
             SIMPLIFY = FALSE), 
      function(df) {
        df <- data.frame(df)
        if (mod == "2pp") {
          colnames(df) <- c("kfast", "kslow", "gam")
        } else {
          colnames(df) <- c("kfast", "kslow", "a21")
        }
        df$est <- c("fit", "init")
        return(df)
      })
  )
  df$PMeco_depth <- rep(names(pars.i), each = 2)
  df$PM <- substr(df$PMeco_depth, start = 1, stop = 2)
  df$eco <- substr(df$PMeco_depth, start = 3, stop = 4)
  df$depth <- substr(df$PMeco_depth, start = 6, stop = length(df$PMeco_depth))
  return(df)
}


## 2pp
# gam range = [0, 1]
pars.fit.2pp.df <- par.fit.df.fx(mod = "2pp",
                                 pars.fit = pars.fit.2pp,
                                 pars.i = pars.i.2pp[ix.10])
# gam range = [.5, .95]
pars.fit.2pp.p3.5.95.df <- par.fit.df.fx(mod = "2pp",
                                         pars.fit = pars.fit.2pp.p3.5.95,
                                         pars.i = pars.i.2pp[ix.10])
## 2ps
# a21 range = [0, 1]
pars.fit.2ps.df <- par.fit.df.fx(mod = "2ps",
                                 pars.fit = pars.fit.2ps,
                                 pars.i = pars.i.2ps[ix.10])

## Summarize by PM, depth
# 2pp
# PM/depth
pars.fit.2pp.df.PM <- suppressMessages(
  pars.fit.2pp.df %>%
    filter(est == "fit") %>%
    select(!c(est, PMeco_depth, eco)) %>%
    group_by(PM, depth) %>%
    summarize_all(list(mean = mean, sd = sd)) %>%
    mutate_if(is.numeric, format, digits = 2)
)
# # print table
# knitr::kable(pars.fit.2pp.df.PM,
#              caption = "Mean parameter estimates by parent material (PM)",
#              align = "c")
# eco/depth
pars.fit.2pp.df.eco <- suppressMessages(
  pars.fit.2pp.df %>%
    filter(est == "fit") %>%
    select(!c(est, PMeco_depth, PM)) %>%
    group_by(eco, depth) %>%
    summarize_all(list(mean = mean, sd = sd)) %>%
    mutate_if(is.numeric, format, digits = 2)
)
# # print table
# knitr::kable(pars.fit.2pp.df.eco,
#              caption = "Mean parameter estimates by ecosystem (eco)",
#              align = "c")
```

```{r plot-modFit-pars}
## plot pars
par.plot.fx <- function(mod, depth, par.df, initial = FALSE) {
  par.df %>%
    { if (initial == TRUE) . else filter(., est == "fit") } %>%
    filter(depth == depth) %>%
    pivot_longer(!(est:depth), names_to = "par", values_to = "value") %>%
    mutate(PM = factor(PM),
           eco = factor(eco, levels = c("pp", "wf", "rf"))) %>%
    ggplot(., aes(par, value, color = PM, shape = eco)) +
    # geom_jitter(size = 4) +
    geom_point(size = 4, position = position_dodge(width = .5)) +
    scale_color_manual(name = "parent material",
                      labels = c("AN" = "andesite",
                                 "BS" = "basalt",
                                 "GR" = "granite"),
                      values = c("AN" = "blue", 
                                 "BS" = "red", 
                                 "GR" = "darkgray")) +
    facet_wrap(. ~ par, scales = "free") +
    ggtitle(paste0("modFit pars ", mod, " 0-10 cm")) +
    theme_bw() +
    theme(panel.grid.minor = element_blank())
}
# 0-10
# 2pp
par.plot.fx(mod = "2pp",
            depth = "0-10",
            par.df = pars.fit.2pp.df,
            initial = FALSE)
# 2ps
par.plot.fx(mod = "2ps",
            depth = "0-10",
            par.df = pars.fit.2ps.df,
            initial = FALSE)
# 2pp, gam = [.5,.95]
par.plot.fx(mod = "2pp (gam = [0.5, 0.95])",
            depth = "0-10",
            par.df = pars.fit.2pp.p3.5.95.df,
            initial = FALSE)
```

```{r fx-fit-soc-in}
## adjust inputs to match modeled stocks
# function for calculating steady-state SOC stocks
soc.fx <- function(pars, In) {
  colSums(-1 * solve(-1 * diag(pars[1:2])) %*% c(In * pars[3], In * (1 - pars[3])))
}

in.fit.fx <- function(pars, initialIn, SOC) {
  # sequence of possible input values
  if  (SOC < soc.fx(pars, initialIn)) {
    ins <- seq(.01, 
               initialIn, 
               .01)
    } else {
      ins <- seq(initialIn, 
                 SOC, 
                 .01)
    }
  # modeled stocks
  soc_mod <- lapply(seq_along(ins), function(j) {
    soc.fx(pars, ins[j])
  })
  ix <- which.min(abs(unlist(soc_mod) - SOC))
  return(ins[ix])
}
```

```{r fit-soc-in}
## Find best inputs
# 2pp
in.fit.2pp <- lapply(seq_along(pars.fit.2pp), function(i) {
  PMeco_depth <- names(pars.fit.2pp)[i]
  SOC <- csoc.19.0_30[[PMeco_depth]][ ,"lyr_soc"]
  return(in.fit.fx(pars.fit.2pp[[i]], in.i[ix.10][[i]], SOC))
})
names(in.fit.2pp) <- names(mod.fits.2pp)
# 2pp gam = [.5, .95]
in.fit.2pp.p3.5.95 <- lapply(seq_along(pars.fit.2pp.p3.5.95), function(i) {
  PMeco_depth <- names(pars.fit.2pp.p3.5.95)[i]
  SOC <- csoc.19.0_30[[PMeco_depth]][ ,"lyr_soc"]
  return(in.fit.fx(pars.fit.2pp.p3.5.95[[i]], in.i[ix.10][[i]], SOC))
})
names(in.fit.2pp.p3.5.95) <- names(mod.fits.2pp.p3.5.95)
# 2ps
in.fit.2ps <- lapply(seq_along(pars.fit.2ps), function(i) {
  PMeco_depth <- names(pars.fit.2ps)[i]
  SOC <- csoc.19.0_30[[PMeco_depth]][ ,"lyr_soc"]
  return(in.fit.fx(pars.fit.2ps[[i]], in.i[ix.10][[i]], SOC))
})
names(in.fit.2ps) <- names(mod.fits.2ps)

## Calc modeled stocks and compare with measured stocks
# 2pp
mod.socs.2pp.ls <- lapply(seq_along(pars.fit.2pp), function(i) {
  A <- -1 * diag(pars.fit.2pp[[i]][1:2])
  return(-1 * solve(A) %*% c(in.fit.2pp[[i]] * pars.fit.2pp[[i]][3], in.fit.2pp[[i]] * (1 - pars.fit.2pp[[i]][3])))
})
names(mod.socs.2pp.ls) <- names(pars.fit.2pp)
socs.2pp.ls <- mapply(cbind,
                      csoc.19.0_30[ix.10], 
                      lapply(mod.socs.2pp.ls, colSums), 
                      SIMPLIFY = FALSE)
# 2pp gam = [.5, .95]
mod.socs.2pp.p3.5.95.ls <- lapply(seq_along(pars.fit.2pp.p3.5.95), function(i) {
  A <- -1 * diag(pars.fit.2pp.p3.5.95[[i]][1:2])
  return(-1 * solve(A) %*% c(in.fit.2pp.p3.5.95[[i]] * pars.fit.2pp.p3.5.95[[i]][3], in.fit.2pp.p3.5.95[[i]] * (1 - pars.fit.2pp.p3.5.95[[i]][3])))
})
names(mod.socs.2pp.p3.5.95.ls) <- names(pars.fit.2pp.p3.5.95)
socs.2pp.p3.5.95ls <- mapply(cbind,
                             csoc.19.0_30[ix.10], 
                             lapply(mod.socs.2pp.p3.5.95.ls, colSums), 
                             SIMPLIFY = FALSE)
# 2ps
mod.socs.2ps.ls <- lapply(seq_along(pars.fit.2ps), function(i) {
  A <- -1 * diag(pars.fit.2ps[[i]][1:2])
  return(-1 * solve(A) %*% c(in.fit.2ps[[i]] * pars.fit.2ps[[i]][3], in.fit.2ps[[i]] * (1 - pars.fit.2ps[[i]][3])))
})
names(mod.socs.2ps.ls) <- names(pars.fit.2ps)
socs.2ps.ls <- mapply(cbind,
                      csoc.19.0_30[ix.10], 
                      lapply(mod.socs.2ps.ls, colSums), 
                      SIMPLIFY = FALSE)

## Return data frames of model fits with adjusted inputs and optimal parameters
# 2pp
Twopp.fits <- lapply(seq_along(pars.fit.2pp), function(i) {
  par.fx(pars.fit.2pp[[i]], in.fit.2pp[[i]], verbose = FALSE, mod = "2pp")
})
names(Twopp.fits) <- names(pars.fit.2pp)
# 2pp gam = [.5, .95]
Twopp.p3.5.95.fits <- lapply(seq_along(pars.fit.2pp.p3.5.95), function(i) {
  par.fx(pars.fit.2pp.p3.5.95[[i]], in.fit.2pp.p3.5.95[[i]], verbose = FALSE, mod = "2pp")
})
names(Twopp.p3.5.95.fits) <- names(pars.fit.2pp.p3.5.95)
# 2ps
Twops.fits <- lapply(seq_along(pars.fit.2ps), function(i) {
  par.fx(pars.fit.2ps[[i]], in.fit.2ps[[i]], verbose = FALSE, mod = "2ps")
})
names(Twops.fits) <- names(pars.fit.2ps)
```

```{r plot-soc-stocks}
# Plot optimized model SOC stocks
mod.socs.df.fx <- function(mod, mod.socs.ls, pools) {
  n <- vapply(mod.socs.ls, nrow, numeric(1))
  return(data.frame(SOC = do.call(rbind, mod.socs.ls),
                    pool = rep(pools, length(mod.socs.ls)),
                    PMeco_depth = rep(names(mod.socs.ls), n),
                    Model = rep(mod, sum(n))))       
}
# run fx
mod.socs.2p.df <- rbind(mod.socs.df.fx("2pp", mod.socs.2pp.ls, c("fast", "slow")),
                        mod.socs.df.fx("2ps", mod.socs.2ps.ls, c("fast", "slow"))
                        # ,mod.socs.df.fx("2pp [.5,.95]", mod.socs.2pp.p3.5.95.ls, c("fast", "slow"))
                        )

# plot
mod.socs.2p.df %>%
  mutate(PM = substr(PMeco_depth, 1, 2),
         eco = substr(PMeco_depth, 3, 4)) %>%
  ggplot(., aes(pool, SOC, fill = Model)) +
  geom_col(position = position_dodge()) +
  facet_grid(rows = vars(eco), cols = vars(PM)) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```

```{r plot-opt-mod-2pp}
# plot fx
Twop.fit.plot.fx <- function(fit1, fit1.name, fit2, fit2.name, fit3 = NULL, fit3.name = NULL) {
  lapply(seq_along(fit1), function(i) {
    PMeco <- substr(names(fit1)[i], 1, 4)
    lyr_bot <- substr(names(fit1)[i], 
                      nchar(names(fit1)[i]) - 1, 
                      nchar(names(fit1)[i]))
    lyr_top <- ifelse(lyr_bot == 10, 0, ifelse(lyr_bot == 20, 10, 20))
    con.df <- con.df.fx(PMeco, lyr_bot)
    plot.df <- rbind(fit1[[i]],
                     fit2[[i]],
                     fit3[[i]])
    plot.df$Model <- factor(c(rep(fit1.name, nrow(fit1[[i]])),
                              rep(fit2.name, nrow(fit2[[i]])),
                              rep(fit3.name, nrow(fit3[[i]]))),
                            levels = c(fit1.name, fit2.name, fit3.name))
    return(plot.df %>%
             filter(pool == "bulk C" | pool == "respiration" | pool == "atm") %>%
             ggplot(., aes(years, d14C, color = pool)) +
             geom_path(aes(linetype = Model)) +
             geom_errorbar(data = con.df,
                           aes(x = Year,
                               ymin = d14c_l, 
                               ymax = d14c_u, 
                               color = pool), 
                           width = .1,
                           inherit.aes = FALSE) +
             geom_point(data = con.df, aes(Year, d14c, color = pool), size = 3) +
             scale_color_manual(
               name = "Model pool",
               values = c("atm" = 8,
                          "bulk C" = "black",
                          "fast" = "#D81B60",
                          "slow" = "#1E88E5",
                          "respiration" = "#FFC107")) +
             scale_x_continuous(limits = c(1950, 2022)) +
             ggtitle(paste0(PMeco, "_", lyr_top, "-", lyr_bot, " 2p mod fits")) +
             xlab("Year") +
             ylab(expression(''*Delta*''^14*'C (‰)')) +
             theme_bw() +
             theme(panel.grid = element_blank()))
  })
}
# 2p modFit optimal model comparison
Twop.fits.plots <- Twop.fit.plot.fx(Twopp.fits, "2pp", Twops.fits, "2ps")
Twop.fits.plots
# Twop.fits.plots2 <- Twop.fit.plot.fx(Twops.fits, "2ps", Twopp.fits, "2pp", Twopp.p3.5.95.fits, "2pp gam = [.5, .95]")
# Twop.fits.plots2
```

```{r modFit-2p-comparison}
# compare output of 2pp and 2ps model fits
merge(ssr.2pp.df, ssr.2ps.df, by = "PMeco_depth", suffixes = c("_2pp", "_2ps")) %>%
  mutate(ssr_2pp = round(ssr_2pp, 1),
         ssr_2ps = round(ssr_2ps, 1),
         dif = ssr_2pp - ssr_2ps)
merge(var_ms.2pp.df,
      var_ms.2ps.df,
      by = c("PMeco_depth", "var"),
      suffixes = c("_2pp", "_2ps")) %>%
  mutate(var_ms_2pp = round(var_ms_2pp, 4),
         var_ms_2ps = round(var_ms_2ps, 4),
         dif = var_ms_2pp - var_ms_2ps)

## Plot
# SSR, PM
rbind(ssr.2pp.df, ssr.2ps.df) %>%
  mutate(mod = rep(c("2pp", "2ps"), each = nrow(ssr.2pp.df)),
         PM = substr(PMeco_depth, 1, 2),
         eco = substr(PMeco_depth, 3, 4)) %>%
  group_by(PM, mod) %>%
  summarize(mean.ssr = mean(ssr), sd = sd(ssr)) %>%
  mutate(err_u = mean.ssr + sd/sqrt(3),
         err_l = mean.ssr - sd/sqrt(3)) %>%
  ggplot(., aes(mod, mean.ssr, fill = PM)) +
  geom_col(position = "dodge") +
  geom_errorbar(
    aes(ymax = err_u, ymin = err_l), 
    position = position_dodge(width = .9),
    width = .3) +
  scale_fill_manual(name = "Parent material",
                    labels = c("AN" = "andesite",
                               "BS" = "basalt",
                               "GR" = "granite"),
                    values = c("AN" = "blue", 
                               "BS" = "red", 
                               "GR" = "darkgray")) +
  facet_wrap(. ~ PM) +
  ggtitle("SSR 2-pool models 0-10 cm") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
# SSR, eco
rbind(ssr.2pp.df, ssr.2ps.df) %>%
  mutate(mod = rep(c("2pp", "2ps"), each = nrow(ssr.2pp.df)),
         PM = substr(PMeco_depth, 1, 2),
         eco = substr(PMeco_depth, 3, 4)) %>%
  group_by(eco, mod) %>%
  summarize(mean.ssr = mean(ssr), sd = sd(ssr)) %>%
  mutate(err_u = mean.ssr + sd/sqrt(3),
         err_l = mean.ssr - sd/sqrt(3)) %>%
  ggplot(., aes(mod, mean.ssr, fill = eco)) +
  geom_col(position = "dodge") +
  geom_errorbar(
    aes(ymax = err_u, ymin = err_l), 
    position = position_dodge(width = .9),
    width = .3) +
  facet_wrap(. ~ eco) +
  ggtitle("SSR 2-pool models 0-10 cm (eco)") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())

# var_ms, PM
rbind(var_ms.2pp.df, var_ms.2ps.df) %>%
  mutate(mod = rep(c("2pp", "2ps"), each = nrow(var_ms.2pp.df)),
         PM = substr(PMeco_depth, 1, 2),
         eco = substr(PMeco_depth, 3, 4)) %>%
  group_by(var, PM, mod) %>%
  summarize(mean.var_ms = mean(var_ms), sd = sd(var_ms)) %>%
  mutate(err_u = mean.var_ms + sd/sqrt(3),
         err_l = mean.var_ms - sd/sqrt(3)) %>%
  ggplot(., aes(mod, mean.var_ms, fill = PM)) +
  geom_col(position = "dodge") +
  geom_errorbar(
    aes(ymax = err_u, ymin = err_l), 
    position = position_dodge(width = .9),
    width = .3) +
  scale_fill_manual(name = "Parent material",
                    labels = c("AN" = "andesite",
                               "BS" = "basalt",
                               "GR" = "granite"),
                    values = c("AN" = "blue", 
                               "BS" = "red", 
                               "GR" = "darkgray")) +
  facet_wrap(. ~ var, scales = "free") +
  ggtitle("Residual error 2-pool models 0-10 cm") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
# var_ms, eco
rbind(var_ms.2pp.df, var_ms.2ps.df) %>%
  mutate(mod = rep(c("2pp", "2ps"), each = nrow(var_ms.2pp.df)),
         PM = substr(PMeco_depth, 1, 2),
         eco = substr(PMeco_depth, 3, 4)) %>%
  group_by(var, eco, mod) %>%
  summarize(mean.var_ms = mean(var_ms), sd = sd(var_ms)) %>%
  mutate(err_u = mean.var_ms + sd/sqrt(3),
         err_l = mean.var_ms - sd/sqrt(3)) %>%
  ggplot(., aes(mod, mean.var_ms, fill = eco)) +
  geom_col(position = "dodge") +
  geom_errorbar(
    aes(ymax = err_u, ymin = err_l), 
    position = position_dodge(width = .9),
    width = .3) +
  facet_wrap(. ~ var, scales = "free") +
  ggtitle("Residual error 2-pool models 0-10 cm") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```

```{r ages-tt-modFit}
## System age
# 2pp
SA.2pp.ls <- lapply(seq_along(pars.fit.2pp), function(i) {
  ks <- pars.fit.2pp[[i]][1:2]
  gam <- pars.fit.2pp[[i]][3]
  In <- in.fit.2pp[[i]]
  return(systemAge(A = -1 * diag(ks), u = c(In * gam, In * (1 - gam))))
})
names(SA.2pp.ls) <- names(pars.fit.2pp)
# 2pp gam = [.5, .95]
SA.2pp.p3.5.95.ls <- lapply(seq_along(pars.fit.2pp.p3.5.95), function(i) {
  ks <- pars.fit.2pp.p3.5.95[[i]][1:2]
  gam <- pars.fit.2pp.p3.5.95[[i]][3]
  In <- in.fit.2pp.p3.5.95[[i]]
  return(systemAge(A = -1 * diag(ks), u = c(In * gam, In * (1 - gam))))
})
names(SA.2pp.p3.5.95.ls) <- names(pars.fit.2pp.p3.5.95)
# 2ps
SA.2ps.ls <- lapply(seq_along(pars.fit.2ps), function(i) {
  ks <- pars.fit.2ps[[i]][1:2]
  gam <- pars.fit.2ps[[i]][3]
  In <- in.fit.2ps[[i]]
  return(systemAge(A = -1 * diag(ks), u = c(In * gam, In * (1 - gam))))
})
names(SA.2ps.ls) <- names(pars.fit.2ps)

## Transit time
# 2pp
TT.2pp.ls <- lapply(seq_along(pars.fit.2pp), function(i) {
  ks <- pars.fit.2pp[[i]][1:2]
  gam <- pars.fit.2pp[[i]][3]
  In <- in.fit.2pp[[i]]
  return(transitTime(A = -1 * diag(ks), u = c(In * gam, In * (1 - gam))))
})
names(TT.2pp.ls) <- names(pars.fit.2pp)
# 2pp gam = [.5, .95]
TT.2pp.p3.5.95.ls <- lapply(seq_along(pars.fit.2pp.p3.5.95), function(i) {
  ks <- pars.fit.2pp.p3.5.95[[i]][1:2]
  gam <- pars.fit.2pp.p3.5.95[[i]][3]
  In <- in.fit.2pp.p3.5.95[[i]]
  return(transitTime(A = -1 * diag(ks), u = c(In * gam, In * (1 - gam))))
})
names(TT.2pp.p3.5.95.ls) <- names(pars.fit.2pp.p3.5.95)
# 2ps
TT.2ps.ls <- lapply(seq_along(pars.fit.2ps), function(i) {
  ks <- pars.fit.2ps[[i]][1:2]
  gam <- pars.fit.2ps[[i]][3]
  In <- in.fit.2ps[[i]]
  return(transitTime(A = -1 * diag(ks), u = c(In * gam, In * (1 - gam))))
})
names(TT.2ps.ls) <- names(pars.fit.2ps)
```

```{r SA-TT-comp}
# compare ages and transit times among the two model structures
SA.2p.ls <- list(SA.2pp.ls, SA.2ps.ls, SA.2pp.p3.5.95.ls)
SA.df <- bind_rows(
  lapply(SA.2p.ls, function(ls) {
    lapply(seq_along(ls), function(i) {
      data.frame(age = c(ls[[i]][["meanSystemAge"]],
                         ls[[i]][["meanPoolAge"]]),
                 component = c("system", "fast pool", "slow pool"))
    })
  })
)
SA.df$PMeco_depth <- rep(names(SA.2pp.ls), each = 3, times = length(SA.2p.ls))
SA.df$Model <- rep(c("2pp", "2ps", "2pp [.5, .95]"), each = 27)
TT.2p.ls <- list(TT.2pp.ls, TT.2ps.ls, TT.2pp.p3.5.95.ls)
TT.df <- bind_rows(
  lapply(TT.2p.ls, function(ls) {
    lapply(seq_along(ls), function(i) {
     data.frame(age = ls[[i]][["meanTransitTime"]],
                component = "transit")
    })
  })
)
TT.df$PMeco_depth <- rep(names(TT.2pp.ls), times = length(TT.2p.ls))
TT.df$Model <- rep(c("2pp", "2ps", "2pp [.5, .95]"), each = 9)
SA.TT.df <- rbind(SA.df, TT.df)
SA.TT.df$PM <- substr(SA.TT.df$PMeco_depth, start = 1, stop = 2)
SA.TT.df$eco <- substr(SA.TT.df$PMeco_depth, start = 3, stop = 4)

## Plot ages and transit times
# by PM
SA.TT.df %>%
  select(!c(PMeco_depth, eco)) %>%
  group_by(component, PM, Model) %>%
  summarize_all(list(mean_age = mean, sd = sd)) %>%
  mutate(err_u = mean_age + sd,
         err_l = mean_age - sd) %>%
  ggplot(., aes(Model, mean_age, fill = PM)) +
  geom_col(position = "dodge") +
  # geom_errorbar(
  #   aes(ymax = err_u, ymin = err_l), 
  #   position = position_dodge(width = .9),
  #   width = .3) +
  scale_fill_manual(name = "Parent material",
                    labels = c("AN" = "andesite",
                               "BS" = "basalt",
                               "GR" = "granite"),
                    values = c("AN" = "blue", 
                               "BS" = "red", 
                               "GR" = "darkgray")) +
  facet_wrap(. ~ component, scales = "free") +
  ylab("mean age") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
# by eco
SA.TT.df %>%
  select(!c(PMeco_depth, PM)) %>%
  group_by(component, eco, Model) %>%
  summarize_all(list(mean_age = mean, sd = sd)) %>%
  mutate(err_u = mean_age + sd,
         err_l = mean_age - sd) %>%
  ggplot(., aes(Model, mean_age, fill = eco)) +
  geom_col(position = "dodge") +
  # geom_errorbar(
  #   aes(ymax = err_u, ymin = err_l),
  #   position = position_dodge(width = .9),
  #   width = .3) +
  facet_wrap(. ~ component, scales = "free") +
  ylab("mean age") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```

### Bayesian parameter estimation (MCMC)

This section needs some work.

```{r MCMC-fits, eval = FALSE}
# the following .RData file is generated by script "sra-ts/source/sra-ts-mcmc-bayes.R"
# load(file = "../data/derived/bayes-par-fit-2020-11-06/bayes_fit_2pp-5000itr.RData")

# plot parameter convergence
lapply(bayes_fit_2pp_0_10, plot)

# plot collinearity
lapply(bayes_fit_2pp_0_10, pairs, nsample = floor(iter/4))

## look at model performance
pars.bayes.df <- bind_rows(lapply(seq_along(bayes_fit_2pp_0_10), function(i) {
  df <- data.frame(k1 = unique(bayes_fit_2pp[[i]][["pars"]][, 1]),
                   k2 = unique(bayes_fit_2pp[[i]][["pars"]][, 2]),
                   gam = unique(bayes_fit_2pp[[i]][["pars"]][, 3]))
  df <- cbind(PMeco_depth = rep(names(pars.fit)[test.ix][i]), 
              df)
}))
pars.bayes.df$PM <- factor(substr(pars.bayes.df$PMeco_depth, 1, 2))
pars.bayes.df$eco <- factor(substr(pars.bayes.df$PMeco_depth, 3, 4), levels = c("pp", "wf", "rf"))
summary(lm(k2 ~ PM, pars.bayes.df))
summary(lm(k1 ~ eco, pars.bayes.df))

# best par set
bestPars.bayes.ls <- lapply(bayes_fit_2pp_0_10, function(x) {
  round(data.frame(k1 = x$bestpar[1],
                   k2 = x$bestpar[2],
                   gam = x$bestpar[3]),
        4)
})
bestPars.bayes.df <- cbind(PM = rep(c("AN", "BS", "GR"), each = 3),
                           eco = rep(c("pp", "rf", "wf"), 3),
                           depth = rep("0-10", 9),
                           bind_rows(bestPars.bayes.ls))

# summarize by PM
pars.bayes.PM <- bestPars.bayes.df %>%
  select(!c(eco, depth)) %>%
  group_by(PM) %>%
  summarize_all(list(mean = mean, sd = sd)) %>%
  mutate_if(is.numeric, format, digits = 3)
# summarize by ECO
pars.bayes.eco <- bestPars.bayes.df %>%
  select(!c(PM, depth)) %>%
  group_by(eco) %>%
  summarize_all(list(mean = mean, sd = sd)) %>%
  mutate_if(is.numeric, format, digits = 3)

# plot best pars
bestPars.bayes.df %>%
  pivot_longer(!(PM:depth), names_to = "par", values_to = "value") %>%
  mutate(PM = factor(PM),
         eco = factor(eco, levels = c("pp", "wf", "rf"))) %>%
  ggplot(., aes(par, value, color = PM, shape = eco)) +
  geom_jitter(size = 4) +
  scale_color_manual(name = "parent material",
                    labels = c("AN" = "andesite",
                               "BS" = "basalt",
                               "GR" = "granite"),
                    values = c("AN" = "blue", 
                               "BS" = "red", 
                               "GR" = "darkgray")) +
  facet_wrap(. ~ par, scales = "free") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())

# plot accepted pars by PM and then by eco
pars.bayes.df %>%
  pivot_longer(!c(PM, eco, PMeco_depth), names_to = "par", values_to = "value") %>%
  mutate(PM = factor(PM),
         eco = factor(eco, levels = c("pp", "wf", "rf"))) %>%
  ggplot(., aes(par, value, fill = PM)) +
  geom_boxplot() +
  scale_fill_manual(name = "parent material",
                    labels = c("AN" = "andesite",
                               "BS" = "basalt",
                               "GR" = "granite"),
                    values = c("AN" = "blue", 
                               "BS" = "red", 
                               "GR" = "darkgray")) +
  facet_wrap(. ~ par, scales = "free") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
pars.bayes.df %>%
  pivot_longer(!c(PM, eco, PMeco_depth), names_to = "par", values_to = "value") %>%
  mutate(PM = factor(PM),
         eco = factor(eco, levels = c("pp", "wf", "rf"))) %>%
  ggplot(., aes(par, value, fill = eco)) +
  geom_boxplot() +
  facet_wrap(. ~ par, scales = "free") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```